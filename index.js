const express = require("express");

const allLanguages = [
  {
    name: "ActionScript",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/0/0f/ActionScript_icon.png/220px-ActionScript_icon.png",
    description:
      "ActionScript is an object-oriented programming language originally developed by Macromedia Inc. (later acquired by Adobe Systems). It is influenced by HyperTalk, the scripting language for HyperCard. It is now an implementation of ECMAScript (meaning it is a superset of the syntax and semantics of the language more widely known as JavaScript), though it originally arose as a sibling, both being influenced by HyperTalk. ActionScript is used primarily for the development of websites and software targeting the Adobe Flash Player platform, used on Web pages in the form of embedded SWF files. ActionScript 3 is also used with Adobe AIR system for the development of desktop and mobile applications. The language itself is open-source in that its specification is offered free of charge and both an open source compiler (as part of Apache Flex) and open source virtual machine (Mozilla Tamarin) are available. ActionScript was also used with Scaleform GFx for the development of 3D video game user interfaces and HUDs.",
    Paradigm:
      "Multi-paradigm: object-oriented (prototype-based), functional, imperative, scripting",
    "Designed by": "Gary Grossman",
    Developer: "Macromedia (now dissolved into Adobe Systems)",
    "First appeared": "1998",
    "Stable release": "3.0 / June 27, 2006",
    "Typing discipline": "strong, static",
    Website: "adobe.com/devnet/actionscript/",
    "Filename extension": ".as",
    "Internet media type": "application/ecmascript",
    other_details: {
      type: "programming",
      tm_scope: "source.actionscript.3",
      color: "#882B0F",
      aliases: ["actionscript 3", "actionscript3", "as3"],
      extensions: [".as"],
      ace_mode: "actionscript",
      language_id: 10,
    },
    id: "ydct",
  },
  {
    name: "Ada",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Ada_Mascot_with_slogan.svg/220px-Ada_Mascot_with_slogan.svg.png",
    description:
      'Ada was originally designed by a team led by French computer scientist Jean Ichbiah of CII Honeywell Bull under contract to the United States Department of Defense (DoD) from 1977 to 1983 to supersede over 450 programming languages used by the DoD at that time. Ada was named after Ada Lovelace (1815–1852), who has been credited as the first computer programmer. Ada was originally designed for embedded and real-time systems. The Ada 95 revision, designed by S. Tucker Taft of Intermetrics between 1992 and 1995, improved support for systems, numerical, financial, and object-oriented programming (OOP). Features of Ada include: strong typing, modular programming mechanisms (packages), run-time checking, parallel processing (tasks, synchronous message passing, protected objects, and nondeterministic select statements), exception handling, and generics. Ada 95 added support for object-oriented programming, including dynamic dispatch. The syntax of Ada minimizes choices of ways to perform basic operations, and prefers English keywords (such as "or else" and "and then") to symbols (such as "||" and "&&"). Ada uses the basic arithmetical operators "+", "-", "*", and "/", but avoids using other symbols. Code blocks are delimited by words such as "declare", "begin", and "end", where the "end" (in most cases) is followed by the identifier of the block it closes (e.g., if ... end if, loop ... end loop). In the case of conditional blocks this avoids a dangling else that could pair with the wrong nested if-expression in other languages like C or Java.',
    Paradigm: "Multi-paradigm: structured, imperative, object-oriented",
    Family: "Pascal",
    "Designed by":
      "MIL-STD-1815, Ada 83: Jean Ichbiah Ada 95: Tucker Taft Ada 2005: Tucker Taft Ada 2012: Tucker Taft",
    "First appeared": "February 1980; 41 years ago",
    "Stable release": "Ada 2012 TC1",
    "Typing discipline": "static, strong, safe, nominative",
    OS: "Multi- or cross-platform",
    "Filename extensions": ".adb, .ads",
    Website: "www.adaic.org",
    other_details: {
      type: "programming",
      color: "#02f88c",
      extensions: [".adb", ".ada", ".ads"],
      aliases: ["ada95", "ada2005"],
      ace_mode: "ada",
      language_id: 11,
    },
    id: "SOc3",
  },
  {
    name: "Agda",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Agda%27s_official_logo.svg/220px-Agda%27s_official_logo.svg.png",
    description:
      'Agda is also a proof assistant based on the propositions-as-types paradigm, but unlike Coq, has no separate tactics language, and proofs are written in a functional programming style. The language has ordinary programming constructs such as data types, pattern matching, records, let expressions and modules, and a Haskell-like syntax. The system has Emacs and Atom interfaces but can also be run in batch mode from the command line. Agda is based on Zhaohui Luo\'s unified theory of dependent types (UTT), a type theory similar to Martin-Löf type theory. Agda is named after the Swedish song "Hönan Agda", written by Cornelis Vreeswijk, which is about a hen named Agda. This alludes to the naming of Coq. The main way of defining data types in Agda is via inductive data types which are similar to algebraic data types in non-dependently typed programming languages.',
    Paradigm: "Functional",
    "Designed by": "Ulf Norell; Catarina Coquand (1.0)",
    Developer: "Ulf Norell; Catarina Coquand (1.0)",
    "First appeared": "2007; 15 years ago (1.0 in 1999; 23 years ago)",
    "Stable release": "2.6.2 / June 19, 2021; 6 months ago",
    "Typing discipline":
      "strong, static, dependent, nominal, manifest, inferred",
    "Implementation language": "Haskell",
    OS: "Cross-platform",
    License: "BSD-like",
    "Filename extensions": ".agda, .lagda, .lagda.md, .lagda.rst, .lagda.tex",
    Website: "wiki.portal.chalmers.se/agda",
    other_details: {
      type: "programming",
      color: "#315665",
      extensions: [".agda"],
      ace_mode: "text",
      language_id: 12,
    },
    id: "KaYt",
  },
  {
    name: "Keysight VEE",
    description:
      "Keysight VEE is a graphical dataflow programming software development environment from Keysight Technologies for automated test, measurement, data analysis and reporting. VEE originally stood for Visual Engineering Environment and developed by HP designated as HP VEE; it has since been officially renamed to Keysight VEE. Keysight VEE has been widely used in various industries, serving the entire stage of a product lifecycle, from design, validation to manufacturing. It is optimized in instrument control and automation with test and measurement devices such as data acquisition instruments like digital voltmeters and oscilloscopes, and source devices like signal generators and programmable power supplies.  A detailed list of features for each version can be found under the References section. A VEE program consists of multiple connected VEE objects (sometimes called devices). Each VEE object consists of different types of pins, namely data pins, sequence pins, execute pins (XEQ), control pins and error pins. Data pins govern the data flow propagation while sequence pins determine object execution order.",
    "Developer(s)": "Keysight Technologies",
    "Operating system": "Microsoft Windows",
    Type: "Integrated Development Environment",
    License: "Proprietary commercial software",
    Website: "https://www.keysight.com/us/en/product/W4000D/vee-pro-9-33.html",
    id: "jzGA",
  },
  {
    name: "AIMMS",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/2/26/AIMMS_logo.png/220px-AIMMS_logo.png",
    description:
      "It has two main product offerings that provide modeling and optimization capabilities across a variety of industries. The AIMMS Prescriptive Analytics Platform allows advanced users to develop optimization-based applications and deploy them to business users. AIMMS SC Navigator, launched in 2017, is built on the AIMMS Prescriptive Analytics Platform and provides configurable Apps for supply chain teams. SC Navigator provides supply chain analytics to non-advanced users. AIMMS B.V. was founded in 1989 by mathematician Johannes Bisschop under the name of Paragon Decision Technology. His vision was to make optimization more approachable by building models rather than programming. In Bisschop’s view, modeling was able to build the bridge between the people who had problems and the people helping them solve those problems. AIMMS began as a software system designed for modeling and solving large-scale optimization and scheduling-type problems. AIMMS is considered to be one of the five most important algebraic modeling languages. Bisschop was awarded with INFORMS Impact Prize for his work in this language.",
    "Designed by": "Johannes J. Bisschop Marcel Roelofs",
    Developer: "AIMMS B.V. (formerly named Paragon Decision Technology B.V.)",
    Website: "AIMMS home page",
    id: "VnCI",
  },
  {
    name: "Aldor",
    description:
      "Aldor combines imperative, functional, and object-oriented features. It has an elaborate type system, allowing types to be used as first-class values. Aldor's syntax is heavily influenced by Pascal, but it is optionally indentation-sensitive, using whitespace characters and the off-side rule, like Python. In its current implementation, it is compiled, but an interactive listener is provided. Aldor is distributed as free and open-source software, under the Apache License 2.0. The Hello world program looks like this: Example of dependent types (from the User Guide):",
    Paradigm:
      "Multi-paradigm: object-oriented, functional, imperative, dependent typed, logic",
    "Designed by":
      "Richard Dimick Jenks, Barry Trager, Stephen Watt, James Davenport, Robert Sutor, Scott Morrison",
    Developer: "Thomas J. Watson Research Center",
    "First appeared": "1990; 32 years ago",
    "Stable release": "1.0.3",
    "Preview release": "1.1.0",
    Platform: "Axiom computer algebra system",
    OS: "Linux, Solaris, Windows",
    License: "Aldor Public 2.0, Apache 2.0",
    "Filename extensions": ".al, .as",
    Website: "www.aldor.org",
    id: "SFiQ",
  },
  {
    name: "Alef",
    description:
      "Alef appeared in the first and second editions of Plan 9, but was abandoned during development of the third edition. Rob Pike later explained Alef's demise by pointing to its lack of automatic memory management, despite Pike's and other people's urging Winterbottom to add garbage collection to the language; also, in a February 2000 slideshow, Pike noted: \"…although Alef was a fruitful language, it proved too difficult to maintain a variant language across multiple architectures, so we took what we learned from it and built the thread library for C.\" Alef was superseded by two programming environments. The Limbo programming language can be considered a direct successor of Alef and is the most commonly used language in the Inferno operating system. The Alef concurrency model was replicated in the third edition of Plan 9 in the form of the libthread library, which makes some of Alef's functionality available to C programs and allowed existing Alef programs (such as Acme) to be translated. This example was taken from the Alef reference manual. The piece illustrates the use of tuple data type.  ",
    Paradigm: "compiled, concurrent, structured",
    "Designed by": "Phil Winterbottom",
    "First appeared": "1992",
    "Typing discipline": "Static, strong",
    OS: "Plan 9 from Bell Labs",
    id: "X5bO",
  },
  {
    name: "ALF",
    description:
      "ALF was designed to be genuine integration of both programming paradigms, and thus any functional expression can be used in a goal literal and arbitrary predicates can occur in conditions of equations. ALF's operational semantics is based on the resolution rule to solve literals and narrowing to evaluate functional expressions. In order to reduce the number of possible narrowing steps, a leftmost-innermost basic narrowing strategy is used which, it is claimed, can be efficiently implemented.[citation needed] Terms are simplified by rewriting before a narrowing step is applied and equations are rejected if the two sides have different constructors at the top. Rewriting and rejection are supposed to result in a large reduction of the search tree and produce an operational semantics that is more efficient than Prolog's resolution strategy. Similarly to Prolog, ALF uses a backtracking strategy corresponding to a depth-first search in the derivation tree. The ALF system was designed to be an efficient implementation of the combination of resolution, narrowing, rewriting, and rejection. ALF programs are compiled into instructions of an abstract machine. The abstract machine is based on the Warren Abstract Machine (WAM) with several extensions to implement narrowing and rewriting. In the current ALF implementation programs of this abstract machine are executed by an emulator written in C. In the Carnegie Mellon University Artificial Intelligence Repository, ALF is included as an AI programming language, in particular as a functional/logic programming language Prolog implementation. A user manual describing the language and the use of the system is available. The ALF System runs under Unix and is available under a custom proprietary software license that grants the right to use for \"evaluation, research and teaching purposes\" but not commercial or military use.  ",
    Paradigm: "multi-paradigm: logic, functional",
    Website: "Getting and installing ALF",
    id: "-5_x",
  },
  {
    name: "ALGOL 58",
    description:
      '"The Zurich ACM-GAMM Conference had two principal motives in proposing the IAL: (a) To provide a means of communicating numerical methods and other procedures between people, and (b) To provide a means of realizing a stated process on a variety of machines..." ALGOL 58 introduced the fundamental notion of the compound statement, but it was restricted to control flow only, and it was not tied to identifier scope in the way that Algol 60\'s blocks were. Bauer attributes the name to Hermann Bottenbruch, who coined the term algorithmic language (algorithmische Sprache) in 1957, "at least in Germany". There were proposals for a universal language by the Association for Computing Machinery (ACM) and also by the German Gesellschaft für Angewandte Mathematik und Mechanik ("Society of Applied Mathematics and Mechanics") (GAMM). It was decided to organize a joint meeting to combine them. The meeting took place from May 27 to June 2, 1958, at ETH Zurich and was attended by the following people:',
    Paradigm: "procedural, imperative, structured",
    Family: "ALGOL",
    "Designed by":
      "Friedrich L. Bauer, Hermann Bottenbruch, Heinz Rutishauser, Klaus Samelson, John Backus, Charles Katz, Alan Perlis, Joseph Henry Wegstein",
    "First appeared": "1958; 64 years ago",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    id: "4Jyo",
  },
  {
    name: "ALGOL 60",
    description:
      'Niklaus Wirth based his own ALGOL W on ALGOL 60 before moving to develop Pascal. Algol-W was intended to be the next generation ALGOL but the ALGOL 68 committee decided on a design that was more complex and advanced rather than a cleaned simplified ALGOL 60. The official ALGOL versions are named after the year they were first published. Algol 68 is substantially different from Algol 60 and was criticised partially for being so, so that in general "Algol" refers to dialects of Algol 60. ALGOL 60 – with COBOL – were the first languages to seek standardization. ALGOL 60 was used mostly by research computer scientists in the United States and in Europe. Its use in commercial applications was hindered by the absence of standard input/output facilities in its description and the lack of interest in the language by large computer vendors. ALGOL 60 did however become the standard for the publication of algorithms and had a profound effect on future language development. John Backus developed the Backus normal form method of describing programming languages specifically for ALGOL 58. It was revised and expanded by Peter Naur for ALGOL 60, and at Donald Knuth\'s suggestion renamed Backus–Naur form.',
    Paradigms: "procedural, imperative, structured",
    Family: "ALGOL",
    "Designed by":
      "Backus, Bauer, Green, Katz, McCarthy, Naur, Perlis, Rutishauser, Samelson, van Wijngaarden, Vauquois, Wegstein, Woodger",
    "First appeared": "1960; 62 years ago",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    id: "qLme",
  },
  {
    name: "ALGOL 68",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/3/35/Algol68RevisedReportCover.jpg/220px-Algol68RevisedReportCover.jpg",
    description:
      'ALGOL 68 (short for Algorithmic Language 1968) is an imperative programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics. The complexity of the language\'s definition, which runs to several hundred pages filled with non-standard terminology, made compiler implementation difficult and it was said it had "no implementations and no users". This was only partly true; ALGOL 68 did find use in several niche markets, notably in the United Kingdom where it was popular on International Computers Limited (ICL) machines, and in teaching roles. Outside these fields, use was relatively limited. Nevertheless, the contributions of ALGOL 68 to the field of computer science have been deep, wide-ranging and enduring, although many of these contributions were only publicly identified when they had reappeared in subsequently developed programming languages. Many languages were developed specifically as a response to the perceived complexity of the language, the most notable being Pascal, or were reimplementations for specific roles, like Ada. Many languages of the 1970s trace their design specifically to ALGOL 68, selecting some features while abandoning others that were considered too complex or out-of-scope for given roles. Among these is the language C, which was directly influenced by ALGOL 68, especially by its strong typing and structures. Most modern languages trace at least some of their syntax to either C or Pascal, and thus directly or indirectly to ALGOL 68.',
    Paradigms: "Multi-paradigm: concurrent, imperative",
    Family: "ALGOL",
    "Designed by":
      "A. van Wijngaarden, B. J. Mailloux, J. E. L. Peck and C. H. A. Koster, et al.",
    "First appeared": "Final Report: 1968; 54 years agor0",
    "Stable release": "Algol 68/RR / Revised Report: 1973; 49 years agor1",
    "Typing discipline": "static, strong, safe, structural",
    Scope: "Lexical",
    id: "_0_s",
  },
  {
    name: "ALGOL W",
    description:
      "ALGOL W is a programming language. It is based on a proposal for ALGOL X by Niklaus Wirth and Tony Hoare as a successor to ALGOL 60. ALGOL W is a relatively simple upgrade of the original ALGOL 60, adding string, bitstring, complex number and reference to record data types and call-by-result passing of parameters, introducing the while statement, replacing switch with the case statement, and generally tightening up the language. Wirth's entry was considered too little of an advance over ALGOL 60, and the more complex entry from Adriaan van Wijngaarden was selected in a highly contentious meeting. After the selection, several members of the IFIP Working Group 2.1 quit. Wirth published his version as A contribution to the development of ALGOL. With a number of small additions, this became ALGOL W. Wirth supervised a high quality implementation for the IBM System/360 at Stanford University that was widely distributed. The implementation was written in PL360, an ALGOL-like assembly language designed by Wirth. The implementation includes influential debugging and profiling abilities. ALGOL W served as the basis for the Pascal language, and the syntax of ALGOL W will be immediately familiar to anyone with Pascal experience. The key differences are improvements to record handling in Pascal, and, oddly, the loss of ALGOL W's ability to define the length of an array at runtime, which is one of Pascal's most-complained-about features.",
    Paradigms: "Multi-paradigm: procedural, imperative, structured",
    Family: "ALGOL",
    "Designed by": "Niklaus Wirth, Tony Hoare",
    "First appeared": "1966; 56 years ago",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    "Implementation language": "PL360",
    Platform: "IBM System/360",
    OS: "Linux",
    id: "VGvw",
  },
  {
    name: "Alice",
    description:
      "Alice extends Standard ML in a number of ways that distinguish it from its predecessor. Alice provides concurrency features as part of the base language through the use of a future type that represents a value being provided by an independent thread of execution. A thread that uses a future value will block on an attempt to access the value until the thread performing it has completed the computation. A related concept is also provided termed a promise, allowing a thread to provide a future value that it will compute to another thread. Future and promise typed variables are used to implement data-flow synchronizing. Like the Haskell functional language, Alice provides facilities to allow a lazy evaluation strategy in programs, unlike the traditional eager evaluation strategy of Standard ML. While Haskell uses the lazy model by default, Alice uses an eager evaluation model by default, needing an explicit programming statement for a computation to evaluate lazily. The Alice implementation from Saarland University uses the Simple Extensible Abstract Machine (SEAM) virtual machine. It is free software, and features just-in-time compilation to bytecode and native code for the x86 architecture. Early versions of Alice ran on the Mozart Programming System (Oz) virtual machine (VM), allowing interfacing between Alice and Oz code.",
    Paradigm: "Multi-paradigm: imperative, functional, distributed, concurrent",
    "Designed by": "Saarland University",
    "First appeared": "2000; 22 years ago",
    "Stable release": "1.4 / May 3, 2007; 14 years ago",
    "Typing discipline": "strong, static, inferred",
    OS: "Cross-platform",
    License: "MIT",
    Website: "www.ps.uni-saarland.de/alice",
    id: "TzVq",
  },
  {
    name: "Alma-0",
    description:
      "Alma-0 is a multi-paradigm computer programming language. This language is an augmented version of the imperative Modula-2 language with logic-programming features and convenient backtracking ability. It is small, strongly typed, and combines constraint programming, a limited number of features inspired by logic programming and supports imperative paradigms. The language advocates declarative programming. The designers claim that search-oriented solutions built with it are substantially simpler than their counterparts written in purely imperative or logic programming style. Alma-0 provides natural, high-level constructs for building search trees. Since the designers of Alma-0 wanted to create a distinct and substantially simpler proposal than prior attempts to integrate declarative programming constructs (such as automatic backtracking) into imperative programming, the design of Alma-0 was guided by four principles: Alma-0 can be viewed not only as a specific and concrete programming language proposal, but also as an example of a generic method for extending any imperative programming language with features that support declarative programming. The feasibility of the Alma-0 approach has been demonstrated through a full implementation of the language (including a description of its semantics) for a subset of Modula-2.",
    Paradigm: "multi-paradigm: constraint, imperative, logic",
    Family: "Wirth Modula",
    "Designed by":
      "Krzysztof Apt, Marc Bezem, Jacob Brunekree, Vincent Partington, Andrea Schaerf",
    Developer: "Centrum Wiskunde & Informatica",
    "First appeared": "1997; 25 years ago",
    "Typing discipline": "static",
    Scope: "Lexical (static)",
    Website: "www.cwi.nl/en/alma",
    id: "BSdv",
  },
  {
    name: "Amiga E",
    description:
      'Amiga E is a combination of many features from a number of languages, but follows the original C programming language most closely in terms of basic concepts. Amiga E\'s main benefits are fast compilation (allowing it to be used in place of a scripting language), very readable source code, flexible type system, powerful module system, exception handling (not C++ variant) and Object oriented programming. A "hello world" program in Amiga E looks like: Amiga E was used to create the core of the popular Amiga graphics software Photogenics. 1993: The first public release of Amiga E.',
    id: "MXqz",
  },
  {
    name: "AMOS",
    description:
      "AMOS is a descendant of STOS BASIC for the Atari ST. AMOS BASIC was first produced in 1990. AMOS competed on the Amiga platform with Acid Software's Blitz BASIC. Both BASICs differed from other dialects on different platforms, in that they allowed the easy creation of fairly demanding multimedia software, with full structured code and many high-level functions to load images, animations, sounds and display them in various ways. The original AMOS was a BASIC interpreter which, whilst working fine, suffered the same disadvantages of any language being run interpretively. By all accounts, AMOS was extremely fast among interpreted languages, being speedy enough that an extension called AMOS 3D could produce playable 3D games even on plain 7 MHz 68000 Amigas. Later, an AMOS compiler was developed that further increased speed. AMOS could also run MC68000 machine code, loaded into a program's memory banks. To simplify animation of sprites, AMOS included the AMOS Animation Language (AMAL), a compiled sprite scripting language which runs independently of the main AMOS BASIC program. It was also possible to control screen and \"rainbow\" effects using AMAL scripts. AMAL scripts in effect created CopperLists, small routines executed by the Amiga's Agnus chip.",
    Paradigm: "Imperative, Procedural",
    Developer: "François Lionet and Constantin Sotiropoulos",
    "First appeared": "1990; 32 years ago",
    "Typing discipline": "Static",
    OS: "AmigaOS",
    License: "BSD style license",
    Website: "AMOS and STOS",
    id: "UOmc",
  },
  {
    name: "AMPL",
    image:
      "https://upload.wikimedia.org/wikipedia/en/b/b6/AMPL_%28textbook_cover%29.jpg",
    description:
      "AMPL (A Mathematical Programming Language) is an algebraic modeling language to describe and solve high-complexity problems for large-scale mathematical computing (i.e., large-scale optimization and scheduling-type problems). It was developed by Robert Fourer, David Gay, and Brian Kernighan at Bell Laboratories. AMPL supports dozens of solvers, both open source and commercial software, including CBC, CPLEX, FortMP, MINOS, IPOPT, SNOPT, KNITRO, and LGO. Problems are passed to solvers as nl files. AMPL is used by more than 100 corporate clients, and by government agencies and academic institutions. One advantage of AMPL is the similarity of its syntax to the mathematical notation of optimization problems. This allows for a very concise and readable definition of problems in the domain of optimization. Many modern solvers available on the NEOS Server (formerly hosted at the Argonne National Laboratory, currently hosted at the University of Wisconsin, Madison) accept AMPL input. According to the NEOS statistics AMPL is the most popular format for representing mathematical programming problems. AMPL features a mix of declarative and imperative programming styles. Formulating optimization models occurs via declarative language elements such as sets, scalar and multidimensional parameters, decision variables, objectives and constraints, which allow for concise description of most problems in the domain of mathematical optimization. Procedures and control flow statements are available in AMPL for",
    Paradigm: "Multi-paradigm: declarative, imperative",
    "Designed by": "Robert Fourer David Gay Brian Kernighan Bell Labs",
    Developer: "AMPL Optimization, Inc.",
    "First appeared": "1985; 37 years ago",
    "Stable release": "20211222 / 22 December 2021; 24 days ago",
    OS: "Cross-platform: Linux, macOS, Solaris, AIX, Windows",
    License:
      "Proprietary (translator), free and open-source (AMPL Solver Library)",
    "Filename extensions": ".mod, .dat, .run",
    Website: "www.ampl.com",
    other_details: {
      type: "programming",
      color: "#E6EFBB",
      extensions: [".ampl", ".mod"],
      tm_scope: "source.ampl",
      ace_mode: "text",
      language_id: 3,
    },
    id: "1P-T",
  },
  {
    name: "Analitik",
    description:
      "Distinctive features of the language are abstract data types, calculations in arbitrary algebras, and analytic transformations. It was implemented on MIR-2 machines. Later, a version of Analitik-74 was developed, implemented on MIR-3 machines. At the moment, the language exists as a computer algebra system, Analitik-2010, which is being developed jointly by the Institute of Mathematical Machines and Systems of the National Academy of Sciences of Ukraine and the Poltava National Technical University.",
    Paradigm:
      "A distinctive feature of the language are abstract data types, calculations in arbitrary algebras, and analytic transformations.",
    "Designed by": "Victor Glushkov & Co",
    Developer: "Poltava National Technical University",
    "First appeared": "January 1, 1968; 54 years ago",
    Website: "About Analitik",
    id: "Ofl8",
  },
  {
    name: "Apache Pig",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/b/bc/Apache_Pig_Logo.svg/250px-Apache_Pig_Logo.svg.png",
    description:
      "Apache Pig was originally developed at Yahoo Research around 2006 for researchers to have an ad hoc way of creating and executing MapReduce jobs on very large data sets. In 2007, it was moved into the Apache Software Foundation. Regarding the naming of the Pig programming language, the name was chosen arbitrarily and stuck because it was memorable, easy to spell, and for novelty. The story goes that the researchers working on the project initially referred to it simply as 'the language'. Eventually they needed to call it something. Off the top of his head, one researcher suggested Pig, and the name stuck. It is quirky yet memorable and easy to spell. While some have hinted that the name sounds coy or silly, it has provided us with an entertaining nomenclature, such as Pig Latin for the language, Grunt for the shell, and PiggyBank for the CPAN-like shared repository. Below is an example of a \"Word Count\" program in Pig Latin:",
    "Developer(s)": "Apache Software Foundation, Yahoo Research",
    "Initial release": "September 11, 2008; 13 years ago",
    "Stable release": "0.17.0 / June 19, 2017; 4 years ago",
    Repository: "svn.apache.org/repos/asf/pig/ ",
    "Operating system": "Microsoft Windows, OS X, Linux",
    Type: "Data analytics",
    License: "Apache License 2.0",
    Website: "pig.apache.org",
    id: "2kHw",
  },
  {
    name: "salesforce.com, inc.",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Salesforce.com_logo.svg/220px-Salesforce.com_logo.svg.png",
    description:
      "Salesforce is an American cloud-based software company headquartered in San Francisco, California. It provides customer relationship management (CRM) service and also provides enterprise applications focused on customer service, marketing automation, analytics, and application development. The company was founded on February 3, 1999 by former Oracle executive Marc Benioff, together with Parker Harris, Dave Moellenhoff, and Frank Dominguez as a software as a service (SaaS) company, and was launched publicly between September and November 1999. In June 2004, the company had its initial public offering on the New York Stock Exchange under the stock symbol CRM and raised US$110 million. Early investors include Larry Ellison, Magdalena Yesil, Halsey Minor, Stewart Henderson, Mark Iscaro, and Igor Sill, a founding member of Geneva Venture Partners. In October 2014, Salesforce announced the development of its Customer Success Platform to tie together Salesforce's services, including sales, service, marketing, analytics, community, and mobile apps. In October 2017, Salesforce launched a Facebook Analytics tool for business-to-business marketers. In September 2018, Salesforce partnered with Apple intended on improving apps for businesses.",
    "Trade name": "Salesforce",
    Type: "Public company",
    "Traded as": "NYSE: CRM DJIA component S&P 100 component S&P 500 component",
    Industry: "Cloud computing Enterprise software Consulting",
    Founded: "February 3, 1999; 22 years ago",
    Founders: "Marc Benioff Parker Harris Dave Moellenhoff Frank Dominguez",
    Headquarters: "Salesforce Tower San Francisco, California, U.S.",
    "Key people":
      "Marc Benioff (Chairman & Co-CEO) Bret Taylor (Vice Chair & Co-CEO)",
    Services: "Cloud computing",
    Revenue: " US$21.25 billion (2021)",
    "Operating income": " US$455 million (2021)",
    "Net income": " US$4.07 billion (2021)",
    "Total assets": " US$66.30 billion (2021)",
    "Total equity": " US$41.49 billion (2021)",
    "Number of employees": "56,606 (January 31, 2021)",
    Subsidiaries:
      "Quip Demandware Heroku MuleSoft Tableau Software Acumen Solutions Slack Technologies",
    Website: "salesforce.com",
    id: "6tEj",
  },
  {
    name: "APL",
    description:
      "A mathematical notation for manipulating arrays was developed by Kenneth E. Iverson, starting in 1957 at Harvard University. In 1960, he began work for IBM where he developed this notation with Adin Falkoff and published it in his book A Programming Language in 1962. The preface states its premise: Applied mathematics is largely concerned with the design and analysis of explicit procedures for calculating the exact or approximate values of various functions. Such explicit procedures are called algorithms or programs. Because an effective notation for the description of programs exhibits considerable syntactic structure, it is called a programming language. This notation was used inside IBM for short research reports on computer systems, such as the Burroughs B5000 and its stack mechanism when stack machines versus register machines were being evaluated by IBM for upcoming computers. Iverson also used his notation in a draft of the chapter A Programming Language, written for a book he was writing with Fred Brooks, Automatic Data Processing, which would be published in 1963.",
    Paradigm: "Array, functional, structured, modular",
    "Designed by": "Kenneth E. Iverson",
    Developer: "Larry Breed, Dick Lathwell, Roger Moore and others",
    "First appeared": "November 27, 1966; 55 years ago",
    "Stable release": "ISO/IEC 13751:2001 / February 1, 2001; 20 years ago",
    "Typing discipline": "Dynamic",
    Platform: "Cross platform",
    License: "Proprietary, open source",
    other_details: {
      type: "programming",
      color: "#5A8164",
      extensions: [".apl", ".dyalog"],
      interpreters: ["apl", "aplx", "dyalog"],
      tm_scope: "source.apl",
      ace_mode: "text",
      codemirror_mode: "apl",
      codemirror_mime_type: "text/apl",
      language_id: 6,
    },
    id: "JB9_",
  },
  {
    name: "MIT App Inventor",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/Mit_app_inventor.png/167px-Mit_app_inventor.png",
    description:
      "It uses a graphical user interface (GUI) very similar to the programming languages Scratch (programming language) and the StarLogo, which allows users to drag and drop visual objects to create an application that can run on Android devices, while a App-Inventor Companion (The program that allows the app to run and debug on) that works on iOS running devices are still under development. In creating App Inventor, Google drew upon significant prior research in educational computing, and work done within Google on online development environments. App Inventor and the other projects are based on and informed by constructionist learning theories, which emphasize that programming can be a vehicle for engaging powerful ideas through active learning. As such, it is part of an ongoing movement in computers and education that began with the work of Seymour Papert and the MIT Logo Group in the 1960s, and has also manifested itself with Mitchel Resnick's work on Lego Mindstorms and StarLogo. App Inventor also supports the use of cloud data via an experimental Firebase#Firebase Realtime Database component. The application was made available through request on July 12, 2010, and released publicly on December 15, 2010. The App Inventor team was led by Hal Abelson and Mark Friedman. In the second half of 2011, Google released the source code, terminated its server, and provided funding to create The MIT Center for Mobile Learning, led by App Inventor creator Hal Abelson and fellow MIT professors Eric Klopfer and Mitchel Resnick. The MIT version was launched in March 2012.",
    "Original author(s)": "Hal Abelson, Mark Friedman",
    "Developer(s)":
      "Google, MIT Media Lab, MIT Computer Science and Artificial Intelligence Laboratory",
    "Initial release": "December 15, 2010; 11 years ago",
    "Stable release": "nb180a / November 26, 2019; 2 years ago",
    Repository: "github.com/mit-cml/appinventor-sources",
    "Written in": "Java, Kawa, Scheme",
    "Operating system": "Android",
    "Available in": "19 languages",
    Type: "Application software development IDE",
    License: "Creative Commons Attribution ShareAlike 3.0 Unported, Apache 2.0",
    Website: "appinventor.mit.edu",
    id: "s5M5",
  },
  {
    name: "AppleScript",
    description:
      'AppleScript is a scripting language created by Apple Inc. that facilitates automated control over scriptable Mac applications. First introduced in System 7, it is currently included in all versions of macOS as part of a package of system automation tools. The term "AppleScript" may refer to the language itself, to an individual script written in the language, or, informally, to the macOS Open Scripting Architecture that underlies the language. AppleScript is primarily a scripting language developed by Apple to do inter-application communication (IAC) using Apple events. AppleScript is related to, but different from, Apple events. Apple events are designed to exchange data between and control other applications in order to automate repetitive tasks. AppleScript has some processing abilities of its own, in addition to sending and receiving Apple events to applications. AppleScript can do basic calculations and text processing, and is extensible, allowing the use of scripting additions that add new functions to the language. Mainly, however, AppleScript relies on the functionality of applications and processes to handle complex tasks. As a structured command language, AppleScript can be compared to Unix shells, the Microsoft Windows Script Host, or IBM REXX in its purpose,[citation needed] but it is distinct from all three. Essential to its functionality is the fact that Macintosh applications publish "dictionaries" of addressable objects and operations. AppleScript has some elements of procedural programming, object-oriented programming (particularly in the construction of script objects), and natural language programming tendencies in its syntax, but does not strictly conform to any of these programming paradigms.: xxvi ',
    Paradigm: "Natural language programming, Scripting",
    Developer: "Apple Inc.",
    "First appeared": "1993; 29 years ago",
    "Stable release": "2.5 / October 16, 2014; 7 years ago",
    "Typing discipline": "Weak, dynamic",
    OS: "System 7, Mac OS 8, Mac OS 9, macOS",
    License: "Proprietary (parts available under APSL)",
    "Filename extensions": ".scpt, .scptd, .applescript",
    Website: "https://developer.apple.com/applescript",
    other_details: {
      type: "programming",
      aliases: ["osascript"],
      extensions: [".applescript", ".scpt"],
      interpreters: ["osascript"],
      ace_mode: "applescript",
      color: "#101F1F",
      language_id: 19,
    },
    id: "DUWu",
  },
  {
    name: "Arc",
    description:
      'In 2001, Paul Graham announced that he was working on a new dialect of Lisp named Arc. Over the years since, he has written several essays describing features or goals of the language, and some internal projects at Graham\'s startup business incubator named Y Combinator have been written in Arc, most notably the Hacker News web forum and news aggregator program. Arc is written in Racket. In the essay Being Popular Graham describes a few of his goals for the language. While many of the goals are very general ("Arc should be hackable", "there should be good libraries"), he did give some specifics. For example, he believes it important for a language to be terse: It would not be far from the truth to say that a hacker about to write a program decides what language to use, at least subconsciously, based on the total number of characters he\'ll have to type. If this isn\'t precisely how hackers think, a language designer would do well to act as if it were. He also stated that it is better for a language to only implement a small number of axioms, even when that means the language may not have features that large organizations want, such as object-orientation (OO). Further, Graham thinks that OO is not useful as its methods and patterns are just "good design", and he views the language features used to implement OO as partly mistaken. At Arc\'s introduction in 2008, Graham stated one of its benefits was its brevity.',
    Paradigms: "Multi-paradigm: functional, meta, procedural",
    Family: "Lisp",
    "Designed by": "Paul Graham",
    Developers: "Paul Graham, Robert Morris, Arc community",
    "First appeared": "29 January 2008; 13 years ago",
    "Stable release": "3.2 / 28 October 2018; 3 years ago",
    "Typing discipline": "Dynamic",
    "Implementation language": "Racket",
    Platform: "IA-32, x86-64",
    OS: "Linux",
    License: "Artistic License 2.0",
    "Filename extensions": ".arc",
    Website: "arclanguage.org",
    other_details: {
      type: "programming",
      color: "#aa2afe",
      extensions: [".arc"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 20,
    },
    id: "9ExQ",
  },
  {
    name: "ARexx",
    description:
      'ARexx can easily communicate with third-party software that implements an "ARexx port". Any Amiga application or script can define a set of commands and functions for ARexx to address, thus making the capabilities of the software available to the scripts written in ARexx. ARexx can direct commands and functions to several applications from the same script, thus offering the opportunity to mix and match functions from the different programs. For example, an ARexx script could extract data from a database, insert the data into a spreadsheet to perform calculations on it, then insert tables and charts based on the results into a word processor document. ARexx was first created in 1987, developed for the Amiga by William S. Hawes. It is based on the REXX language described by Mike Cowlishaw in the book The REXX Language: A Practical Approach to Programming. ARexx was included by Commodore with AmigaOS 2.0 in 1990, and has been included with all subsequent AmigaOS releases. This later version of ARexx follows the official REXX language closely; Hawes was later involved in drafting the ANSI standard for REXX. ARexx is written in 68000 Assembly, and cannot therefore function at full speed with new PPC CPUs, a version of ARexx has not been rewritten for them and is still missing from MorphOS 3.0. William Hawes is no longer involved in development of Amiga programs and no other Amiga-related firm is financing new versions of ARexx. Notwithstanding this fact, the existing version of ARexx continues to be used, although it is not distributed with MorphOS.',
    id: "jIO4",
  },
  {
    name: "Assembly language",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Motorola_6800_Assembly_Language.png/300px-Motorola_6800_Assembly_Language.png",
    description:
      'In computer programming, assembly language (or assembler language), sometimes abbreviated asm, is any low-level programming language in which there is a very strong correspondence between the instructions in the language and the architecture\'s machine code instructions. Assembly language usually has one statement per machine instruction (1:1), but constants, comments, assembler directives, symbolic labels of, e.g., memory locations, registers, and macros are generally also supported. Assembly code is converted into executable machine code by a utility program referred to as an assembler. The term "assembler" is generally attributed to Wilkes, Wheeler and Gill in their 1951 book The Preparation of Programs for an Electronic Digital Computer, who, however, used the term to mean "a program that assembles another program consisting of several sections into a single program". The conversion process is referred to as assembly, as in assembling the source code. The computational step when an assembler is processing a program is called assembly time. Assembly language may also be called symbolic machine code. Because assembly depends on the machine code instructions, each assembly language[nb 1] is specific to a particular computer architecture. Sometimes there is more than one assembler for the same architecture, and sometimes an assembler is specific to an operating system or to particular operating systems. Most assembly languages do not provide specific syntax for operating system calls, and most assembly languages[nb 2] can be used universally with any operating system, as the language provides access to all the real capabilities of the processor, upon which all system call mechanisms ultimately rest. In contrast to assembly languages, most high-level programming languages are generally portable across multiple architectures but require interpreting or compiling, a much more complicated task than assembling.',
    Paradigm: "Imperative, unstructured",
    "First appeared": "1949; 73 years ago",
    id: "h7ca",
  },
  {
    name: "AutoIt",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/2/22/Autoitlogo.png/187px-Autoitlogo.png",
    description:
      'The scripting language in AutoIt 1 and 2 was statement-driven and designed primarily for simulating user interaction. From version 3 onward, the AutoIt syntax is similar to that found in the BASIC family of languages. In this form, AutoIt is a general-purpose, third-generation programming language with a classical data model and a variant data type that can store several types of data, including arrays. An AutoIt automation script can be converted into a compressed, stand-alone executable which can be run on computers even if they do not have the AutoIt interpreter installed. A wide range of function libraries (known as UDFs, or "User Defined Functions") are also included as standard or are available from the website to add specialized functionality. AutoIt is also distributed with an IDE based on the free SciTE editor. The compiler and help text are fully integrated and provide a de facto standard environment for developers using AutoIt. AutoIt1 and AutoIt2 were closed-source projects, and had a very different syntax than AutoIt3, whose syntax is more like VBScript and BASIC. AutoIt3 was initially free and open-source, licensed under the terms of the GNU General Public License, with its initial public release 3.0.100 in February 2004, and had open-source releases in March 2004 and August 2004. Version 3.0.102, released in August 2004, was initially open-source, but by January 2005 was distributed as closed-source. Subsequent releases, starting from the February 2005 release of version 3.1.0, were all closed-source. Version 3.1.0 was also the first release with support for GUI scripts.',
    Paradigm: "Object-oriented, imperative, functional, procedural, reflective",
    "Designed by": "Jonathan Bennett",
    Developer: "AutoIt Consulting Ltd.",
    "First appeared": "January 1999; 23 years ago",
    "Stable release": "3.3.14.5 / March 16, 2018; 3 years ago",
    "Preview release": "3.3.15.4 Beta / June 12, 2021; 7 months ago",
    Platform: "IA-32 and x64",
    OS: "Windows XP SP3 and later Windows Server 2003 and later",
    License: "Freeware",
    "Filename extensions": ".au3",
    Website: "www.autoitscript.com",
    other_details: {
      type: "programming",
      color: "#1C3552",
      aliases: ["au3", "AutoIt3", "AutoItScript"],
      extensions: [".au3"],
      tm_scope: "source.autoit",
      ace_mode: "autohotkey",
      language_id: 27,
    },
    id: "fta5",
  },
  {
    name: "AutoLISP",
    description:
      "AutoLISP is a small, dynamically scoped, dynamically typed Lisp language dialect with garbage collection, immutable list structure, and settable symbols, lacking in such regular Lisp features as macro system, records definition facilities, arrays, functions with variable number of arguments or let bindings. Aside from the core language, most of the primitive functions are for geometry, accessing AutoCAD's internal DWG database, or manipulation of graphical entities in AutoCAD. The properties of these graphical entities are revealed to AutoLISP as association lists in which values are paired with AutoCAD group codes that indicate properties such as definitional points, radii, colors, layers, linetypes, etc. AutoCAD loads AutoLISP code from .LSP files. AutoLISP code can interact with the user through AutoCAD's graphical editor by use of primitive functions that allow the user to pick points, choose objects on screen, and input numbers and other data. AutoLisp also has a built-in graphical user interface (GUI) mini- or domain-specific language (DSL), the Dialog Control Language, for creating modal dialog boxes with automated layout, within AutoCAD. AutoLISP was derived from an early version of XLISP, which was created by David Betz. The language was introduced in AutoCAD Version 2.18 in January 1986, and continued to be enhanced in successive releases up to release 13 in February 1995. After that, its development was neglected by Autodesk in favor of more fashionable development environments like Visual Basic for Applications (VBA), .NET Framework, and ObjectARX. However, it has remained AutoCAD's main user customizing language. Vital-LISP, a considerably enhanced version of AutoLISP including an integrated development environment (IDE), debugger, compiler, and ActiveX support, was developed and sold by third party developer Basis Software. Vital LISP was a superset of the existing AutoLISP language that added VBA-like access to the AutoCAD object model, reactors (event handling for AutoCAD objects), general ActiveX support, and some other general Lisp functions. Autodesk purchased this, renamed it Visual LISP, and briefly sold it as an add-on to AutoCAD release 14 released in May 1997. It was incorporated into AutoCAD 2000 released in March 1999, as a replacement for AutoLISP. Since then, Autodesk has ceased major enhancements to Visual LISP and focused more effort on VBA and .NET, and C++. As of January 31, 2014, Autodesk no longer supports VBA versions older than 7.1. This is part of a long-term process of changing from VBA to .NET for user customizing.",
    Family: "Lisp",
    "Designed by": "David Betz",
    Developers: "Autodesk, Basis Software",
    "First appeared": "January 1986; 36 years ago",
    "Stable release": "13 / February 1995; 26 years ago",
    "Typing discipline": "dynamic",
    Scope: "dynamic",
    Platform: "IA-32",
    OS: "Linux",
    id: "OCxk",
  },
  {
    name: "Averest",
    description:
      "It can be used to model and verify finite and infinite state systems, at varied abstraction levels. It is useful for hardware design, modeling communication protocols, concurrent programs, software in embedded systems, and more. Components: compiler to translate synchronous programs to transition systems, symbolic model checker, tool for hardware/software synthesis. These cover large parts of the design flow of reactive systems, from specifying to implementing. Though the tools are part of a common framework, they are mostly independent of each other, and can be used with 3rd-party tools.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    id: "OGFi",
  },
  {
    name: "AWK",
    description:
      "The AWK language is a data-driven scripting language consisting of a set of actions to be taken against streams of textual data – either run directly on files or used as part of a pipeline – for purposes of extracting or transforming text, such as producing formatted reports. The language extensively uses the string datatype, associative arrays (that is, arrays indexed by key strings), and regular expressions. While AWK has a limited intended application domain and was especially designed to support one-liner programs, the language is Turing-complete, and even the early Bell Labs users of AWK often wrote well-structured large AWK programs. AWK was created at Bell Labs in the 1970s,[better source needed] and its name is derived from the surnames of its authors: Alfred Aho, Peter Weinberger, and Brian Kernighan. The acronym is pronounced the same as the bird auk, which is on the cover of The AWK Programming Language. When written in all lowercase letters, as awk, it refers to the Unix or Plan 9 program that runs scripts written in the AWK programming language. AWK was initially developed in 1977 by Alfred Aho (author of egrep), Peter J. Weinberger (who worked on tiny relational databases), and Brian Kernighan. AWK takes its name from their respective initials. According to Kernighan, one of the goals of AWK was to have a tool that would easily manipulate both numbers and strings. AWK was also inspired by Marc Rochkind's programming language that was used to search for patterns in input data, and was implemented using yacc. As one of the early tools to appear in Version 7 Unix, AWK added computational features to a Unix pipeline besides the Bourne shell, the only scripting language available in a standard Unix environment. It is one of the mandatory utilities of the Single UNIX Specification, and is required by the Linux Standard Base specification.",
    Paradigm: "Scripting, procedural, data-driven",
    "Designed by": "Alfred Aho, Peter Weinberger, and Brian Kernighan",
    "First appeared": "1977; 45 years ago",
    "Stable release": "IEEE Std 1003.1-2008 (POSIX) / 1985",
    "Typing discipline":
      "none; can handle strings, integers and floating-point numbers; regular expressions",
    OS: "Cross-platform",
    id: "g_jx",
  },
  {
    name: "B",
    description:
      "B was derived from BCPL, and its name may possibly be a contraction of BCPL. Thompson's coworker Dennis Ritchie speculated that the name might be based on Bon, an earlier, but unrelated, programming language that Thompson designed for use on Multics.[note 1] B was designed for recursive, non-numeric, machine-independent applications, such as system and language software. It was a typeless language, with the only data type being the underlying machine's natural memory word format, whatever that might be. Depending on the context, the word was treated either as an integer or a memory address. As machines with ASCII processing became common, notably the DEC PDP-11 that arrived at Bell, support for character data stuffed in memory words became important. The typeless nature of the language was seen as a disadvantage, which led Thompson and Ritchie to develop an expanded version of the language supporting new internal and user-defined types, which became the C programming language. Circa 1969, Ken Thompson and later Dennis Ritchie developed B basing it mainly on the BCPL language Thompson used in the Multics project. B was essentially the BCPL system stripped of any component Thompson felt he could do without in order to make it fit within the memory capacity of the minicomputers of the time. The BCPL to B transition also included changes made to suit Thompson's preferences (mostly along the lines of reducing the number of non-whitespace characters in a typical program). Much of the typical ALGOL-like syntax of BCPL was rather heavily changed in this process. The assignment operator := reverted to the = of Rutishauser's Superplan, and the equality operator = was replaced by ==.",
    "Designed by": "Ken Thompson",
    Developer: "Ken Thompson, Dennis Ritchie",
    "First appeared": "1969; 53 years ago",
    "Typing discipline": "typeless (everything is a word)",
    "Filename extensions": ".b",
    id: "e8sW",
  },
  {
    name: "Ballerina",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/Official_Ballerina_Programming_Language_Logo.png/200px-Official_Ballerina_Programming_Language_Logo.png",
    description:
      "It is an open source project  started in 2015 by architects from WSO2 as a code-based alternative to the configuration-based integration tools such as EAI, ESB, and workflow products. It has various constructs geared toward cloud-native development including support for modern data formats and protocols, reliability, distributed transactions, APIs, and event streams. Ballerina was designed by WSO2 to improve productivity for application developers that have to work with distributed cloud-native systems. The designers, who provided enterprise products in the integration space for over 10 years, used their knowledge of the industry when designing the language. Ballerina was first publicly announced in 2017 and version 1.0 was released on September 10, 2019. Some key concepts in Ballerina include:",
    "Designed by":
      "Sanjiva Weerawarana, James Clark, Sameera Jayasoma, Hasitha Aravinda, Srinath Perera, Frank Leymann and WSO2",
    Developer: "WSO2",
    "First appeared": "2017",
    "Typing discipline": "Structural, strong, static, inferred",
    "Implementation language": "Java, Ballerina, TypeScript ",
    OS: "Cross-platform",
    License: "Apache License 2.0",
    Website: "ballerina.io",
    other_details: {
      type: "programming",
      extensions: [".bal"],
      tm_scope: "source.ballerina",
      ace_mode: "text",
      color: "#FF5000",
      language_id: 720859680,
    },
    id: "jjuJ",
  },
  {
    name: "Bash",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Gnu-bash-logo.svg/152px-Gnu-bash-logo.svg.png",
    description:
      'Bash is a Unix shell and command language written by Brian Fox for the GNU Project as a free software replacement for the Bourne shell. First released in 1989, it has been used as the default login shell for most Linux distributions. A version is also available for Windows 10 via the Windows Subsystem for Linux. It is also the default user shell in Solaris 11. Bash was also the default shell in all versions of Apple macOS prior to the 2019 release of macOS Catalina, which changed the default shell to zsh, although Bash remains available as an alternative shell. Bash is a command processor that typically runs in a text window where the user types commands that cause actions. Bash can also read and execute commands from a file, called a shell script. Like most Unix shells, it supports filename globbing (wildcard matching), piping, here documents, command substitution, variables, and control structures for condition-testing and iteration. The keywords, syntax, dynamically scoped variables and other basic features of the language are all copied from sh. Other features, e.g., history, are copied from csh and ksh. Bash is a POSIX-compliant shell, but with a number of extensions. The shell\'s name is an acronym for Bourne Again Shell, a pun on the name of the Bourne shell that it replaces and the notion of being "born again". A security hole in Bash dating from version 1.03 (August 1989), dubbed Shellshock, was discovered in early September 2014 and quickly led to a range of attacks across the Internet. Patches to fix the bugs were made available soon after the bugs were identified.',
    "Original author(s)": "Brian Fox",
    "Initial release": "June 8, 1989; 32 years ago",
    "Stable release": "5.1.16  / 5 January 2022; 10 days ago",
    Repository: "git.savannah.gnu.org/cgit/bash.git ",
    "Written in": "C",
    "Operating system":
      "Unix-like macOS (GPL-2.0-or-later; GPL-3.0-or-later available through third parties) Windows (GPL-3.0-or-later)",
    Platform: "GNU",
    "Available in": "Multilingual (gettext)",
    Type: "Unix shell, command language",
    License:
      "Since 4.0: GPL-3.0-or-later 1.11? to 3.2: GPL-2.0-or-later 0.99? to 1.05?: GPL-1.0-or-later",
    Website: "www.gnu.org/software/bash/",
    id: "RZ2l",
  },
  {
    name: "BASIC",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/AtariBasic.png/300px-AtariBasic.png",
    description:
      "BASIC (Beginners' All-purpose Symbolic Instruction Code) is a family of general-purpose, high-level programming languages whose design philosophy emphasizes ease of use. The original version was designed by John G. Kemeny and Thomas E. Kurtz and released at Dartmouth College in 1964. They wanted to enable students in fields other than science and mathematics to use computers. At the time, nearly all use of computers required writing custom software, which was something only scientists and mathematicians tended to learn. In addition to the language itself, Kemeny and Kurtz developed the Dartmouth Time Sharing System (DTSS), which allowed multiple users to edit and run BASIC programs at the same time. This general model became very popular on minicomputer systems like the PDP-11 and Data General Nova in the late 1960s and early 1970s. Hewlett-Packard produced an entire computer line for this method of operation, introducing the HP2000 series in the late 1960s and continuing sales into the 1980s. Many early video games trace their history to one of these versions of BASIC. The emergence of early microcomputers in the mid-1970s led to the development of a number of BASIC dialects, including Microsoft BASIC in 1975. Due to the tiny main memory available on these machines, often 4 KB, a variety of Tiny BASIC dialects was also created. BASIC was available for almost any system of the era, and naturally became the de facto programming language for the home computer systems that emerged in the late 1970s. These machines almost always had a BASIC interpreter installed by default, often in the machine's firmware or sometimes on a ROM cartridge. BASIC fell from use in the early 1990s, as newer machines with far greater capabilities came to market and other programming languages (such as Pascal and C) became tenable. In 1991, Microsoft released Visual Basic, combining a greatly updated version of BASIC with a visual forms builder. This reignited use of the language and \"VB\" remains a major programming language in the form of VB.NET.",
    Paradigm: "Non-structured, later procedural, later object-oriented",
    "Designed by": "John G. Kemeny Thomas E. Kurtz",
    "First appeared": "May 1, 1964; 57 years ago",
    id: "awZW",
  },
  {
    name: "Batch file",
    image: "https://upload.wikimedia.org/wikipedia/en/7/7c/Batch_file_icon.png",
    description:
      'A batch file is a script file in DOS, OS/2 and Microsoft Windows. It consists of a series of commands to be executed by the command-line interpreter, stored in a plain text file. A batch file may contain any command the interpreter accepts interactively and use constructs that enable conditional branching and looping within the batch file, such as IF, FOR, and GOTO labels. The term "batch" is from batch processing, meaning "non-interactive execution", though a batch file may not process a batch of multiple data. Similar to Job Control Language (JCL), DCL and other systems on mainframe and minicomputer systems, batch files were added to ease the work required for certain regular tasks by allowing the user to set up a script to automate them. When a batch file is run, the shell program (usually COMMAND.COM or cmd.exe) reads the file and executes its commands, normally line-by-line. Unix-like operating systems, such as Linux, have a similar, but more flexible, type of file called a shell script. The filename extension .bat is used in DOS and Windows. Windows NT and OS/2 also added .cmd. Batch files for other environments may have different extensions, e.g., .btm in 4DOS, 4OS2 and 4NT related shells. The detailed handling of batch files has changed significantly between versions. Some of the detail in this article applies to all batch files, while other details apply only to certain versions.',
    "Filename extensions": ".bat, .cmd, .btm",
    "Internet media type":
      "application/bat application/x-bat application/x-msdos-program text/plain",
    "Type of format": "Scripting",
    "Container for": "Scripts",
    id: "eu_x",
  },
  {
    name: "bc",
    description:
      "A typical interactive usage is typing the command bc on a Unix command prompt and entering a mathematical expression, such as (1 + 3) * 2, whereupon 8 will be output. While bc can work with arbitrary precision, it actually defaults to zero digits after the decimal point, so the expression 2/3 yields 0. This can surprise new bc users unaware of this fact. The -l option to bc sets the default scale (digits after the decimal point) to 20 and adds several additional mathematical functions to the language. bc first appeared in Version 6 Unix in 1975 and was written by Robert Morris and Lorinda Cherry of Bell Labs. bc was preceded by dc, an earlier arbitrary-precision calculator written by the same authors. dc could do arbitrary-precision calculations, but its reverse Polish notation (RPN) syntax—much loved by many for evaluating algebraic formulas—proved inconvenient to its users when expressing flow control, and therefore bc was written as a front-end to dc. bc was a very simple compiler (a single yacc source file with a few hundred lines), which converted the new, C-like, bc syntax into dc's postfix notation and piped the results through dc. In 1991, POSIX rigorously defined and standardized bc. Three implementations of this standard survive today: The first is the traditional Unix implementation, a front-end to dc, which survives in Unix and Plan 9 systems. The second is the free software GNU bc, first released in 1991 by Philip A. Nelson. The GNU implementation has numerous extensions beyond the POSIX standard and is no longer a front-end to dc (it is a bytecode interpreter). The third is a re-implementation by OpenBSD in 2003. The POSIX standardized bc language is traditionally written as a program in the dc programming language to provide a higher level of access to the features of the dc language without the complexities of dc's terse syntax.",
    "Developer(s)":
      "Robert Morris and Lorinda Cherry of Bell Labs, Philip A. Nelson",
    "Initial release": "1975, 46–47 years ago",
    "Operating system": "Unix, Unix-like, Plan 9, FreeDOS",
    Platform: "Cross-platform",
    Type: "Command",
    id: "sqsl",
  },
  {
    name: "BCPL",
    description:
      "BCPL was designed so that small and simple compilers could be written for it; reputedly some compilers could be run in 16 kilobytes. Further, the original compiler, itself written in BCPL, was easily portable. BCPL was thus a popular choice for bootstrapping a system.[citation needed] A major reason for the compiler's portability lay in its structure. It was split into two parts: the front end parsed the source and generated O-code, an intermediate language. The back end took the O-code and translated it into the machine code for the target machine. Only 1⁄5 of the compiler's code needed to be rewritten to support a new machine, a task that usually took between 2 and 5 man-months. This approach became common practice later (e.g. Pascal, Java). The language is unusual in having only one data type: a word, a fixed number of bits, usually chosen to align with the architecture's machine word and of adequate capacity to represent any valid storage address. For many machines of the time, this data type was a 16-bit word. This choice later proved to be a significant problem when BCPL was used on machines in which the smallest addressable item was not a word but a byte or on machines with larger word sizes such as 32-bit or 64-bit.[citation needed] The interpretation of any value was determined by the operators used to process the values. (For example, + added two values together, treating them as integers; ! indirected through a value, effectively treating it as a pointer.) In order for this to work, the implementation provided no type checking. Hungarian notation was developed to help programmers avoid inadvertent type errors.[citation needed] The mismatch between BCPL's word orientation and byte-oriented hardware was addressed in several ways. One was by providing standard library routines for packing and unpacking words into byte strings. Later, two language features were added: the bit-field selection operator and the infix byte indirection operator (denoted by %).[citation needed]",
    Paradigm: "procedural, imperative, structured",
    "Designed by": "Martin Richards",
    "First appeared": "1967; 55 years ago",
    "Typing discipline": "typeless (everything is a word)",
    id: "IduC",
  },
  {
    name: "BeanShell",
    description:
      'While BeanShell allows its users to define functions that can be called from within a script, its underpinning philosophy has been to not pollute its syntax with too many extensions and "syntactic sugar", thereby ensuring that code written for a Java compiler can usually be executed interpretively by BeanShell without any changes and, almost just as much, vice versa. This makes BeanShell a popular testing and debugging tool for the Java virtual machine (JVM) platform. BeanShell supports scripted objects as simple method closures like those in Perl and JavaScript. BeanShell is an open source project and has been incorporated into many applications, such as Apache OpenOffice, Apache Ant, WebLogic Server Application Server, Apache JMeter, jEdit, ImageJ, JUMP GIS, Apache Taverna, and many others. BeanShell provides an easy to integrate application programming interface (API). It can also be run in command-line mode or within its own graphical environment. The first versions of BeanShell (0.96, 1.0) were released by Patrick Niemeyer in 1999, followed by a series of versions. BeanShell 1.3.0 was released in August 2003. Version 2.0b1 was released in September 2003, culminating with version 2.0b4 in May 2005, which as of January 2015 is the newest release posted on the official webpage.',
    Paradigm: "Object-oriented, scripting",
    "Designed by": "JCP",
    "First appeared": "1999; 23 years ago",
    "Stable release": "2.1.0 / December 22, 2020; 12 months ago",
    "Typing discipline": "Dynamic, strong",
    "Implementation language": "Java",
    Platform: "JVM",
    OS: "Cross-platform",
    License:
      "2012: Apache-2.0[a] 2001: SPL-1.0 or LGPL-2.1-only[b] 1999: LGPL-2.1-only[c]",
    Website: "github.com/beanshell/beanshell",
    id: "8BU_",
  },
  {
    name: "BETA",
    description:
      "The project is inactive as of October 2020. From a technical perspective, BETA provides several unique features. Classes and Procedures are unified to one concept, a Pattern. Also, classes are defined as properties/attributes of objects. This means that a class cannot be instantiated without an explicit object context. A consequence of this is that BETA supports nested classes. Classes can be virtually defined, much like virtual methods can be in most object-oriented programming languages. Virtual entities (such as methods and classes) are never overwritten; instead they are redefined or specialized. BETA supports the object-oriented perspective on programming and has comprehensive facilities for procedural and functional programming. It has powerful abstraction mechanisms to support identification of objects, classification and composition. BETA is a statically typed language like Simula, Eiffel and C++, with most type checking done at compile-time. BETA aims to achieve an optimal balance between compile-time type checking and run-time type checking. A major and peculiar feature of the language is the concept of patterns. In another programming language, such as C++, one would have several classes and procedures. BETA expresses both of these concepts using patterns.",
    Paradigm: "Object-oriented",
    "Designed by":
      "Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Møller-Pedersen, Kristen Nygaard",
    Website: "beta.cs.au.dk",
    id: "v8n1",
  },
  {
    name: "BLISS",
    description:
      'BLISS is a typeless block-structured programming language based on expressions rather than statements, and includes constructs for exception handling, coroutines, and macros. It does not include a goto statement. The name is variously said to be short for Basic Language for Implementation of System Software or System Software Implementation Language, Backwards. It was sometimes called "Bill\'s Language for Implementing System Software", after Bill Wulf. The original Carnegie Mellon compiler was notable for its extensive use of optimizations, and formed the basis of the classic book The Design of an Optimizing Compiler. Digital Equipment Corporation (DEC) developed and maintained BLISS compilers for the PDP-10, PDP-11, VAX, DEC PRISM, MIPS, DEC Alpha, and Intel IA-32, The language did not become popular among customers and few had the compiler, but DEC used it heavily in-house into the 1980s; most of the utility programs for the OpenVMS operating system were written in BLISS-32. The DEC BLISS compiler has been ported to the IA-64 and x86-64 architectures as part of the ports of OpenVMS to these platforms. The x86-64 BLISS compiler uses LLVM as its backend code generator, replacing the proprietary GEM backend used for Alpha and IA-64.',
    Paradigm: "Structured, imperative (procedural)",
    "Designed by": "W. A. Wulf, D. B. Russell, A. N. Habermann",
    Developer: "Carnegie Mellon University",
    "First appeared": "1970; 52 years ago",
    "Stable release": "BLISS-64",
    "Typing discipline": "Typeless",
    Scope: "Lexical",
    Platform:
      "PDP-10, PDP-11, VAX, PRISM, MIPS, DEC Alpha, IA-32, IA-64, x86-64",
    OS: "Cross-platform",
    Website: "pdp-10.trailing-edge.com/bb-m836d-bm/",
    id: "I-rq",
  },
  {
    name: "Blockly",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Blockly-Demo.png/300px-Blockly-Demo.png",
    description:
      "Blockly uses visual blocks that link together to make writing code easier, and can generate code in JavaScript, Lua, Dart, Python, or PHP. It can also be customized to generate code in any textual programming language. Blockly development began in summer 2011. The first public release was in May 2012 at Maker Faire. Blockly was originally designed as a replacement for OpenBlocks in App Inventor. Neil Fraser began the project with Quynh Neutron, Ellen Spertus, and Mark Friedman as contributors. The default graphical user interface (GUI) of the Blockly editor consists of a toolbox, which holds available blocks, and where a user can select blocks, and a workspace, where a user can drag and drop and rearrange blocks. The workspace also includes, by default, zoom icons, and a trashcan to delete blocks. The editor can be modified easily to customize and limit the available editing features and blocks. Blockly includes a set of visual blocks for common operations, and can be customized by adding more blocks. New blocks require a block definition and a generator. The definition describes the block's appearance (user interface) and the generator describes the block's translation to executable code. Definitions and generators can be written in JavaScript, or using a visual set of blocks, the Block Factory, which allows new blocks to be described using extant visual blocks; the intent is to make creating new blocks easier.",
    "Original author(s)":
      "Neil Fraser, Quynh Neutron, Ellen Spertus, Mark Friedman",
    "Developer(s)": "Google, MIT",
    "Initial release": "May 2012; 9 years ago",
    "Stable release": "Q1 2021 / 25 March 2021; 9 months ago",
    Repository: "github.com/google/blockly",
    "Written in": "JavaScript",
    "Operating system": "Android, iOS",
    Platform: "Web browser",
    Size: "150 KB",
    "Available in": "50 languages",
    Type: "Library",
    License: "Apache License 2.0",
    Website: "developers.google.com/blockly",
    id: "_tSr",
  },
  {
    name: "Boo",
    description:
      "FlooP is identical to BlooP except that it supports unbounded loops; it is a Turing-complete language and can express all computable functions. For example, it can express the Ackermann function, which (not being primitive recursive) cannot be written in BlooP. Borrowing from standard terminology in mathematical logic, Hofstadter calls FlooP's unbounded loops MU-loops. Like all Turing-complete programming languages, FlooP suffers from the halting problem: programs might not terminate, and it is not possible, in general, to decide which programs do. BlooP and FlooP can be regarded as models of computation, and have sometimes been used in teaching computability. The only variables are OUTPUT (the return value of the procedure) and CELL(i) (an unbounded sequence of natural-number variables, indexed by constants, as in the Unlimited Register Machine). The only operators are ⇐ (assignment), + (addition), × (multiplication), < (less-than), > (greater-than) and = (equals). Each program uses only a finite number of cells, but the numbers in the cells can be arbitrarily large. Data structures such as lists or stacks can be handled by interpreting the number in a cell in specific ways, that is, by Gödel numbering the possible structures.",
    other_details: {
      type: "programming",
      color: "#d4bec1",
      extensions: [".boo"],
      ace_mode: "text",
      tm_scope: "source.boo",
      language_id: 37,
    },
    id: "Je1o",
  },
  {
    name: "Bosque",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Bosque_logo.png/256px-Bosque_logo.png",
    description:
      'Bosque is a free and open-source programming language developed by Microsoft that was inspired by the syntax and types of TypeScript and the semantics of ML and Node/JavaScript. Design goals for the language include better software quality and improved developer productivity. Bosque was designed by Microsoft Research computer scientist Mark Marron, who describes the language as an effort to move beyond the structured programming model that became popular in the 1970s. The structured programming paradigm, in which flow control is managed with loops, conditionals, and subroutines, became popular after a 1968 paper titled "Go To Statement Considered Harmful" by computer scientist Edsger Dijkstra. Marron believes we can do better by getting rid of sources of complexity like loops, mutable state, and reference equality. The result is Bosque, which represents a programming paradigm that Marron, in a paper he wrote, calls "regularized programming." The Bosque specification, parser, type checker, reference interpreter, and IDE support are licensed under MIT License and available on GitHub.',
    Paradigm: "Multi-paradigm: functional, typed language",
    "Designed by": "Mark Marron",
    Developer: "Microsoft",
    "First appeared": "March 3, 2019; 2 years ago",
    License: "MIT License",
    "Filename extensions": ".bsq",
    Website:
      "www.microsoft.com/en-us/research/project/bosque-programming-language/",
    id: "3Y-5",
  },
  {
    name: "C",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/The_C_Programming_Language_logo.svg/140px-The_C_Programming_Language_logo.svg.png",
    description:
      "C (/ˈsiː/, as in the letter c) is a general-purpose, procedural computer programming language supporting structured programming, lexical variable scope, and recursion, with a static type system. By design, C provides constructs that map efficiently to typical machine instructions. It has found lasting use in applications previously coded in assembly language. Such applications include operating systems and various application software for computer architectures that range from supercomputers to PLCs and embedded systems. A successor to the programming language B, C was originally developed at Bell Labs by Dennis Ritchie between 1972 and 1973 to construct utilities running on Unix. It was applied to re-implementing the kernel of the Unix operating system. During the 1980s, C gradually gained popularity. It has become one of the most widely used programming languages, with C compilers from various vendors available for the majority of existing computer architectures and operating systems. C has been standardized by ANSI since 1989 (ANSI C) and by the International Organization for Standardization (ISO). C is an imperative procedural language. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code. Since 2000, C has consistently ranked among the top two languages in the TIOBE index, a measure of the popularity of programming languages.",
    Paradigm: "Multi-paradigm: imperative (procedural), structured",
    "Designed by": "Dennis Ritchie",
    Developer:
      "Dennis Ritchie & Bell Labs (creators); ANSI X3J11 (ANSI C); ISO/IEC JTC1/SC22/WG14 (ISO C)",
    "First appeared": "1972; 50 years ago",
    "Stable release": "C17 / June 2018; 3 years ago",
    "Preview release": "C2x (N2731) / October 18, 2021; 2 months ago",
    "Typing discipline": "Static, weak, manifest, nominal",
    OS: "Cross-platform",
    "Filename extensions": ".c, .h",
    Website: "www.iso.org/standard/74528.html www.open-std.org/jtc1/sc22/wg14/",
    other_details: {
      type: "programming",
      color: "#555555",
      extensions: [".c", ".cats", ".h", ".idc"],
      interpreters: ["tcc"],
      ace_mode: "c_cpp",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-csrc",
      language_id: 41,
    },
    id: "wnRt",
  },
  {
    name: "C--",
    description:
      'There are two main branches: C-- is a "portable assembly language", designed to ease the implementation of compilers that produce high-quality machine code. This is done by delegating low-level code-generation and program optimization to a C-- compiler. The language\'s syntax borrows heavily from C while omitting or changing standard C features such as variadic functions, pointer syntax, and aspects of C\'s type system, because they hamper essential features of C-- and ease of code-generation. The name of the language is an in-joke, indicating that C-- is a reduced form of C, in the same way that C++ is basically an expanded form of C. (-- and ++ mean "decrement" and "increment," respectively.) Work on C-- began in the late 1990s. Since writing a custom code generator is a challenge in itself, and the compiler backends available to researchers at that time were complex and poorly documented, several projects had written compilers which generated C code (for instance, the original Modula-3 compiler). However, C is a poor choice for functional languages: it does not guarantee tail-call optimization, or support accurate garbage collection or efficient exception handling. C-- is a tightly-defined simpler alternative to C which supports all of these. Its most innovative feature is a run-time interface which allows writing of portable garbage collectors, exception handling systems and other run-time features which work with any C-- compiler.',
    Paradigm: "imperative",
    "Designed by": "Simon Peyton Jones and Norman Ramsey",
    "First appeared": "1997",
    "Typing discipline": "static, weak",
    Website: "https://www.cs.tufts.edu/~nr/c--/index.html",
    id: "APBU",
  },
  {
    name: "C++",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/120px-ISO_C%2B%2B_Logo.svg.png",
    description:
      'C++ (/ˌsiːˌplʌsˈplʌs/) is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or "C with Classes". The language has expanded significantly over time, and modern C++ now has object-oriented, generic, and functional features in addition to facilities for low-level memory manipulation. It is almost always implemented as a compiled language, and many vendors provide C++ compilers, including the Free Software Foundation, LLVM, Microsoft, Intel, Oracle, and IBM, so it is available on many platforms. C++ was designed with an orientation toward systems programming and embedded, resource-constrained software and large systems, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g. e-commerce, web search, or databases), and performance-critical applications (e.g. telephone switches or space probes). C++ is standardized by the International Organization for Standardization (ISO), with the latest standard version ratified and published by ISO in December 2020 as ISO/IEC 14882:2020 (informally known as C++20). The C++ programming language was initially standardized in 1998 as ISO/IEC 14882:1998, which was then amended by the C++03, C++11, C++14, and C++17 standards. The current C++20 standard supersedes these with new features and an enlarged standard library. Before the initial standardization in 1998, C++ was developed by Danish computer scientist Bjarne Stroustrup at Bell Labs since 1979 as an extension of the C language; he wanted an efficient and flexible language similar to C that also provided high-level features for program organization. Since 2012, C++ has been on a three-year release schedule with C++23 as the next planned standard. In 1979, Bjarne Stroustrup, a Danish computer scientist, began work on "C with Classes", the predecessor to C++. The motivation for creating a new language originated from Stroustrup\'s experience in programming for his PhD thesis. Stroustrup found that Simula had features that were very helpful for large software development, but the language was too slow for practical use, while BCPL was fast but too low-level to be suitable for large software development. When Stroustrup started working in AT&T Bell Labs, he had the problem of analyzing the UNIX kernel with respect to distributed computing. Remembering his PhD experience, Stroustrup set out to enhance the C language with Simula-like features. C was chosen because it was general-purpose, fast, portable and widely used. As well as C and Simula\'s influences, other languages also influenced this new language, including ALGOL 68, Ada, CLU and ML.',
    Paradigms:
      "Multi-paradigm: procedural, functional, object-oriented, generic, modular",
    Family: "C",
    "Designed by": "Bjarne Stroustrup",
    Developer:
      "ISO/IEC JTC1 (Joint Technical Committee 1) / SC22 (Subcommittee 22) / WG21 (Working Group 21)",
    "First appeared": "1985; 37 years ago",
    "Stable release":
      "C++20 (ISO/IEC 14882:2020) / 15 December 2020; 13 months ago",
    "Preview release": "C++23 / 23 October 2021; 2 months ago",
    "Typing discipline": "Static, nominative, partially inferred",
    OS: "Cross-platform",
    "Filename extensions":
      ".C, .cc, .cpp, .cxx, .c++, .h, .H, .hh, .hpp, .hxx, .h++",
    Website: "isocpp.org",
    other_details: {
      type: "programming",
      ace_mode: "c_cpp",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-c++src",
      color: "#f34b7d",
      aliases: ["cpp"],
      extensions: [
        ".cpp",
        ".c++",
        ".cc",
        ".cp",
        ".cxx",
        ".h",
        ".h++",
        ".hh",
        ".hpp",
        ".hxx",
        ".inc",
        ".inl",
        ".ino",
        ".ipp",
        ".re",
        ".tcc",
        ".tpp",
      ],
      language_id: 43,
    },
    id: "YCYF",
  },
  {
    name: "C#",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/C_Sharp_wordmark.svg/120px-C_Sharp_wordmark.svg.png",
    description:
      "C# (/si ʃɑːrp/ see sharp)[b] is a general-purpose, multi-paradigm programming language. C# encompasses static typing, strong typing, lexically scoped, imperative, declarative, functional, generic, object-oriented (class-based), and component-oriented programming disciplines. C# was designed by Anders Hejlsberg from Microsoft in 2000 and was later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO (ISO/IEC 23270) in 2003. Microsoft introduced C# along with .NET Framework and Visual Studio, both of which were closed-source. At the time, Microsoft had no open-source products. Four years later, in 2004, a free and open-source project called Mono began, providing a cross-platform compiler and runtime environment for the C# programming language. A decade later, Microsoft released Visual Studio Code (code editor), Roslyn (compiler), and the unified .NET platform (software framework), all of which support C# and are free, open-source, and cross-platform. Mono also joined Microsoft but was not merged into .NET. As of 2021, the most recent version of the language is C# 10.0, which was released in 2021 in .NET 6.0. The Ecma standard lists these design goals for C#:",
    Paradigm:
      "Multi-paradigm: structured, imperative, object-oriented, event-driven, task-driven, functional, generic, reflective, concurrent",
    Family: "C",
    "Designed by": "Anders Hejlsberg (Microsoft)",
    Developer: "Mads Torgersen (Microsoft)",
    "First appeared": "2000; 22 years ago",
    "Stable release": "10.0  / 8 November 2021; 2 months ago",
    "Typing discipline":
      "Static, dynamic, strong, safe, nominative, partially inferred",
    Platform: "Common Language Infrastructure",
    License:
      "Roslyn compiler: MIT/X11 .NET Core CLR: MIT/X11 Mono compiler: dual GPLv3 and MIT/X11 DotGNU: dual GPL and LGPL",
    "Filename extensions": ".cs, .csx",
    Website: "docs.microsoft.com/en-us/dotnet/csharp/",
    other_details: {
      type: "programming",
      ace_mode: "csharp",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-csharp",
      tm_scope: "source.cs",
      color: "#178600",
      aliases: ["csharp"],
      extensions: [".cs", ".cake", ".csx"],
      language_id: 42,
    },
    id: "eR8y",
  },
  {
    name: "C/AL",
    description:
      "This is the classic Hello World example. Since the C/SIDE (Client/Server Integrated Development Environment) does not have a console to output text, this example is made using a dialog box as the visual interface. Variables in C/AL are not defined through code, but are defined via the variable declaration menu in the C/AL editor. In this example Item is assumed to be a variable of type Record. . Looping over a recordset and modifying the individual records is achieved with only a few lines of code.",
    Paradigm: "Imperative",
    "Designed by": "Michael Nielsen",
    Developer: "Microsoft",
    id: "vD_r",
  },
  {
    name: "Caché ObjectScript",
    description:
      "The language has private and public variables and globals. Global has a different meaning in this language than in most; such variables are global across routines, processes, and sessions. Thus, editing a global variable is making permanent and immediate changes to a system-universal database (which survives reboots, etc.). The scope of a private variable is the local function, the scope of a public variable is the entire process. Variables, private and public, may be single elements or complete multi-dimensional arrays. The great majority of Caché's feature-set is inherited from the ANSI MUMPS standard. See that article for details on how data is represented and the different ways a programmer can think about the data during development. Then in Caché Terminal (assuming you wrote the hello routine to the SAMPLE namespace): ",
    "First appeared": "1997",
    OS: "Cross-platform",
    id: "yBm1",
  },
  {
    name: "C shell",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Tcsh_ejecut%C3%A1ndose_en_escritorio_Mac_OSX.png/300px-Tcsh_ejecut%C3%A1ndose_en_escritorio_Mac_OSX.png",
    description:
      "The C shell (csh or the improved version, tcsh) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s. It has been widely distributed, beginning with the 2BSD release of the Berkeley Software Distribution (BSD) which Joy first distributed in 1978. Other early contributors to the ideas or the code were Michael Ubell, Eric Allman, Mike O'Brien and Jim Kulp. The C shell is a command processor which is typically run in a text window, allowing the user to type and execute commands. The C shell can also read commands from a file, called a script. Like all Unix shells, it supports filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration. What differentiated the C shell from others, especially in the 1980s, were its interactive features and overall style. Its new features made it easier and faster to use. The overall style of the language looked more like C and was seen as more readable. On many systems, such as macOS and Red Hat Linux, csh is actually tcsh, an improved version of csh. Often one of the two files is either a hard link or a symbolic link to the other, so that either name refers to the same improved version of the C shell. On Debian and some derivatives (including Ubuntu), there are two different packages: csh and tcsh. The former is based on the original BSD version of csh and the latter is the improved tcsh.",
    "Original author(s)": "Bill Joy",
    "Initial release": "1978; 44 years ago",
    "Stable release": "6.20.00 / 24 November 2016; 5 years ago",
    Repository: "bxr.su/n/bin/csh/ ",
    "Written in": "C",
    "Operating system": "BSD, UNIX, Linux, macOS",
    Type: "Unix shell",
    License: "BSD license",
    id: "ufaX",
  },
  {
    name: "Caml",
    image: "https://upload.wikimedia.org/wikipedia/en/4/4a/Caml.gif",
    description:
      "Caml is statically typed, strictly evaluated, and uses automatic memory management. OCaml, the main descendant of Caml, adds many features to the language, including an object layer. In the following, # represents the Caml prompt. Many mathematical functions, such as factorial, are most naturally represented in a purely functional form. The following recursive, purely functional Caml function implements factorial: The function can be written equivalently using pattern matching:",
    Paradigm: "Multi-paradigm: functional, imperative",
    Family: "ML",
    "Designed by":
      "Gérard Huet, Guy Cousineau, Ascánder Suárez, Pierre Weis, Michel Mauny (Heavy Caml), Xavier Leroy (Caml Light)",
    "First appeared": "1985",
    "Stable release": "0.75 / January 26, 2002; 19 years ago",
    "Typing discipline": "Inferred, static, strong",
    OS: "Cross-platform",
    Website: "caml.inria.fr",
    id: "fy9G",
  },
  {
    name: "Cecil",
    description:
      "Augustsson has worked for Carlstedt Research and Technology, Sandburst, Credit Suisse, Standard Chartered Bank, Facebook, X Development, Google and is currently employed by Epic Games. Augustsson is the author of: He was also a co-developer, with Thomas Johnsson, of Lazy ML, a functional programming language developed in the early 1980s, prior to Miranda and Haskell. LML is a strongly typed, statically scoped implementation of ML, with lazy evaluation. The key innovation of LML was to demonstrate how to compile a lazy functional language. Until then, lazy languages had been implemented via interpreted graph reduction. LML compiled to G-machine code.[citation needed] Augustsson was intimately involved in early LPMud development, both in the LPMUD driver and the CD mudlib. His MUD community pseudonym is Marvin.",
    id: "CbPD",
  },
  {
    name: "Cecil",
    description:
      "The language supports multiple dispatch and multimethods, dynamic inheritance, and optional static type checking. Unlike most other OOP systems, Cecil allows subtyping and code inheritance to be used separately, allowing run-time or external extension of object classes or instances. Like Objective-C, all object services in Cecil are invoked by message passing, and the language supports run-time class identification. These features allow Cecil to support dynamic, exploratory programming styles. Parameterized types and methods (generics, polymorphism), garbage collection, and delegation are also supported. Cecil also supports a module mechanism for isolating independent libraries or packages. Cecil does not presently support threads or any other form of concurrency. A standard library for Cecil is also available and includes various collection, utility, system, I/O, and GUI classes. The Diesel language was the successor of Cecil. There was also an assembler type language known as CESIL (Computer Education in Schools Instructional Language) used in the late-1970s developed by ICL. It was quite similar to the later language MASM.  ",
    Paradigm: "object-oriented",
    "Designed by": "Craig Chambers",
    "First appeared": "1992; 30 years ago",
    "Typing discipline": "dynamic (optionally static)",
    id: "OwIe",
  },
  {
    name: "Ceylon",
    description:
      "Computer Education in Schools (CES) was a project developed in the late 1960s and early 1970s by International Computers Limited (ICL). CESIL was developed by ICL as part of the CES project, and introduced in 1974. In those days, very few if any schools had computers, so pupils would write programs on coding sheets, which would then be transferred to punched cards or paper tape. Typically, this would be sent to run on a mainframe computer, with the output from a line printer being returned later. Because CESIL was not designed as an interactive language, there is no facility to input data in real time. Instead, numeric data is included as a separate section at the end of the program. The fundamental principle of CESIL is the use of a single accumulator, which handles mathematical operations. Numeric values are stored in variables, which in CESIL are referred to as store locations. CESIL only works with integers, and results from DIVIDE operations are rounded if necessary. There is no facility for structured data such as arrays, nor for string handling, though string constants can be output by means of the PRINT instruction. Jumps and loops can be conditional or non-conditional, and transfer operation of the program to a line with a specific label, which is identified in the first column of a coding sheet. The instruction or operation is stated in the second column, and the operand in the third column. On some coding sheets, comments and the text of the PRINT instruction would be written in a fourth column.",
    other_details: {
      type: "programming",
      color: "#dfa535",
      extensions: [".ceylon"],
      tm_scope: "source.ceylon",
      ace_mode: "text",
      language_id: 54,
    },
    id: "DvGM",
  },
  {
    name: "Ceylon",
    image:
      "https://upload.wikimedia.org/wikipedia/en/2/20/Ceylon_%28programming_language%29_logo.png",
    description:
      'Important features of Ceylon include: The name "Ceylon" is an oblique reference to Java, in that Java and Sri Lanka, formerly known as Ceylon, are islands known for growth and export of coffee and tea. In August 2017, Ceylon was donated to the Eclipse Foundation. Ceylon is heavily influenced by Java\'s syntax, but adds many new features.',
    Paradigm: "Object-oriented",
    "Designed by": "Gavin King",
    Developer: "Eclipse Foundation",
    "First appeared": "2011; 11 years ago",
    "Stable release": "1.3.3 / August 21, 2017; 4 years ago",
    "Typing discipline": "Static, strong, safe",
    Platform: "Java virtual machine, JavaScript",
    License: "Apache License 2.0",
    "Filename extensions": ".ceylon",
    Website: "ceylon-lang.org",
    other_details: {
      type: "programming",
      color: "#dfa535",
      extensions: [".ceylon"],
      tm_scope: "source.ceylon",
      ace_mode: "text",
      language_id: 54,
    },
    id: "S5lP",
  },
  {
    name: "CFEngine",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/1/1d/CFEngine_banner_logo_with_agent_and_text_2021.png/200px-CFEngine_banner_logo_with_agent_and_text_2021.png",
    description:
      'The CFEngine project began in 1993 as a way for author Mark Burgess (then a post-doctoral fellow of the Royal Society at Oslo University, Norway) to get his work done by automating the management of a small group of workstations in the Department of Theoretical Physics. Like many post-docs and PhD students, Burgess ended up with the task of managing Unix workstations, scripting and fixing problems for users manually. Scripting took too much time, the flavours of Unix were significantly different, and scripts had to be maintained for multiple platforms, drowning in exception logic. After discussing the problems with a colleague, Burgess wrote the first version of CFEngine (the configuration engine) which was published as an internal report and presented at the CERN computing conference. It gained significant attention from a wider community because it was able to hide platform differences using a domain-specific language. A year later, Burgess finished his post-doc but decided to stay in Oslo and took a job lecturing at Oslo University College. Here he realized that there was little or no research being done into configuration management, and he set about applying the principles of scientific modelling to understanding computer systems. In a short space of time, he developed the notion of convergent operators, which remains a core of CFEngine. In 1998 Burgess wrote "Computer Immunology", a paper at the USENIX/LISA98 conference. It laid out a manifesto for creating self-healing systems, reiterated a few years later by IBM in their form of Autonomic Computing. This started a research effort which led to a major re-write, CFEngine 2, which added features for machine learning, anomaly detection and secure communications.',
    "Initial release": "1993",
    "Stable release": "3.19.0, 3.18.1, 3.15.5, / December 10th, 2021",
    Repository: "github.com/cfengine/core ",
    "Operating system": "Cross-platform",
    Platform: "Unix-like, Windows",
    Type: "Configuration management System administration Network management",
    License: "GNU General Public License version 3",
    Website: "cfengine.com",
    id: "L5nO",
  },
  {
    name: "Chapel (Cascade High Productivity Language)",
    description:
      "HLSL is analogous to the GLSL shading language used with the OpenGL standard. It is very similar to the Nvidia Cg shading language, as it was developed alongside it. Early versions of the two languages were considered identical, only marketed differently. HLSL shaders can enable profound speed and detail increases as well as many special effects in both 2D and 3D computer graphics.[citation needed] HLSL programs come in six forms: pixel shaders (fragment in GLSL), vertex shaders, geometry shaders, compute shaders, tessellation shaders (Hull and Domain shaders), and ray tracing shaders (Ray Generation Shaders, Intersection Shaders, Any Hit/Closest Hit/Miss Shaders). A vertex shader is executed for each vertex that is submitted by the application, and is primarily responsible for transforming the vertex from object space to view space, generating texture coordinates, and calculating lighting coefficients such as the vertex's normal, tangent, and bitangent vectors. When a group of vertices (normally 3, to form a triangle) come through the vertex shader, their output position is interpolated to form pixels within its area; this process is known as rasterization. Optionally, an application using a Direct3D 10/11/12 interface and Direct3D 10/11/12 hardware may also specify a geometry shader. This shader takes as its input some vertices of a primitive (triangle/line/point) and uses this data to generate/degenerate (or tessellate) additional primitives or to change the type of primitives, which are each then sent to the rasterizer. D3D11.3 and D3D12 introduced Shader Model 5.1 and later 6.0.",
    id: "i5jI",
  },
  {
    name: "Ch C/C++ interpreter",
    description:
      "Ch can be embedded in C/C++ application programs. It has numerical computing and graphical plotting features. Ch is a combined shell and IDE. Ch shell combines the features of common shell and C language. ChIDE provides quick code navigation and symbolic debugging. It is based on embedded Ch, Scite and Scintilla. Ch is written in C and runs on Windows, Linux, macOS, FreeBSD, AIX, Solaris, QNX, and HP-UX. It supports C90 and major C99 features, but it does not support the full set of C++ features. C99 complex number, IEEE-754 floating-point arithmetic, and variable-length array features were supported in Ch before they became part of the C99 standard. An article published by Computer Reseller News (CRN) named Ch as notable among C-based virtual machines for its functionality and the availability of third-party libraries. Ch has many toolkits that extend its functions. For example, Ch Mechanism Toolkit is used for design and analysis of commonly used mechanisms such as fourbar linkage, five-bar linkage, six-bar linkage, crank-slider mechanism, and cam-follower system. Ch Control System Toolkit is used for modeling, design, and analysis of continuous-time or discrete-time linear time invariant (LTI) control systems. Both toolkits includes the source code. Ch is now used and integrated into curriculum by many high schools and universities to teach computing and programming in C/C++. Ch has been integrated into free C-STEM Studio, a platform for learning computing, science, technology, engineering, and mathematics (C-STEM) with robotics. C-STEM Studio is developed by UC Davis Center for Integrated Computing and STEM Education (C-STEM). It offers the curriculum for K-12 students.",
    "Original author(s)": "Harry H. Cheng",
    "Developer(s)": "SoftIntegration, Inc.",
    "Initial release": "October 1, 2001; 20 years ago",
    "Stable release": "8.0.0 / November 19, 2017; 4 years ago",
    "Written in": "C",
    "Operating system":
      "Windows, OS X, Linux, AIX, HP-UX, Solaris (SPARC and x86), QNX, FreeBSD",
    Platform: "x86, SPARC",
    "Available in": "English",
    Type: "Integrated development environment",
    License:
      "Proprietary software Standard edition: freeware Student edition: freeware for students Professional edition: trialware for 30 days",
    Website: "www.softintegration.com",
    id: "iQ-b",
  },
  {
    name: "Chapel",
    image:
      "https://upload.wikimedia.org/wikipedia/en/c/c0/Cray_Chapel_Logo.png",
    description:
      "Chapel aims to improve the programmability of parallel computers in general and the Cascade system in particular, by providing a higher level of expression than current programming languages do and by improving the separation between algorithmic expression and data structure implementation details. The language designers aspire for Chapel to bridge the gap between current HPC programming practitioners, who they describe as Fortran, C or C++ users writing procedural code using technologies like OpenMP and MPI on one side, and newly graduating computer programmers who tend to prefer Java, Python or Matlab with only some of them having experience with C++ or C. Chapel should offer the productivity advances offered by the latter suite of languages while not alienating the users of the first. Chapel supports a multithreaded parallel programming model at a high level by supporting abstractions for data parallelism, task parallelism, and nested parallelism. It enables optimizations for the locality of data and computation in the program via abstractions for data distribution and data-driven placement of subcomputations. It allows for code reuse and generality through object-oriented concepts and generic programming features. For instance, Chapel allows for the declaration of locales. While Chapel borrows concepts from many preceding languages, its parallel concepts are most closely based on ideas from High Performance Fortran (HPF), ZPL, and the Cray MTA's extensions to Fortran and C.",
    Paradigm:
      "Object-oriented Partitioned global address space Parallel programming",
    "Designed by": "David Callahan, Hans Zima, Brad Chamberlain, John Plevyak",
    Developer: "Cray Inc.",
    "First appeared": "2009",
    "Stable release": "1.24.1 / April 15, 2021; 9 months ago",
    "Typing discipline": "static inferred",
    Platform: "multiplatform",
    OS: "Mac OS, Linux, POSIX, Windows (with Cygwin)",
    License: "Apache 2",
    "Filename extensions": ".chpl",
    Website: "chapel-lang.org",
    other_details: {
      type: "programming",
      color: "#8dc63f",
      aliases: ["chpl"],
      extensions: [".chpl"],
      ace_mode: "text",
      language_id: 55,
    },
    id: "xFJ1",
  },
  {
    name: "Charm",
    description:
      "A set of Charm tools including a compiler, assembler and linker was made available for Acorn's RISC OS platform. Charm reworked for RISC OS platforms has subsequently been reviewed in Archive magazine. Charm is further described in the e-book Programming in Charm on the Raspberry Pi. The definition of the Charm grammar in Backus–Naur form along with descriptive examples of Charm constructs is defined on the Charm language page. The language is block structured, with each block being introduced by a language keyword that is descriptive of the operation being performed in the block e.g. for, while, repeat (iteration), case, if (selection). Each block is enclosed by { and } delimiters. Additionally language lines within a block are normally indented for clarity, though this not required as white space is ignored.",
    Paradigm: "Structured programming",
    "Designed by": "P. Nowosad",
    "First appeared": "1996",
    OS: "RISC OS",
    Website: "charm.qu-bit.co.uk",
    id: "2KOO",
  },
  {
    name: "CHILL",
    description:
      "The CHILL language is similar in size and complexity to the original Ada language. The first specification of the CHILL language was published in 1980, a few years before Ada. ITU provides a standard CHILL compiler. A free CHILL compiler was bundled with GCC up to version 2.95, however, was removed from later versions. An object-oriented version, called Object CHILL, was developed also. ITU is responsible for the CHILL standard, known as ITU-T Rec. Z.200. The equivalent ISO standard is ISO/IEC 9496:2003. (The text of the two documents is the same). In late 1999 CCITT stopped maintaining the CHILL standard. CHILL was used in systems of Alcatel System 12 and Siemens EWSD, for example.",
    Paradigm: "procedural",
    "Designed by": "CCITT",
    "First appeared": "1980",
    "Stable release": "3.0? / 2003; 19 years ago",
    "Typing discipline": "static, strong",
    OS: "telecommunication switches",
    id: "JhVN",
  },
  {
    name: "Cilk (also Cilk++ and Cilk plus)",
    description:
      "Roughly fifteen years after CHIP-8 was introduced, derived interpreters appeared for some models of graphing calculators (from the late 1980s onward, these handheld devices in many ways have more computing power than most mid-1970s microcomputers for hobbyists). An active community of users and developers existed in the late 1970s, beginning with ARESCO's \"VIPer\" newsletter whose first three issues revealed the machine code behind the CHIP-8 interpreter. There are a number of classic video games ported to CHIP-8, such as Pong, Space Invaders, Tetris, and Pac-Man. There are also applications like a random maze generator and Conway's Game of Life. During the 1970s and 1980s, CHIP-8 users shared CHIP-8 programs, but also changes and extensions to the CHIP-8 interpreter, in the COSMAC VIP users' newsletter, VIPER magazine. These extensions included CHIP-10 and Hi-Res CHIP-8, which introduced a higher resolution than the standard 64x32, and CHIP-8C and CHIP-8X, which extended the monochrome display capabilities to support limited color, among other features. These extensions were mostly backwards compatible, as they were based on the original interpreter, although some repurposed rarely used opcodes for new instructions.",
    id: "Wysn",
  },
  {
    name: "ChucK",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/6/6a/ChucK_logo2.jpg",
    description:
      'ChucK was created and chiefly designed by Ge Wang as a graduate student working with Perry R. Cook. ChucK is distributed freely under the terms of the GNU General Public License on Mac OS X, Linux and Microsoft Windows. On iPhone and iPad, ChiP (ChucK for iPhone) is distributed under a limited, closed source license, and is not currently licensed to the public. However, the core team has stated that it would like to explore "ways to open ChiP by creating a beneficial environment for everyone". The ChucK programming language is a loosely C-like object-oriented language, with strong static typing. ChucK is distinguished by the following characteristics: ChucK standard libraries provide:',
    Paradigm: "Multi-paradigm",
    "Designed by": "Ge Wang",
    "First appeared": "2003; 19 years ago",
    "Stable release": "1.4.0.2 / July 20, 2020; 17 months ago",
    "Typing discipline": "Strong",
    OS: "Cross-platform",
    License:
      "Mac, Linux, Windows: GPL-2.0-or-later iOS: Closed Source (Not Public)",
    Website: "chuck.cs.princeton.edu",
    other_details: {
      type: "programming",
      extensions: [".ck"],
      tm_scope: "source.java",
      ace_mode: "java",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-java",
      language_id: 57,
    },
    id: "7puQ",
  },
  {
    name: "Cilk",
    description:
      'Originally developed in the 1990s at the Massachusetts Institute of Technology (MIT) in the group of Charles E. Leiserson, Cilk was later commercialized as Cilk++ by a spinoff company, Cilk Arts. That company was subsequently acquired by Intel, which increased compatibility with existing C and C++ code, calling the result Cilk Plus. After Intel stopped supporting Cilk Plus in 2017, MIT is again developing Cilk in the form of OpenCilk. The Cilk programming language grew out of three separate projects at the MIT Laboratory for Computer Science: In April 1994 the three projects were combined and christened "Cilk". The name Cilk is not an acronym, but an allusion to "nice threads" (silk) and the C programming language. The Cilk-1 compiler was released in September 1994. The original Cilk language was based on ANSI C, with the addition of Cilk-specific keywords to signal parallelism. When the Cilk keywords are removed from Cilk source code, the result should always be a valid C program, called the serial elision (or C elision) of the full Cilk program, with the same semantics as the Cilk program running on a single processor. Despite several similarities,[which?] Cilk is not directly related to AT&T Bell Labs\' Concurrent C.',
    Paradigm: "imperative (procedural), structured, parallel",
    "Designed by": "Intel",
    Developer: "Intel",
    "First appeared": "2010",
    "Typing discipline": "static, weak, manifest",
    Website: "http://cilkplus.org/",
    "Stable release": "1.2 / September 9, 2013; 8 years ago",
    License: "MIT",
    "Filename extensions": "(Same as C or C++)",
    id: "P73Z",
  },
  {
    name: "Control Language",
    description:
      "Although CL is a scripting language for system administration, it is used mainly to create compiled programs. The use of interpreted CL scripts through the SBMDBJOB command  is in fact extremely limited. While thousands of commands were written by IBM developers to perform system level tasks like compiling programs, backing up data, changing system configurations, displaying system object details, or deleting them, commands are not limited to systems level concerns and can be drafted for user applications as well. Parameters (command-line arguments) defined in the main procedures of all traditional System/38 and AS/400 programs are hard coded lists that are made up of parameters that can be numeric, alphanumeric, boolean, etc. and the order in which parameters are passed is important. This is a stark difference from the Unix and DOS worlds where the parameter list in Unix shell scripts and C programs is a set or array of character pointers and more often than not the parameters are not positionally dependent. The developer's solution to this problem was the command object (*CMD). While the parameters on the command can be specified in any order, each parameter is defined to be passed in a specific order to the program. The programmer can also define, among other things, the parameter's data type, unique parameter name, descriptive text (for prompting), default value (used only if the parameter isn't specified during execution), if the values are restricted to a certain set or range, if the data entered should be changed to another value before calling the program, etc.",
    Paradigm: "imperative",
    "Designed by": "IBM",
    Developer: "IBM",
    "First appeared": "1978; 44 years ago",
    OS: "Control Program Facility, IBM i",
    License: "Proprietary",
    id: "wCYB",
  },
  {
    name: "Claire",
    description:
      "Claire provides: Claire's reference implementation, consisting of an interpreter and compiler, was fully open-sourced with the release of version 3.3.46 in February 2009. Another implementation, WebClaire, is commercially supported. Claire is a general-purpose programming language, best suited to application software requiring sophisticated data modeling, rule processing or problem solving. WebClaire adds extensions for fuller integration with the operating system and for programming web applications. Though Claire can be used for complete projects, it is designed to integrate smoothly with C++ or Java: Claire programs may include C++ or Java code, and Claire code may be translated into C++ or Java for use in C++ or Java projects.",
    Paradigm:
      "multi-paradigm: functional, object-oriented (class-based), rule processing, reflective",
    "Designed by": "Yves Caseau",
    "First appeared": "1994",
    "Stable release": "3.3.46 / February 17, 2009; 12 years ago",
    "Typing discipline": "strong, both static and dynamic",
    OS: "Cross-platform",
    License: "Permissive free software licence",
    "Filename extensions": ".cl",
    Website: "www.claire-language.com",
    id: "0jLG",
  },
  {
    name: "Clarion",
    description:
      "The Clarion development environment (IDE) runs on the Clarion language. The IDE provides code generation facilities via a system of templates which allow programmers to describe the program from an abstract level higher than code statements. The generator then turns this higher level into code, which in turn is then compiled and linked using a normal compiler and linker. This generation layer is sometimes referred to as 4GL programming. Using the generation layer is optional. It is possible to create programs fully at the code level (the so-called 3GL layer), bypassing all code generation facilities. If the templates are used to generate code, then programmers are able to inject their own code into the generated code to alter, or extend, the functions offered by the template layer. This process of embedding code can be done while viewing the surrounding generated code. This mixing of template code and generated code allows the template settings to be updated, and the code regenerated, without loss of the embedded code. The templates (from which the code is generated) are provided in source form and developers are free to create their own templates. Many templates have been written by various developers: some are offered as commercial add-ons, and some are free. Three main Clarion products exist: Professional Edition, Enterprise Edition, and .NET.",
    Paradigms: "Imperative, structured, object-oriented",
    Family: "Pascal",
    Developer:
      "Jensen & Partners International (JPI), Clarion International, SoftVelocity",
    "First appeared": "April 1986; 35 years ago",
    "Stable release": "11 / October 2018; 3 years ago",
    Platform: "IA-32",
    OS: "DOS, Windows",
    License: "Proprietary",
    Website: "www.softvelocity.com",
    other_details: {
      type: "programming",
      color: "#db901e",
      ace_mode: "text",
      extensions: [".clw"],
      tm_scope: "source.clarion",
      language_id: 59,
    },
    id: "Gbk3",
  },
  {
    name: "Clean",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/4/4b/Clean_3.0_%28programming_language%29_logo.svg/220px-Clean_3.0_%28programming_language%29_logo.svg.png",
    description:
      "The language Clean first appeared in 1987. Although development of the language itself has slowed down, some researchers are still working in the language. In 2018, a spin-off company was founded that uses Clean as well. Clean shares many properties and syntax with a younger sibling language, Haskell: referential transparency, list comprehension, guards, garbage collection, higher order functions, currying and lazy evaluation. However, Clean deals with mutable state and I/O through a uniqueness typing system, in contrast to Haskell's use of monads. The compiler takes advantage of the uniqueness type system to generate more efficient code, because it knows that at any point during the execution of the program, only one reference can exist to a value with a unique type. Therefore, a unique value can be changed in place. An integrated development environment (IDE) for Microsoft Windows is included in the Clean distribution. Hello world:",
    Paradigm: "functional",
    "Designed by":
      "Software Technology Research Group of Radboud University Nijmegen",
    "First appeared": "1987; 35 years ago",
    "Stable release": "3.1 / January 5, 2022; 11 days ago",
    "Typing discipline": "strong, static, dynamic",
    OS: "Cross-platform",
    License: "Simplified BSD",
    "Filename extensions": ".icl, .dcl, .abc",
    Website: "clean.cs.ru.nl",
    other_details: {
      type: "programming",
      color: "#3F85AF",
      extensions: [".icl", ".dcl"],
      tm_scope: "source.clean",
      ace_mode: "text",
      language_id: 60,
    },
    id: "AlI5",
  },
  {
    name: "Clipper",
    description:
      "One major dBase feature not implemented in Clipper is the dot-prompt (. prompt) interactive command set, which was an important part of the original dBase implementation. Clipper, from Nantucket Corp and later Computer Associates, started out as a native code compiler for dBase III databases, and later evolved. Clipper was created by Nantucket Corporation, a company that was started in 1984 by Barry ReBell (management) and Brian Russell (technical); Larry Heimendinger was Nantucket's president. In 1992, the company was sold to Computer Associates for 190 million dollars and the product was renamed to CA-Clipper. Clipper was created as a replacement programming language for Ashton Tate's dBASE III, a very popular database language at the time. The advantage of Clipper over dBASE was that it could be compiled and executed under MS-DOS as a standalone application. In the years between 1985 and 1992, millions of Clipper applications were built, typically for small businesses dealing with databases concerning many aspects of client management and inventory management. For many smaller businesses, having a Clipper application designed to their specific needs was their first experience with software development. Also a lot of applications for banking and insurance companies were developed, here especially in those cases where the application was considered too small to be developed and run on traditional mainframes. In these environments Clipper also served as a front end for existing mainframe applications.",
    "First appeared": "1985",
    "Stable release": "CA Clipper 5.3b / May 20, 1997; 24 years ago",
    OS: "MS-DOS",
    Website: "www.grafxsoft.com/clipper.htm",
    id: "XUu9",
  },
  {
    name: "CLIPS",
    description:
      'CLIPS was probably the most widely used expert system tool as of 2005. CLIPS itself is written in C, extensions can be written in C, and CLIPS can be called from C. Its syntax resembles that of the programming language Lisp. CLIPS incorporates a complete object-oriented language for writing expert systems. COOL combines the programming paradigms of procedural, object oriented and logical (theorem proving) languages. CLIPS uses forward chaining. Like other expert system languages, CLIPS deals with rules and facts. Various facts can make a rule applicable. An applicable rule is then fired. Facts and rules are created by first defining them, as shown below: Having set this up, the (reset) command causes CLIPS to read the facts and rules. In this case, that would lead to the three "trouble_shooting" facts being asserted. Then the (run) command is used. Given that the two facts listed in rule1 have both been asserted, the conditions for doing its action have been met so the additional fact is asserted as a result of the run.',
    Paradigm: "expert systems",
    "First appeared": "1985",
    Website: "http://www.clipsrules.net/",
    other_details: {
      type: "programming",
      extensions: [".clp"],
      tm_scope: "source.clips",
      ace_mode: "text",
      language_id: 46,
    },
    id: "ZCux",
  },
  {
    name: "CLU",
    description:
      'In its basic form, a CLIST program (or "CLIST" for short) can take the form of a simple list of commands to be executed in strict sequence (like a DOS batch file (*.bat) file). However, CLIST also features If-Then-Else logic as well as loop constructs. CLIST is an interpreted language. That is, the computer must translate a CLIST every time the program is executed. CLISTs therefore tend to be slower than programs written in compiled languages such as COBOL, FORTRAN, or PL/1. (A program written in a compiled language is translated once to create a "load module" or executable.) CLIST can read/write MVS files and read/write from/to a TSO terminal. It can read parameters from the caller and also features a function to hold global variables and pass them between CLISTs. A CLIST can also call an MVS application program (written in COBOL or PL/I, for example). CLISTs can be run in background (by running JCL which executes the TSO control program (IKJEFT01)). TSO I/O screens and menus using ISPF dialog services can be displayed by CLISTs. Compare the function of CLIST with that provided by REXX.',
    id: "oPIH",
  },
  {
    name: "Clojure",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Clojure_logo.svg/120px-Clojure_logo.svg.png",
    description:
      "Clojure advocates immutability and immutable data structures and encourages programmers to be explicit about managing identity and its states. This focus on programming with immutable values and explicit progression-of-time constructs is intended to facilitate developing more robust, especially concurrent, programs that are simple and fast. While its type system is entirely dynamic, recent efforts have also sought the implementation of a dependent type system. Commercial support for Clojure is provided by the company Cognitect, which sponsors a promotional conference. Rich Hickey is the creator of the Clojure language. Before Clojure, he developed dotLisp, a similar project based on the .NET platform, and three earlier attempts to provide interoperability between Lisp and Java: a Java foreign language interface for Common Lisp (jfli), A Foreign Object Interface for Lisp (FOIL), and a Lisp-friendly interface to Java Servlets (Lisplets). Hickey spent about 2½ years working on Clojure before releasing it publicly, much of that time working exclusively on Clojure with no outside funding. At the end of this time, Hickey sent an email announcing the language to some friends in the Common Lisp community.",
    Paradigm:
      "multi-paradigm: agent-orientedconcurrentfunctionallogicmacropipeline",
    Family: "Lisp",
    "Designed by": "Rich Hickey",
    "First appeared": "2007; 15 years ago",
    "Stable release": "1.10.3 / 4 March 2021; 10 months ago",
    "Typing discipline": "dynamicstrong",
    Platform: "JavaJavaScript.NET",
    License: "Eclipse Public License",
    "Filename extensions": ".clj.cljs.cljc.edn",
    Website: "clojure.org",
    other_details: {
      type: "programming",
      ace_mode: "clojure",
      codemirror_mode: "clojure",
      codemirror_mime_type: "text/x-clojure",
      color: "#db5855",
      extensions: [
        ".clj",
        ".boot",
        ".cl2",
        ".cljc",
        ".cljs",
        ".cljs.hl",
        ".cljscm",
        ".cljx",
        ".hic",
      ],
      filenames: ["riemann.config"],
      language_id: 62,
    },
    id: "LLS5",
  },
  {
    name: "CLU",
    description:
      'CLU is a programming language created at the Massachusetts Institute of Technology (MIT) by Barbara Liskov and her students starting in 1973. While it did not find extensive use, it introduced many features that are used widely now, and is seen as a step in the development of object-oriented programming (OOP). Key contributions include abstract data types, call-by-sharing, iterators, multiple return values (a form of parallel assignment), type-safe parameterized types, and type-safe variant types. It is also notable for its use of classes with constructors and methods, but without inheritance. The syntax of CLU was based on ALGOL, then the starting point for most new language designs. The key addition was the concept of a cluster, CLU\'s type extension system and the root of the language\'s name (CLUster). Clusters correspond generally to the concept of a "class" in an OO language. For instance, here is the CLU syntax for a cluster that implements complex numbers: A cluster is a module that encapsulates all of its components except for those explicitly named in the "is" clause. These correspond to the public components of a class in recent OO languages. A cluster also defines a type that can be named outside the cluster (in this case, "complex_number"), but its representation type (rep) is hidden from external clients.',
    Paradigm: "multi-paradigm: object-oriented, procedural",
    "Designed by": "Barbara Liskov and her students",
    Developer: "Massachusetts Institute of Technology",
    "First appeared": "1975; 47 years ago",
    "Stable release":
      "Native CLU 1.5 (SPARC, VAX) / May 26, 1989; 32 years ago   Portable CLU / November 6, 2009; 12 years ago",
    "Typing discipline": "strong",
    Website: "pmg.csail.mit.edu/CLU.html",
    id: "U3GW",
  },
  {
    name: "CMS-2",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/f/f1/CMS-2Y_Programmers_Reference_Manual_for_the_AN_UYK-7_and_AN_UYK-43_Oct86.jpg/220px-CMS-2Y_Programmers_Reference_Manual_for_the_AN_UYK-7_and_AN_UYK-43_Oct86.jpg",
    description:
      'CMS-2 was developed by RAND Corporation in the early 1970s and stands for "Compiler Monitor System". The name "CMS-2" is followed in literature by a letter designating the type of target system. For example, CMS-2M targets Navy 16-bit processors, such as the AN/AYK-14. CMS-2 was developed for FCPCPAC (Fleet Computer Programming Center - Pacific) in San Diego, CA. It was implemented by Computer Sciences Corporation in 1968 with design assistance from Intermetrics. The language continued to be developed, eventually supporting a number of computers including the AN/UYK-7 and AN/UYK-43 and UYK-20 and UYK-44  computers. CMS-2 was designed to encourage program modularization, permitting independent compilation of portions of a total system. The language is statement oriented. The source is free-form and may be arranged for programming convenience. Data types include fixed-point, floating-point, boolean, character and status. Direct reference to, and manipulation of character and bit strings is permitted. Symbolic machine code may be included, known as direct code. A CMS-2 program is composed of statements. Statements are made up of symbols separated by delimiters. The categories of symbols include operators, identifiers, and constants. The operators are language primitives assigned by the compiler for specific operations or definitions in a program. Identifiers are unique names assigned by the programmer to data units, program elements and statement labels. Constants are known values that may be numeric, Hollerith strings, status values or Boolean.',
    Paradigm: "Imperative",
    "Designed by": "RAND, Intermetrics",
    Developer: "Computer Sciences Corporation",
    "First appeared": "1968",
    id: "rUj9",
  },
  {
    name: "COBOL",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/COBOL_Report_Apr60.djvu/page1-220px-COBOL_Report_Apr60.djvu.jpg",
    description:
      'COBOL (/ˈkoʊbɒl, -bɔːl/; an acronym for "common business-oriented language") is a compiled English-like computer programming language designed for business use. It is an imperative, procedural and, since 2002, object-oriented language. COBOL is primarily used in business, finance, and administrative systems for companies and governments. COBOL is still widely used in applications deployed on mainframe computers, such as large-scale batch and transaction processing jobs. However, due to its declining popularity and the retirement of experienced COBOL programmers, programs are being migrated to new platforms, rewritten in modern languages or replaced with software packages. Most programming in COBOL is now purely to maintain existing applications; however, many large financial institutions were still developing new systems in COBOL as late as 2006. COBOL was designed in 1959 by CODASYL and was partly based on the programming language FLOW-MATIC designed by Grace Hopper. It was created as part of a US Department of Defense effort to create a portable programming language for data processing. It was originally seen as a stopgap, but the Department of Defense promptly forced computer manufacturers to provide it, resulting in its widespread adoption. It was standardized in 1968 and has since been revised four times. Expansions include support for structured and object-oriented programming. The current standard is ISO/IEC 1989:2014. COBOL statements have an English-like syntax, which was designed to be self-documenting and highly readable. However, it is verbose and uses over 300 reserved words. In contrast with modern, succinct syntax like y = x;, COBOL has a more English-like syntax (in this case, MOVE x TO y). COBOL code is split into four divisions (identification, environment, data, and procedure) containing a rigid hierarchy of sections, paragraphs and sentences. Lacking a large standard library, the standard specifies 43 statements, 87 functions and just one class. Academic computer scientists were generally uninterested in business applications when COBOL was created and were not involved in its design; it was (effectively) designed from the ground up as a computer language for business, with an emphasis on inputs and outputs, whose only data types were numbers and strings of text. COBOL has been criticized throughout its life for its verbosity, design process, and poor support for structured programming. These weaknesses result in monolithic, verbose (intended to be English-like) programs that are not easily comprehensible.',
    Paradigm: "Procedural, imperative, object-oriented",
    "Designed by":
      "Howard Bromberg, Norman Discount, Vernon Reeves, Jean E. Sammet, William Selden, Gertrude Tierney, with indirect influence from Grace Hopper",
    Developers: "CODASYL, ANSI, ISO",
    "First appeared": "1959; 63 years ago",
    "Stable release": "ISO/IEC 1989:2014 / 2014",
    "Typing discipline": "Weak, static",
    "Filename extensions": ".cbl, .cob, .cpy",
    other_details: {
      type: "programming",
      extensions: [".cob", ".cbl", ".ccp", ".cobol", ".cpy"],
      ace_mode: "cobol",
      codemirror_mode: "cobol",
      codemirror_mime_type: "text/x-cobol",
      language_id: 48,
    },
    id: "wjAc",
  },
  {
    name: "CoffeeScript",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/1/1c/CoffeeScript-logo.png/220px-CoffeeScript-logo.png",
    description:
      'CoffeeScript support is included in Ruby on Rails version 3.1 and Play Framework. In 2011, Brendan Eich referenced CoffeeScript as an influence on his thoughts about the future of JavaScript. On December 13, 2009, Jeremy Ashkenas made the first Git commit of CoffeeScript with the comment: "initial commit of the mystery language." The compiler was written in Ruby. On December 24, he made the first tagged and documented release, 0.1.0. On February 21, 2010, he committed version 0.5, which replaced the Ruby compiler with a self-hosting version in pure CoffeeScript. By that time the project had attracted several other contributors on GitHub, and was receiving over 300 page hits per day. On December 24, 2010, Ashkenas announced the release of stable 1.0.0 to Hacker News, the site where the project was announced for the first time. On September 18, 2017, version 2.0.0 was introduced, which "aims to bring CoffeeScript into the modern JavaScript era, closing gaps in compatibility with JavaScript while preserving the clean syntax that is CoffeeScript’s hallmark."',
    Paradigm:
      "Multi-paradigm: prototype-based, functional, imperative, scripting",
    "Designed by": "Jeremy Ashkenas",
    Developer: "Jeremy Ashkenas",
    "First appeared": "December 13, 2009; 12 years ago",
    "Stable release": "2.6.1  / 4 October 2021; 3 months ago",
    "Typing discipline": "dynamic, implicit",
    OS: "Cross-platform",
    License: "MIT License",
    "Filename extensions": ".coffee, .litcoffee[citation needed]",
    Website: "coffeescript.org",
    other_details: {
      type: "programming",
      tm_scope: "source.coffee",
      ace_mode: "coffee",
      codemirror_mode: "coffeescript",
      codemirror_mime_type: "text/x-coffeescript",
      color: "#244776",
      aliases: ["coffee", "coffee-script"],
      extensions: [".coffee", "._coffee", ".cake", ".cjsx", ".iced"],
      filenames: ["Cakefile"],
      interpreters: ["coffee"],
      language_id: 63,
    },
    id: "6OH1",
  },
  {
    2016: "Update 16 (2016,0,16,320445) / July 14, 2020; 18 months ago",
    2018: "Update 10 (2018,0,10,320417) / July 14, 2020; 18 months ago",
    2021: "2021 / November 11, 2020; 14 months ago",
    name: "Adobe ColdFusion",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Adobe_ColdFusion_10_icon.png/64px-Adobe_ColdFusion_10_icon.png",
    description:
      "One of the distinguishing features of ColdFusion is its associated scripting language, ColdFusion Markup Language (CFML). CFML compares to the scripting components of ASP, JSP, and PHP in purpose and features, but its tag syntax more closely resembles HTML, while its script syntax resembles JavaScript. ColdFusion is often used synonymously with CFML, but there are additional CFML application servers besides ColdFusion, and ColdFusion supports programming languages other than CFML, such as server-side Actionscript and embedded scripts that can be written in a JavaScript-like language known as CFScript. Originally a product of Allaire and released on July 2, 1995, ColdFusion was developed by brothers Joseph J. Allaire and Jeremy Allaire. In 2001 Allaire was acquired by Macromedia, which in turn was acquired by Adobe Systems Inc in 2005. ColdFusion is most often used for data-driven websites or intranets, but can also be used to generate remote services such as REST services, WebSockets, SOAP web services or Flash remoting. It is especially well-suited as the server-side technology to the client-side ajax. ColdFusion can also handle asynchronous events such as SMS and instant messaging via its gateway interface, available in ColdFusion MX 7 Enterprise Edition.",
    "Original author(s)": "J. J. Allaire",
    "Developer(s)": "Adobe Systems Incorporated",
    "Initial release": "1995; 27 years ago",
    "Written in": "Java",
    "Operating system": "Cross-platform",
    "Available in": "English",
    Type: "Application server",
    License: "Proprietary",
    Website: "www.adobe.com/products/coldfusion-family.html",
    id: "VSqM",
  },
  {
    name: "COMAL",
    description:
      '"COMAL Kernel Syntax & Semantics" contains the formal definition of the language. Further extensions are common to many implementations. COMAL was created as a mixture of the prevalent educational programming languages of the time, BASIC, Pascal, and, at least in the Commodore and Compis versions, the turtle graphics of Logo. The language was meant to introduce structured programming elements in an environment where BASIC would normally be used. With the benefit of hindsight, COMAL looks like a Structured BASIC that has reasonably well-written, vendor neutral, free, standards.[original research?] It is never necessary to use GOTO, and line numbers are purely for editing purposes rather than flow control. Note, however, that the standardised language only supports control structuring, not data structuring such as records or structs (commercial implementations such as UniCOMAL 3 supported this as an extension). COMAL was originally developed in Denmark by mathematics teacher Børge R. Christensen. The school in which he taught had received a Data General NOVA 1200 minicomputer in 1972, with the expectation that the school would begin to teach computer science. Christensen, who had taken a short course on the subject at university, was expected to lead the program and to maintain the computer system. The NOVA 1200 was supplied with Data General Extended BASIC, and Christensen quickly became frustrated with the way in which the unstructured language led students to write low-quality code that was difficult to read and thus mark. Christensen met with computer scientist Benedict Løfstedt, who encouraged him to read Systematic Programming, the then-new book on programming language design by Niklaus Wirth, the creator of Pascal. Christensen was impressed, but found that he could not use Pascal directly, as it lacked the interactive shell that made BASIC so easy for students to develop with. Over the next six months Christensen and Løfstedt corresponded by mail to design an alternative to BASIC which retained its interactive elements but added structured elements from Pascal. By 1974 the language\'s definition was complete but Christensen was unsuccessful in attracting interest from software firms in developing an implementation. He therefore worked with two of his students, to whom he had taught NOVA 1200 machine language, to write an implementation themselves, over another six months. The first proof-of-concept implementation (running a five-line loop) was ready on 5 August 1974, and the first release (on paper tape, as this was what the NOVA 1200 used for input-output) was ready in February 1975. Development costs had been around US$300. Only now did the system (which had previously used an internal Danish name) pick up the name COMAL, for Common Algorithmic Language, inspired by ALGOL, with which Christensen had been experimenting. The first release was therefore named COMAL 75. Christensen subsequently wrote a textbook on the language which evolved into Beginning COMAL.',
    Paradigm: "Structured",
    "Designed by": "Børge R. Christensen, Benedict Løfstedt",
    "First appeared": "1975",
    "Typing discipline": "Strong",
    id: "-Qs2",
  },
  {
    name: "COMPASS",
    description:
      "CIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of C# and the CLI, the bytecode is now officially known as CIL. Windows Defender virus definitions continue to refer to binaries compiled with it as MSIL. During compilation of CLI programming languages, the source code is translated into CIL code rather than into platform- or processor-specific object code. CIL is a CPU- and platform-independent instruction set that can be executed in any environment supporting the Common Language Infrastructure, such as the .NET runtime on Windows, or the cross-platform Mono runtime. In theory, this eliminates the need to distribute different executable files for different platforms and CPU types. CIL code is verified for safety during runtime, providing better security and reliability than natively compiled executable files. The execution process looks like this: CIL bytecode has instructions for the following groups of tasks:",
    id: "q1O0",
  },
  {
    name: "Common Lisp",
    description:
      "Common Lisp (CL) is a dialect of the Lisp programming language, published in ANSI standard document ANSI INCITS 226-1994 (S20018) (formerly X3.226-1994 (R1999)). The Common Lisp HyperSpec, a hyperlinked HTML version, has been derived from the ANSI Common Lisp standard. The Common Lisp language was developed as a standardized and improved successor of Maclisp. By the early 1980s several groups were already at work on diverse successors to MacLisp: Lisp Machine Lisp (aka ZetaLisp), Spice Lisp, NIL and S-1 Lisp. Common Lisp sought to unify, standardise, and extend the features of these MacLisp dialects. Common Lisp is not an implementation, but rather a language specification. Several implementations of the Common Lisp standard are available, including free and open-source software and proprietary products. Common Lisp is a general-purpose, multi-paradigm programming language. It supports a combination of procedural, functional, and object-oriented programming paradigms. As a dynamic programming language, it facilitates evolutionary and incremental software development, with iterative compilation into efficient run-time programs. This incremental development is often done interactively without interrupting the running application. It also supports optional type annotation and casting, which can be added as necessary at the later profiling and optimization stages, to permit the compiler to generate more efficient code. For instance, fixnum can hold an unboxed integer in a range supported by the hardware and implementation, permitting more efficient arithmetic than on big integers or arbitrary precision types. Similarly, the compiler can be told on a per-module or per-function basis which type of safety level is wanted, using optimize declarations. Common Lisp includes CLOS, an object system that supports multimethods and method combinations. It is often implemented with a Metaobject Protocol.",
    Paradigm:
      "Multi-paradigm: procedural, functional, object-oriented, meta, reflective, generic",
    Family: "Lisp",
    "Designed by":
      "Scott Fahlman, Richard P. Gabriel, David A. Moon, Kent Pitman, Guy Steele, Dan Weinreb",
    Developer: "ANSI X3J13 committee",
    "First appeared":
      "1984 (38 years ago), 1994 (28 years ago) for ANSI Common Lisp",
    "Typing discipline": "Dynamic, strong",
    Scope: "Lexical, optionally dynamic",
    OS: "Cross-platform",
    "Filename extensions": ".lisp, .lsp, .l, .cl, .fasl",
    Website: "common-lisp.net",
    other_details: {
      type: "programming",
      tm_scope: "source.lisp",
      color: "#3fb68b",
      aliases: ["lisp"],
      extensions: [
        ".lisp",
        ".asd",
        ".cl",
        ".l",
        ".lsp",
        ".ny",
        ".podsl",
        ".sexp",
      ],
      interpreters: ["lisp", "sbcl", "ccl", "clisp", "ecl"],
      ace_mode: "lisp",
      codemirror_mode: "commonlisp",
      codemirror_mime_type: "text/x-common-lisp",
      language_id: 66,
    },
    id: "4VT4",
  },
  {
    name: "Constraint Handling Rules (CHR)",
    description:
      "There are two flavors of COMPASS on the 60-bit machines: COMPASS is a classical two-pass assembler with macro and conditional assembly features, and generates a full listing showing both the source assembly code and the generated machine code (in octal). CDC's operating systems were written almost entirely in COMPASS assembly language. Central processor (CP or CPU) hardware maintains 24 operational registers, named A0 to A7, X0 to X7 and B0 to B7. Registers X0 to X7 are 60 bits long and are used to hold data, while registers B0 to B7 are 18 bits long and their major purpose is to hold either addresses or be used as indexing registers, except that B0 is always zero. As a programming convention, B1 (or B7) often contains positive 1. A or address registers are also 18 bits long. Each A register pairs with the corresponding X register. Whenever an address is set into any of A1 to A5 registers, the data at that memory location (address) is loaded into the corresponding X register. Likewise, setting an address into one of A6 or A7 registers stores the data held in the corresponding X6 or X7 register to that memory location. However, A0 can be used to hold any address without affecting the contents of register X0.",
    id: "22OA",
  },
  {
    name: "Component Pascal",
    description:
      "Component Pascal is a programming language in the tradition of Niklaus Wirth's Pascal, Modula-2, Oberon and Oberon-2. It bears the name of the language Pascal and preserves its heritage, but is incompatible with Pascal. Instead, it is a minor variant and refinement of Oberon-2 with a more expressive type system and built-in string support. Component Pascal was originally named Oberon/L, and was designed and supported by a small ETH Zürich spin-off company named Oberon microsystems. They developed an integrated development environment (IDE) named BlackBox Component Builder. Since 2014, development and support has been taken over by a small group of volunteers. The first version of the IDE was released in 1994, as Oberon/F. At the time, it presented a novel approach to graphical user interface (GUI) construction based on editable forms, where fields and command buttons are linked to exported variables and executable procedures. This approach bears some similarity to the code-behind way used in Microsoft's .NET 3.0 to access code in Extensible Application Markup Language (XAML), which was released in 2008. An open-source software implementation of Component Pascal exists for the .NET and Java virtual machine (JVM) platforms, from the Gardens Point team around John Gough at Queensland University of Technology in Australia. On 23 June 2004 Oberon microsystems announced that the BlackBox Component Builder was made available as a free download and that an open-source version was planned. The beta open-source version was initially released in December 2004 and updated to a final v1.5 release in December 2005. It includes the complete source code of the IDE, compiler, debugger, source analyser, profiler, and interfacing libraries, and can also be downloaded from their website. Several release candidates for v1.6 appeared in the years 2009–2011, the latest one (1.6rc6) appeared on Oberon microsystems web pages in 2011. At the end of 2013, Oberon microsystems released the final release 1.6. It is probably the last release bundled by them. A small community took over the ongoing development. BlackBox Component Pascal uses the extensions .odc (Oberon document) for document files, such as source files for example, and .osf (Oberon symbol file) for symbol files while Gardens Point Component Pascal uses .cp for source and .cps for symbol files. BlackBox Component Pascal has its own executable and loadable object format .ocf (Oberon code file); it includes a runtime linking loader for this format. The document format (.odc) is a rich text binary format, which allows nice formatting, supports conditional folding, and allows active content to be embedded in the source text. It also handles user interface elements in editable forms. This is in tradition of the Oberon Text format.",
    Paradigms: "Imperative, structured, modular, object-oriented",
    Family: "Wirth Oberon",
    Developer: "Oberon microsystems",
    "First appeared": "1997; 25 years ago",
    "Typing discipline": "Strong, static",
    Scope: "Lexical",
    Website: "blackboxframework.org",
    other_details: {
      type: "programming",
      color: "#B0CE4E",
      extensions: [".cp", ".cps"],
      tm_scope: "source.pascal",
      aliases: ["delphi", "objectpascal"],
      ace_mode: "pascal",
      codemirror_mode: "pascal",
      codemirror_mime_type: "text/x-pascal",
      language_id: 67,
    },
    id: "tBiK",
  },
  {
    name: "Constraint Handling Rules (CHR)",
    description:
      'A CHR program, sometimes called a constraint handler, is a set of rules that maintain a constraint store, a multi-set of logical formulas. Execution of rules may add or remove formulas from the store, thus changing the state of the program. The order in which rules "fire" on a given constraint store is non-deterministic, according to its abstract semantics and deterministic (top-down rule application), according to its refined semantics. Although CHR is Turing complete, it is not commonly used as a programming language in its own right. Rather, it is used to extend a host language with constraints. Prolog is by far the most popular host language and CHR is included in several Prolog implementations, including SICStus and SWI-Prolog, although CHR implementations also exist for Haskell, Java, C, SQL, and JavaScript. In contrast to Prolog, CHR rules are multi-headed and are executed in a committed-choice manner using a forward chaining algorithm. The concrete syntax of CHR programs depends on the host language, and in fact programs embed statements in the host language that are executed to handle some rules. The host language supplies a data structure for representing terms, including logical variables. Terms represent constraints, which can be thought of as "facts" about the program\'s problem domain. Traditionally, Prolog is used as the host language, so its data structures and variables are used. The rest of this section uses a neutral, mathematical notation that is common in the CHR literature. A CHR program, then, consists of rules that manipulate a multi-set of these terms, called the constraint store. Rules come in three types:',
    Paradigms: "Constraint logic, declarative",
    "Designed by": "Thom Frühwirth",
    "First appeared": "1991; 31 years ago",
    Website: "constraint-handling-rules.org",
    id: "t6Yd",
  },
  {
    name: "COOL",
    description:
      'The reference Cool compiler is written in C++, built fully on the public domain tools. It generates code for a MIPS simulator, SPIM. Thus, the language should port easily to other platforms. It has been used for teaching compilers at many institutions (such as the University of California at Berkeley, where it was first used or Shahid Beheshti University of Iran) and the software is stable. This language is unrelated to the COOL language included in CLIPS. As the primary purpose of Cool is instruction, it lacks many of the features common to other, more general programming languages. For instance, the language supports less than comparisons but not greater than. The syntax is very much stripped down, and the "standard library" contains only a few basic classes. Separate compilation is not supported, though the compiler does support multiple source files as input. Every Cool program must define a class Main which must have a no argument main method in which execution flow begins. Namespaces are not supported. "Hello, world!":',
    Paradigm: "Object-oriented",
    "Designed by": "Alexander Aiken",
    Developer: "Alexander Aiken",
    "First appeared": "1996",
    "Typing discipline": "Static, strong, manifest",
    id: "L39Z",
  },
  {
    name: "Coq (software)",
    image: "https://upload.wikimedia.org/wikipedia/commons/d/d8/Coq_logo.png",
    description:
      'The Association for Computing Machinery awarded Thierry Coquand, Gérard Huet, Christine Paulin-Mohring, Bruno Barras, Jean-Christophe Filliâtre, Hugo Herbelin, Chetan Murthy, Yves Bertot, and Pierre Castéran with the 2013 ACM Software System Award for Coq. Coq is a wordplay on the name of Thierry Coquand, Calculus of Constructions or "CoC" and is following the French tradition to name tools after animals (coq in French meaning rooster). When viewed as a programming language, Coq implements a dependently typed functional programming language; when viewed as a logical system, it implements a higher-order type theory. The development of Coq has been supported since 1984 by INRIA, now in collaboration with École Polytechnique, University of Paris-Sud, Paris Diderot University, and CNRS. In the 1990s, ENS Lyon was also part of the project. The development of Coq was initiated by Gérard Huet and Thierry Coquand, and more than 40 people, mainly researchers, have contributed features to the core system since its inception. The implementation team has successively been coordinated by Gérard Huet, Christine Paulin-Mohring, Hugo Herbelin, and Matthieu Sozeau. Coq is mainly implemented in OCaml with a bit of C. The core system can be extended by way of a plug-in mechanism. The name coq means "rooster" in French and stems from a French tradition of naming research development tools after animals. Up until 1991, Coquand was implementing a language called the Calculus of Constructions and it was simply called CoC at this time. In 1991, a new implementation based on the extended Calculus of Inductive Constructions was started and the name was changed from CoC to Coq in an indirect reference to Coquand, who developed the Calculus of Constructions along with Gérard Huet and contributed to the Calculus of Inductive Constructions with Christine Paulin-Mohring.',
    "Developer(s)": "The Coq development team",
    "Initial release": "1 May 1989; 32 years ago (version 4.10)",
    "Stable release": "8.13.1 / 22 February 2021; 10 months ago",
    "Preview release": "8.13+beta1 / 7 December 2020; 13 months ago",
    Repository: "github.com/coq/coq",
    "Written in": "OCaml",
    "Operating system": "Cross-platform",
    "Available in": "English",
    Type: "Proof assistant",
    License: "LGPLv2.1",
    Website: "coq.inria.fr",
    id: "_xKg",
  },
  {
    name: "Coral 66",
    description:
      'CORAL, short for Computer On-line Real-time Applications Language is a programming language originally developed in 1964 at the Royal Radar Establishment (RRE), Malvern, Worcestershire, in the United Kingdom. The R was originally for "radar", not "real-time". It was influenced primarily by JOVIAL, and thus ALGOL, but is not a subset of either. The most widely-known version, CORAL 66, was subsequently developed by I. F. Currie and M. Griffiths under the auspices of the Inter-Establishment Committee for Computer Applications (IECCA). Its official definition, edited by Woodward, Wetherall, and Gorman, was first published in 1970. In 1971, CORAL was selected by the Ministry of Defence as the language for future military applications and to support this, a standardization program was introduced to ensure CORAL compilers met the specifications. This process was later adopted by the US Department of Defense while defining Ada. Coral 66 is a general-purpose programming language based on ALGOL 60, with some features from Coral 64, JOVIAL, and Fortran. It includes structured record types (as in Pascal) and supports the packing of data into limited storage (also as in Pascal). Like Edinburgh IMP it allows inline (embedded) assembly language, and also offers good runtime checking and diagnostics. It is designed for real-time computing and embedded system applications, and for use on computers with limited processing power, including those limited to fixed-point arithmetic and those without support for dynamic storage allocation.',
    Paradigms: "procedural, imperative, structured",
    Family: "ALGOL",
    "Designed by": "Philip Woodward, I. F. Currie, M. Griffiths",
    Developer: "Royal Radar Establishment",
    "First appeared": "1964; 58 years ago",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    "Implementation language": "BCPL",
    Platform:
      "CTL Modular-1, DEC Alpha, GEC, Ferranti, Honeywell, HPE Integrity Servers, Interdata 8/32, PDP-11, SPARC, VAX, x86, Intel 8080, Zilog Z80, Motorola 68000",
    OS: "OpenVMS, BSD Unix, Linux, Solaris",
    id: "Mbfd",
  },
  {
    name: "CorVision",
    description:
      "CorVision can be traced back to 1972 when Lou Santoro and Mike Lowery created INFORM for the newly formed time-sharing company Standard Information Systems (SIS). INFORM contained some of CorVisions basic utility commands such as SORT, REPORT, LIST and CONSOLIDATE. Some of the first users of INFORM were New England Telephone, Polaroid and Temple Barker & Sloan. By 1972 SIS had offices in Los Angeles, Garden Grove, Minneapolis, Chicago, Boston, New York City, District of Columbia, Charlotte, Raleigh, Atlanta and Phoenix. Between 1976 and 1977 Ken Levitt and Dick Berthold of SIS ported INFORM from the CDC-3600 to the PDP-11/70 under IAS. They called this new tool INFORM-11. Cortex was founded in 1978 by Sherm Uchill, Craig Hill, Mike Lowery, and Dick Berthold to market INFORM-11. INFORM-11 was first used to deliver a 20-user order entry system at Eddie Bauer, and to deliver an insurance processing system for Consolidated Group Trust. Between 1981 and 1982 Cortex received significant investment from A. B. Dick. Using this new investment, Cortex ported INFORM to Digital Equipment Corporation's new VAX/VMS, adding compiled executables. INFORM-11 was promoted by both Cortex and Digital as a pioneering rapid application development system. In 1984 Jim Warner encapsulated INFORM in a repository-based development tool and called it Application Factory. INFORM's PROCESS procedural language became known as BUILDER within Application Factory. In 1986 the name of Application Factory was dropped in favor of the name CorVision.",
    Developer: "Cortex",
    "First appeared": "1986",
    id: "RPLz",
  },
  {
    name: "COWSEL",
    description:
      "COWSEL was initially implemented on a Ferranti Pegasus computer at the University of Leeds and on a Stantec Zebra at the Bradford Institute of Technology; later, Rod Burstall implemented it on an Elliot 4120 at the University of Edinburgh. COWSEL was renamed POP-1 during the summer of 1966 and development continued under that name from then on. Note that keywords were also underlined in the original printouts. Popplestone used a Flexowriter with underscoring for syntax highlighting. This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    Developer: "Burstall, Popplestone",
    "First appeared": "1964",
    id: "BpM7",
  },
  {
    name: "CPL",
    description:
      'CPL was developed initially at the Mathematical Laboratory at the University of Cambridge as the "Cambridge Programming Language" and later published jointly between Cambridge and the University of London Computer Unit as the "Combined Programming Language". Christopher Strachey, David Barron and others were involved in its development. (CPL was also nicknamed by some as "Cambridge Plus London" or "Christopher\'s Programming Language"). The first paper describing it was published in 1963, while it was being implemented on the Titan Computer at Cambridge and the Atlas Computer at London. It was heavily influenced by ALGOL 60, but instead of being extremely small, elegant and simple, CPL was intended for a wider application area than scientific calculations and was therefore much more complex and not as elegant as ALGOL 60. CPL was a big language for its time. CPL attempted to go beyond ALGOL to include industrial process control, business data processing and possibly some early command line games. CPL was intended to allow low-level programming and high level abstractions using the same language. However, CPL was only implemented very slowly. The first CPL compiler was probably written about 1970, but the language never gained much popularity and seems to have disappeared without trace sometime in the 1970s. BCPL (for "Basic CPL", although originally "Bootstrap CPL") was a much simpler language based on CPL intended primarily as a systems programming language, particularly for writing compilers; it was first implemented in 1967, prior to CPL\'s first implementation. BCPL then led, via B, to the popular and influential C programming language.',
    Paradigm: "Multi-paradigm: procedural, imperative, structured, functional",
    "Designed by": "Christopher Strachey et al.",
    "First appeared": "1963; 59 years ago",
    id: "9CO6",
  },
  {
    name: "Crystal",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Crystal_language_logo.svg/220px-Crystal_language_logo.svg.png",
    description:
      "Work on the language began in June 2011, with the aim of merging the elegance and productivity of Ruby with the speed, efficiency, and type safety of a compiled language. Initially named Joy, it was quickly renamed to Crystal. The Crystal compiler was first written in Ruby, but later rewritten in Crystal, thus becoming self-hosting, as of November 2013. The first official version was released in June 2014. In July 2016, Crystal joined the TIOBE index. Although resembling the Ruby language in syntax, Crystal compiles to much more efficient native code using an LLVM backend, at the cost of precluding the dynamic aspects of Ruby. However, the advanced global type inference used by the Crystal compiler, combined with the use of union types, gives Crystal the feel of a higher-level scripting language more so than many other comparable programming languages. The language has automated garbage collection and currently offers a Boehm collector. Crystal possesses a macro system and supports generics as well as both method and operator overloading. Crystal's concurrency model is inspired by communicating sequential processes (CSP) and implements light-weight fibers and channels (for communicating between fibers) inspired by Go. This is the simplest way to write the Hello World program in Crystal:",
    Paradigm: "Multi-paradigm: object-oriented, concurrent",
    "Designed by": "Ary Borenszweig, Juan Wajnerman, Brian Cardiff",
    Developer: "Manas Technology Solutions",
    "First appeared": "June 19, 2014; 7 years ago",
    "Stable release": "1.3.0  / 6 January 2022; 3 days ago",
    "Typing discipline": "static, inferred, nominal, duck",
    "Implementation language": "Crystal",
    Platform: "IA-32 (i386), x86-64, AArch64",
    OS: "Linux, macOS, FreeBSD, OpenBSD",
    License: "Apache License 2.0",
    "Filename extensions": ".cr",
    Website: "crystal-lang.org",
    other_details: {
      type: "programming",
      color: "#000100",
      extensions: [".cr"],
      ace_mode: "ruby",
      codemirror_mode: "crystal",
      codemirror_mime_type: "text/x-crystal",
      tm_scope: "source.crystal",
      interpreters: ["crystal"],
      language_id: 72,
    },
    id: "uEBU",
  },
  {
    name: "Csound",
    description:
      "It is free software, available under the LGPL-2.1-or-later. Csound was originally written at MIT by Barry Vercoe in 1985, based on his earlier system called Music 11, which in its turn followed the MUSIC-N model initiated by Max Mathews at the Bell Labs. Its development continued throughout the 1990s and 2000s, led by John Fitch at the University of Bath. The first documented version 5 release is version 5.01 on March 18, 2006. Many developers have contributed to it, most notably Istvan Varga, Gabriel Maldonado, Robin Whittle, Richard Karpen, Iain McCurdy, Michael Gogins, Matt Ingalls, Steven Yi, Richard Boulanger, Victor Lazzarini and Joachim Heintz. Developed over many years, it currently has nearly 1700 unit generators. One of its greatest strengths is that it is completely modular and extensible by the user. Csound is closely related to the underlying language for the Structured Audio extensions to MPEG-4, SAOL. Csound takes two specially formatted text files as input. The orchestra describes the nature of the instruments and the score describes notes and other parameters along a timeline. Csound processes the instructions in these files and renders an audio file or real-time audio stream as output.",
    "Initial release": "1986; 36 years ago",
    "Stable release": "6.16.2 / July 17, 2021; 5 months ago",
    Repository: "github.com/csound/csound ",
    "Written in": "C",
    "Operating system": "Cross-platform",
    License: "LGPL-2.1-or-later",
    Website: "csound.com",
    other_details: {
      type: "programming",
      aliases: ["csound-orc"],
      extensions: [".orc", ".udo"],
      tm_scope: "source.csound",
      ace_mode: "csound_orchestra",
      language_id: 73,
    },
    id: "5oHF",
  },
  {
    name: "Cuneiform",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/G18225.png/72px-G18225.png",
    description:
      "Cuneiform is implemented in distributed Erlang. If run in distributed mode it drives a POSIX-compliant distributed file system like Gluster or Ceph (or a FUSE integration of some other file system, e.g., HDFS). Alternatively, Cuneiform scripts can be executed on top of HTCondor or Hadoop. Cuneiform is influenced by the work of Peter Kelly who proposes functional programming as a model for scientific workflow execution. In this, Cuneiform is distinct from related workflow languages based on dataflow programming like Swift. External tools and libraries (e.g., R or Python libraries) are integrated via a foreign function interface. In this it resembles, e.g., KNIME which allows the use of external software through snippet nodes, or Taverna which offers BeanShell services for integrating Java software. By defining a task in a foreign language it is possible to use the API of an external tool or library. This way, tools can be integrated directly without the need of writing a wrapper or reimplementing the tool. Currently supported foreign programming languages are:",
    Paradigm: "functional, scientific workflow",
    "Designed by": "Jörgen Brandt",
    "First appeared": "2013",
    "Stable release": "3.0.4 / November 19, 2018",
    "Typing discipline": "static, simple types",
    "Implementation language": "Erlang",
    OS: "Linux, Mac OS",
    License: "Apache License 2.0",
    "Filename extensions": ".cfl",
    Website: "cuneiform-lang.org",
    id: "l064",
  },
  {
    name: "Curl",
    image: "https://upload.wikimedia.org/wikipedia/en/5/5a/Curl_logo.gif",
    description:
      'Curl combines text markup (as in HTML), scripting (as in JavaScript), and heavy-duty computing (as in Java, C#, or C++) within one unified framework. It is used in a range of internal enterprise, B2B, and B2C applications. Curl programs may be compiled into Curl applets, that are viewed using the Curl RTE, a runtime environment with a plugin for web browsers. Currently, it is supported on Microsoft Windows. Linux, and macOS was dropped on March 25, 2019 (starting with version 8.0.8). Curl supports "detached applets", which is a web deployed applet which runs on the user\'s desktop independent of a browser window much as in Silverlight 3 and Adobe AIR. The Curl language attempts to address a long-standing problem: the different building blocks that make up any modern web document most often require wildly different methods of implementation: different languages, different tools, different frameworks, often completely different teams. The final — and often most difficult — hurdle has been getting all of these blocks to communicate with each other in a consistent manner. Curl attempts to side-step these problems by providing a consistent syntactic and semantic interface at all levels of web content creation: from simple HTML to complex object-oriented programming. Curl is a markup language like HTML—that is, plain text is shown as text; at the same time, Curl includes an object-oriented programming language that supports multiple inheritance. Curl applications are not required to observe the separation of information, style, and behavior that HTML, Cascading Style Sheets (CSS), and JavaScript have imposed, although that style of programming can be used in Curl if desired.',
    Paradigm: "multi-paradigm: object-oriented, markup",
    "Designed by": "Steve Ward, MIT",
    Developer: "Curl, Inc., Sumisho Computer Systems Corp., SCSK Corporation",
    "First appeared": "1998",
    "Stable release": "8.0.10 / 30 August 2019; 2 years ago",
    "Typing discipline": "strong",
    OS: "Linux, MacOS, Windows",
    Website: "www.curl.com",
    id: "z5_Y",
  },
  {
    name: "Curry",
    description:
      "It is nearly a superset of Haskell, lacking support mostly for overloading using type classes, which some implementations provide anyway as a language extension, such as the Münster Curry Compiler. A functional program is a set of functions defined by equations or rules. A functional computation consists of replacing subexpressions by equal (with regard to the function definitions) subexpressions until no more replacements (or reductions) are possible and a value or normal form is obtained. For instance, consider the function double defined by The expression “double 1” is replaced by 1+1. The latter can be replaced by 2 if we interpret the operator “+” to be defined by an infinite set of equations, e.g., 1+1 = 2, 1+2 = 3, etc. In a similar way, one can evaluate nested expressions (where the subexpressions to be replaced are quoted): There is also another order of evaluation if we replace the arguments of operators from right to left:",
    Paradigm: "functional, logic, non-strict, modular",
    "Designed by": "Michael Hanus, Sergio Antoy, et al.",
    "Typing discipline": "static, strong, inferred",
    OS: "portable",
    Website: "Curry",
    id: "9-aX",
  },
  {
    name: "Cyclone",
    description:
      "Cyclone development was started as a joint project of AT&T Labs Research and Greg Morrisett's group at Cornell in 2001. Version 1.0 was released on May 8, 2006. Cyclone attempts to avoid some of the common pitfalls of C, while still maintaining its look and performance. To this end, Cyclone places the following limits on programs: To maintain the tool set that C programmers are used to, Cyclone provides the following extensions: For a better high-level introduction to Cyclone, the reasoning behind Cyclone and the source of these lists, see this paper.",
    "Designed by": "AT&T Labs",
    "First appeared": "2002; 20 years ago",
    "Final release": "1.0 / May 8, 2006; 15 years ago",
    Website: "cyclone.thelanguage.org",
    id: "eZ3U",
  },
  {
    name: "CEEMACD",
    description:
      "Cypher was largely an invention of Andrés Taylor while working for Neo4j, Inc. (formerly Neo Technology) in 2011. Cypher was originally intended to be used with the graph database Neo4j, but was opened up through the openCypher project in October 2015. The language was designed with the power and capability of SQL (standard query language for the relational database model) in mind, but Cypher was based on the components and needs of a database built upon the concepts of graph theory. In a graph model, data is structured as nodes (vertices in math and network science) and relationships (edges in math and network science) to focus on how entities in the data are connected and related to one another. Cypher is based on the Property Graph Model, which organizes data into nodes and edges (called “relationships” in Cypher). In addition to those standard graph elements of nodes and relationships, the property graph model adds labels and properties for describing finer categories and attributes of the data. Nodes are the entities in the graph. They can hold any number of attributes (key-value pairs) called properties. Nodes can be tagged with zero or more labels (like tags or categories), representing their different roles in a domain. Relationships provide directed, named, semantically-relevant connections between two node entities. A relationship always has a direction, a start node, an end node, and exactly one relationship type. Like nodes, relationships can also have properties.",
    id: "wT_M",
  },
  {
    name: "Cython",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/c/ce/Cython-logo.svg/220px-Cython-logo.svg.png",
    description:
      "Cython is a programming language that aims to be a superset of the Python programming language, designed to give C-like performance with code that is written mostly in Python with optional additional C-inspired syntax. Cython is a NumFOCUS affiliated project. Cython is a compiled language that is typically used to generate CPython extension modules. Annotated Python-like code is compiled to C or C++ then automatically wrapped in interface code, producing extension modules that can be loaded and used by regular Python code using the import statement, but with significantly less computational overhead at run time. Cython also facilitates wrapping independent C or C++ code into python-importable modules. Cython is written in Python and C and works on Windows, macOS, and Linux, producing source files compatible with CPython 2.6, 2.7, and 3.3 and later versions. Cython 3.0.0 is in development.",
    Developer: "Robert Bradshaw, Stefan Behnel, et al.",
    "First appeared": "28 July 2007; 14 years ago",
    "Stable release": "0.29.21 (8 July 2020; 18 months ago) [±]",
    "Preview release": "3.0a6 (31 July 2020; 17 months ago) [±]",
    "Implementation language": "Python",
    OS: "Windows、MacOS、Linux",
    License: "Apache License 2.0",
    "Filename extensions": ".pyx, .pxd, .pxi ",
    Website: "cython.org ",
    other_details: {
      type: "programming",
      group: "Python",
      extensions: [".pyx", ".pxd", ".pxi"],
      aliases: ["pyrex"],
      ace_mode: "text",
      codemirror_mode: "python",
      codemirror_mime_type: "text/x-cython",
      language_id: 79,
    },
    id: "28JS",
  },
  {
    name: "CEEMAC",
    description:
      'CEEMAC was designed to be a visual composition language in which the programmer designed dynamic "scores" by programatically controlling color, shape, sound and movement. Additionally, a programmer could then "perform" their score through use of the Apple II keyboard or paddle input devices to introduce additional variation. CEEMAC syntax loosely resembled a combination of BASIC and Pascal and include control commands such as GOTO, GOSUB, DO, AGAIN, FOR, SKIP, EXIT and loop control structures such as IF/WHILE and TIL/UNLESS. Additionally, 30 predefined macros were included in CEEMAC to aid in score composition. The following is a small CEEMAC sample score: CEEMAC was originally marketed through distribution of a free demonstration program entitled Fire Organ. This program contained several scores created by Boering and other programmers to demonstrate some of the capabilities of the language.',
    Paradigm: "Visual composition language",
    "Designed by": "Brooke Boering",
    Developer: "Vagabondo Enterprises",
    Platform: "Apple II",
    id: "j7_l",
  },
  {
    name: "D programming language",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/D_Programming_Language_logo.svg/120px-D_Programming_Language_logo.svg.png",
    description:
      "GDC, D, also known as Dlang, is a multi-paradigm system programming language created by Walter Bright at Digital Mars and released in 2001. Andrei Alexandrescu joined the design and development effort in 2007. Though it originated as a re-engineering of C++, D is a distinct language. It has redesigned some core C++ features, while also sharing characteristics of other languages, notably Java, Python, Ruby, C#, and Eiffel. The design goals of the language attempted to combine the performance and safety of compiled languages with the expressive power of modern dynamic languages. Idiomatic D code is commonly as fast as equivalent C++ code, while also being shorter. The language as a whole is not memory-safe but does include optional attributes designed to check memory safety. Type inference, automatic memory management and syntactic sugar for common types allow faster development, while bounds checking, design by contract features and a concurrency-aware type system help reduce the occurrence of bugs.",
    Paradigm: "Multi-paradigm: functional, imperative, object-oriented",
    "Designed by": "Walter Bright, Andrei Alexandrescu (since 2007)",
    Developer: "D Language Foundation",
    "First appeared": "8 December 2001; 20 years ago",
    "Stable release": "2.097.0  / 3 June 2021; 7 months ago",
    "Typing discipline": "Inferred, static, strong",
    OS: "FreeBSD, Linux, macOS, Windows",
    License: "Boost",
    "Filename extensions": ".d",
    Website: "dlang.org",
    id: "rx1A",
  },
  {
    name: "Dart",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Dart_programming_language_logo.svg/220px-Dart_programming_language_logo.svg.png",
    description:
      "Dart is an object-oriented, class-based, garbage-collected language with C-style syntax. Dart can compile to either native code or JavaScript. It supports interfaces, mixins, abstract classes, reified generics, and type inference. Dart was unveiled at the GOTO conference in Aarhus, Denmark, October 10–12, 2012. The project was founded by Lars Bak and Kasper Lund. Dart 1.0 was released on November 14, 2013. Dart initially had a mixed reception and the Dart initiative has been criticized by some for fragmenting the web, due to the original plans to include a Dart VM in Chrome. Those plans were dropped in 2015 with the 1.9 release of Dart to focus instead on compiling Dart to JavaScript. In August 2018, Dart 2.0 was released, with language changes including a sound type system.",
    Paradigm:
      "Multi-paradigm: functional, imperative, object-oriented, reflective",
    "Designed by": "Lars Bak and Kasper Lund",
    Developer: "Google",
    "First appeared": "October 10, 2011; 10 years ago",
    "Stable release": "2.15.1  / 14 December 2021; 33 days ago",
    "Preview release": "2.16.0-109.0.dev / December 14, 2021; 33 days ago",
    "Typing discipline": "1.x: Optional 2.x: Inferred (static, strong)",
    Platform: "Cross-platform",
    OS: "Cross-platform",
    License: "BSD",
    "Filename extensions": ".dart",
    Website: "dart.dev",
    other_details: {
      type: "programming",
      color: "#00B4AB",
      extensions: [".dart"],
      interpreters: ["dart"],
      ace_mode: "dart",
      codemirror_mode: "dart",
      codemirror_mime_type: "application/dart",
      language_id: 87,
    },
    id: "O99L",
  },
  {
    name: "DataFlex",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/3/36/DF_Logo_Compact_RGB.png",
    description:
      "DataFlex can be traced back to 1982 when the company called Data Access Corporation (founded in 1976) created and developed a language allowing application code to run on almost any system architecture, regardless of hardware. It started as a relatively early example of a fully fledged and commercially used fourth-generation programming language (4GL). In its early forms, DataFlex was available for CP/M, MS-DOS, TurboDOS, Novell NetWare, OS/2, Unix, VMS and IBM AIX operating systems. By 1985, DataFlex was applied in a variety of high-tech industries including automated inventory control systems and insurance fraud detection systems. DataFlex has lasted many years as a niche application development environment. The DataFlex product supports many relational database environments: Oracle database, Microsoft SQL Server, IBM DB2, MySQL, PostgreSQL and any ODBC database. DataFlex applications are used by around 3 million users. In 1991, the 3.0 version with a modernized interface was released. In 2014, Data Access released 2014/18.0 version. DataFlex is developed and provided by Data Access Worldwide, a software company with main offices in Miami, Florida, Hengelo, Netherlands, and São Paulo, Brazil. The DataFlex language supports:",
    "Developer(s)": "Data Access Worldwide",
    "Stable release": "20.0. / April 21, 2021; 8 months ago",
    "Operating system": "Microsoft Windows",
    Type: "Object-oriented, Integrated development environment, programming language, application framework, structured, imperative",
    License: "Commercial proprietary software",
    Website: "www.dataaccess.com/DataFlex",
    id: "rJ0V",
  },
  {
    name: "Datalog",
    description:
      "Its origins date back to the beginning of logic programming, but it became prominent as a separate area around 1977 when Hervé Gallaire and Jack Minker organized a workshop on logic and databases. David Maier is credited with coining the term Datalog. Unlike in Prolog, statements of a Datalog program can be stated in any order. Furthermore, Datalog queries on finite sets are guaranteed to terminate, so Datalog does not have Prolog's cut operator. This makes Datalog a fully declarative language. In contrast to Prolog, Datalog Query evaluation with Datalog is based on first-order logic, and is thus sound and complete. However, Datalog is not Turing complete, and is thus used as a domain-specific language that can take advantage of efficient algorithms developed for query resolution. Indeed, various methods have been proposed to efficiently perform queries, e.g., the Magic Sets algorithm, tabled logic programming or SLG resolution.",
    Paradigm: "Logic, Declarative",
    Family: "Prolog",
    "First appeared": "1986; 36 years ago",
    "Stable release": "2.0",
    "Typing discipline": "Weak",
    id: "LFIn",
  },
  {
    name: "DATATRIEVE",
    description:
      "DATATRIEVE works against flat files, indexed files, and databases. Such data files are delimited using record definitions stored in the Common Data Dictionary (CDD), or in RMS files. DATATRIEVE is used at many OpenVMS installations. DATATRIEVE was developed in the late 1970s and early 1980s by a team of software engineers at DEC's Central Commercial Engineering facilities in Merrimack and Nashua, New Hampshire, under database architect Jim Starkey. Many of the project's engineers went on to highly visible careers in database management and other software disciplines. Version 1 for the PDP-11 was released in 1977; VAX DATATRIEVE was released in 1981 as part of the VAX Information Architecture. DATATRIEVE adopted the wombat as its notional mascot; the program's help file responded to “HELP WOMBAT” with factual information about real world wombats.",
    "Developer(s)":
      "VMS Software Inc. (originally Digital Equipment Corporation)",
    "Stable release": "7.4-1 / March 2017",
    "Operating system": "OpenVMS, PDP-11 operating systems",
    "Available in": "English",
    id: "VoKh",
  },
  {
    name: "DBase",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/DBaseLogo_BlackWithRed_glass_300.png/220px-DBaseLogo_BlackWithRed_glass_300.png",
    description:
      'Originally released as Vulcan for PTDOS in 1978, the CP/M port caught the attention of Ashton-Tate in 1980. They licensed it and re-released it as dBASE II, and later ported to Apple II and IBM PC computers running DOS. On the PC platform, in particular, dBase became one of the best-selling software titles for a number of years. A major upgrade was released as dBase III, and ported to a wider variety of platforms, adding UNIX, and VMS. By the mid-1980s, Ashton-Tate was one of the "big three" software publishers in the early business software market, the others being Lotus Development and WordPerfect.[citation needed] Starting in the mid-1980s, several companies produced their own variations on the dBase product and especially the dBase programming language. These included FoxBASE+ (later renamed FoxPro), Clipper, and other so-called xBase products. Many of these were technically stronger than dBase, but could not push it aside in the market. This changed with the poor reception of dBase IV, whose design and stability were so lacking that many users switched to other products. At the same time, database products increasingly used the IBM-invented SQL (Structured Query Language). Another factor was user adoption of Microsoft Windows on desktop computers. The shift toward SQL and Windows put pressure on the makers of xBase products to invest in major redesign to provide new capabilities.[citation needed] In the early 1990s, xBase products constituted the leading database platform for implementing business applications. The size and impact of the xBase market did not go unnoticed, and within one year, the three top xBase firms were acquired by larger software companies: By the opening decade of the 21st century, most of the original xBase products had faded from prominence and many disappeared entirely. Products known as dBase still exist, owned by dBase LLC.[citation needed]',
    Paradigm: "Imperative, declarative",
    Developer: "Cecil Wayne Ratliff",
    "First appeared": "1979; 43 years ago",
    "Stable release": "dBASE 2019 / 2019; 3 years ago",
    "Implementation language": "C",
    OS: "Microsoft DOS Microsoft Windows",
    License: "Proprietary",
    Website: "www.dbase.com",
    id: "Ohf9",
  },
  {
    name: "dc",
    description:
      "This article provides some examples in an attempt to give a general flavour of the language; for a complete list of commands and syntax, one should consult the man page for one's specific implementation. dc is the oldest surviving Unix language program. When its home Bell Labs received a PDP-11, dc—written in B—was the first language to run on the new computer, even before an assembler. Ken Thompson has opined that dc was the very first program written on the machine. To multiply four and five in dc (note that most of the whitespace is optional): The results are also available from the commands:",
    "Original author(s)": "Robert Morris (AT&T Bell Laboratories)",
    "Developer(s)": "Various open-source and commercial developers",
    "Written in": "B",
    "Operating system": "Unix, Unix-like, Plan 9",
    Platform: "Cross-platform",
    Type: "Command",
    id: "Bq_8",
  },
  {
    name: "DIGITAL Command Language",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Openvms-8.4-2L1-dcl.png/300px-Openvms-8.4-2L1-dcl.png",
    description:
      "Written when the programming language Fortran was in heavy use, DCL is a scripting language supporting several datatypes, including strings, integers, bit arrays, arrays and booleans, but not floating point numbers. Access to OpenVMS system services (kernel API) is through lexical functions, which perform the same as their compiled language counterparts and allow scripts to get information on system state. DCL includes IF-THEN-ELSE, access to all the Record Management Services (RMS) file types including stream, indexed, and sequential, but unfortunately lacks a DO-WHILE or other looping construct, requiring users to make do with IF and GOTO-label statements instead. DCL is available for other operating systems as well, including DCL is the basis of the XLNT language, implemented on Windows by an interpreter-IDE-WSH engine combination with CGI capabilities distributed by Advanced System Concepts Inc. from 1997. For the OpenVMS implementation, the command line parser is a runtime library (CLI$) that can be compiled into user applications and therefore gives a consistent command line interface for both OS supplied commands and user written commands. The command line must start with a verb and is then followed by up to 8 parameters (arguments) and/or qualifiers (switches in Unix terminology) which begin with a '/' character. Unlike Unix (but similar to DOS), a space is not required before the '/'. Qualifiers can be position independent (occurring anywhere on the command line) or position dependent, in which case the qualifier affects the parameter it appears after. Most qualifiers are position independent. Qualifiers may also be assigned values or a series of values. Only the first most significant part of the verb and qualifier name is required. Parameters can be integers or alphanumeric text.",
    Paradigm: "imperative",
    "Designed by": "Digital Equipment Corporation",
    Developer: "VMS Software Inc. (VSI)",
    OS: "RSTS/E, RSX-11, RT-11, OpenVMS, VAXELN, MICA",
    other_details: {
      type: "programming",
      aliases: ["dcl"],
      extensions: [".com"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 82,
    },
    id: "eQMR",
  },
  {
    name: "Delphi",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/b/b2/Embarcadero_Delphi_10.4_Sydney_Product_Logo_and_Icon.svg/128px-Embarcadero_Delphi_10.4_Sydney_Product_Logo_and_Icon.svg.png",
    description:
      "Delphi's compilers generate native code for Microsoft Windows, macOS, iOS, Android and Linux (x64). Delphi includes a code editor, a visual designer, an integrated debugger, a source code control component, and support for third-party plugins. The code editor features Code Insight (code completion), Error Insight (real-time error-checking), and refactoring. The visual forms designer has the option of using either the Visual Component Library (VCL) for pure Windows development or the FireMonkey (FMX) framework for cross-platform development. Database support is a key feature and is provided by FireDAC (Database Access Components). Delphi is known for its fast compilation speed, native code, and developer productivity.[citation needed] Delphi was originally developed by Borland as a rapid application development tool for Windows as the successor of Turbo Pascal. Delphi added full object-oriented programming to the existing language, and the language has grown to support generics, anonymous methods, closures, and native Component Object Model (COM) support. Delphi and its C++ counterpart, C++Builder, are interoperable and jointly sold under the name RAD Studio. There are Professional, Enterprise, and Architect editions, with the higher editions having more features at a higher price. There is also a free-of-charge Community edition, with most of the features of Professional, but restricted to users and companies with low revenue.",
    "Original author(s)": "Borland, CodeGear, Embarcadero",
    "Developer(s)": "Embarcadero Technologies",
    "Stable release":
      "RAD Studio 11 Alexandria  / 9 September 2021; 4 months ago",
    "Written in": "Mostly Delphi (Object Pascal)",
    "Operating system":
      "Runs on Windows 10; targets Windows 10, Linux, macOS, Android, iOS",
    Type: "Software Development, Designer, IDE, Compiler, RTL",
    License: "Freemium",
    Website: "embarcadero.com/products/delphi",
    id: "rnR7",
  },
  {
    name: "Draco",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Dinksmallwoodlogo.png/220px-Dinksmallwoodlogo.png",
    description:
      "The game centers on Dink, a pig farmer-turned-hero who embarks on various quests throughout his world. The game features isometric, Diablo-like gameplay, including weapons, items, and magic. The game has a satirical off-color slant, including everything from a fiercely abusive uncle to a town that worships ducks. Dink is never freed from the grievances of being a pig farmer, a fact he is far too often reminded of by his nemesis, Milder Flatstomp. Dink starts out as a pig farmer, living a normal life in his village, Stonebrook. His father is said to have disappeared, leaving him behind in a small village with his mother. Somehow, as he is outside, his house burns down, killing his mother. He is then told to go out of his village, into the world to find his aunt, and start living a new life with her. Along the way, he hears of a powerful and sinister group known as the Cast whose nefarious deeds are threatening the kingdom. Dink eventually makes it his quest to defeat this mysterious cult. After that, he goes in the Darklands to kill the mighty evil, Seth. Dink Smallwood was developed by Robinson Technologies in the mid 1990s, at the time consisting of Seth Robinson, Justin Martin, and Greg Smith. Mitch Brink composed several of the game's music tracks. The game was initially released in 1997 for purchase in the United States and Europe. The game could be purchased from retail stores in Europe via European publisher Iridon Interactive; however, Robinson Technologies did not secure a publisher for the United States, requiring them to sell to this region via mail order at the price of $25 (including shipping). By the summer of 1999, Robinson Technologies had sold out of all their copies of Dink Smallwood and claimed that there were no plans to publish more copies. It was announced a short time later that the game would be distributed as freeware, and the freeware version of Dink Smallwood was released on October 17, 1999.",
    "Developer(s)": "Robinson Technologies",
    "Publisher(s)": "EU: Iridon Interactive",
    "Designer(s)": "Seth Robinson",
    "Platform(s)": "Windows, Linux, OS X, PlayStation Portable, iOS, Android",
    Release: "1998",
    "Genre(s)": "Action role-playing game",
    "Mode(s)": "Single player",
    id: "Za_f",
  },
  {
    name: "DIBOL",
    description:
      "It has a syntax similar to FORTRAN and BASIC, along with BCD arithmetic. It shares the COBOL program structure of separate data and procedure divisions. Unlike Fortran's numeric labels (for GOTO), DIBOL's were alphanumeric;  the language supported a counterpart to computed goto. DIBOL was originally marketed by Digital Equipment Corporation (DEC) in 1970. The original version, DIBOL-8, was produced for PDP-8 systems running COS-300. The PDP-8-like DECmate II, supports the COS-310 Commercial Operating System, featuring DIBOL. DIBOL-11 was developed for the PDP-11 running COS-350 operating system. It also ran on RSX-11, RT-11, and from 1978 on RSTS/E. DIBOL-32 runs on VMS systems, although it can also be used on other systems through emulators.",
    Paradigm: "procedural, imperative, structured",
    Developer: "DEC",
    "First appeared": "1970",
    "Stable release": "DIBOL 1992 / 2002",
    "Typing discipline": "static",
    id: "cHlm",
  },
  {
    name: "Dylan",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Sep_Kamvar.jpg/220px-Sep_Kamvar.jpg",
    description:
      "Kamvar's main contributions to computer science have been at the intersection of computer science and mathematics, particularly in the fields of personalized search, peer-to-peer networks, social search and data mining. As a graduate student at Stanford University, Kamvar developed tools that made it possible to compute personalized PageRank. He also developed the first efficient algorithm for adding personal context to the internet search process. In 2003, Kamvar co-founded Kaltix, a personalized search engine company. He was the CEO of Kaltix until Google acquired the company in September 2003. After the acquisition of Kaltix, Kamvar joined Google, where he led the personalization efforts between 2003 and 2007. Kamvar's research and work in peer-to-peer networks focused on the social mechanisms that reward cooperation and punish adversarial behavior. His 2003 paper, EigenTrust, is one of the most highly cited papers in the field.",
    Born: "1977 (age 44–45)",
    Nationality: "American",
    Education: "Princeton University (AB) Stanford University (PhD)",
    Occupation: "Professor at MIT",
    other_details: {
      type: "programming",
      color: "#6c616e",
      extensions: [".dylan", ".dyl", ".intr", ".lid"],
      ace_mode: "text",
      codemirror_mode: "dylan",
      codemirror_mime_type: "text/x-dylan",
      language_id: 91,
    },
    id: "IAcl",
  },
  {
    name: "DRAKON",
    description:
      'The name DRAKON is the Russian acronym for "Дружелюбный Русский Алгоритмический [язык], Который Обеспечивает Наглядность", which translates to "Friendly Russian algorithmic [language] that illustrates (or provides clarity)". The word "наглядность" (pronounced approximately as "naa-glya-dno-st-th") refers to a concept or idea being easy to imagine and understand, and may be translated as "clarity". The DRAKON language can be used both as a modelling/"markup" language (which is considered a standalone "pure DRAKON" program) and as a programming language (as part of a hybrid language). Integration of a stricter, "academic", variant of a markup language into programming, such as provided by DRAKON, adds syntactic sugar allowing users of different programming languages to easily understand the contributions of others and provide commentary if needed. The development of DRAKON started in 1986 to address the longstanding risk of misunderstandings in large projects developed by the Soviet space program, especially if multiple programming languages are used. Its development was directed by Vladimir Parondzhanov with later participation of the Russian Federal Space Agency (Academician Pilyugin Center, Moscow) and Russian Academy of Sciences (Keldysh Institute of Applied Mathematics).',
    Paradigm: "Visual",
    "First appeared": "1996",
    Website: "drakon-editor.sourceforge.net",
    id: "eI03",
  },
  {
    name: "Dylan",
    image: "https://upload.wikimedia.org/wikipedia/en/2/25/Dylan_logo.png",
    description:
      'A concise and thorough overview of the language may be found in the Dylan Reference Manual. Dylan derives from Scheme and Common Lisp and adds an integrated object system derived from the Common Lisp Object System (CLOS). In Dylan, all values (including numbers, characters, functions, and classes) are first-class objects. Dylan supports multiple inheritance, polymorphism, multiple dispatch, keyword arguments, object introspection, pattern-based syntax extension macros, and many other advanced features. Programs can express fine-grained control over dynamism, admitting programs that occupy a continuum between dynamic and static programming and supporting evolutionary development (allowing for rapid prototyping followed by incremental refinement and optimization). Dylan\'s main design goal is to be a dynamic language well-suited for developing commercial software. Dylan attempts to address potential performance issues by introducing "natural" limits to the full flexibility of Lisp systems, allowing the compiler to clearly understand compilable units, such as libraries. Dylan derives much of its semantics from Scheme and other Lisps; some Dylan implementations were initially built within extant Lisp systems. However, Dylan has an ALGOL-like syntax instead of a Lisp-like prefix syntax.',
    Paradigm: "multi-paradigm: functional, object-oriented",
    Developer:
      "Open Source Community Apple Computer, Harlequin, Carnegie Mellon University",
    "First appeared": "1992; 30 years ago",
    "Stable release": "2020.1 / October 10, 2020; 15 months ago",
    "Typing discipline": "Strong, dynamic",
    Platform: "IA-32, x86-64",
    OS: "Cross-platform",
    "Filename extensions": "dylan",
    Website: "opendylan.org",
    other_details: {
      type: "programming",
      color: "#6c616e",
      extensions: [".dylan", ".dyl", ".intr", ".lid"],
      ace_mode: "text",
      codemirror_mode: "dylan",
      codemirror_mime_type: "text/x-dylan",
      language_id: 91,
    },
    id: "PscL",
  },
  {
    name: "Easy PL/I",
    description:
      'DYNAMO was initially developed under the direction of Jay Wright Forrester in the late 1950s, by Dr. Phyllis Fox, Alexander L. Pugh III, Grace Duren, and others at the M.I.T. Computation Center. DYNAMO was used for the system dynamics simulations of global resource depletion reported in the Club of Rome\'s Limits to Growth, but has since fallen into disuse. In 1958, Forrester unwittingly instigated DYNAMO\'s development when he asked an MIT staff programmer to compute needed solutions to some equations, for a Harvard Business Review paper he was writing about industrial dynamics. The programmer, Richard Bennett, chose to implement a system (SIMPLE - "Simulation of Industrial Management Problems with Lots of Equations") that took coded equations as symbolic input and computed solutions. SIMPLE became the proof-of-concept for DYNAMO: rather than have a specialist programmer "hard-code" a special-purpose solver in a general purpose programming language, users could specify a system\'s equations in a special simulation language and get simulation output from one program execution. DYNAMO was designed to emphasize the following:',
    id: "VA6O",
  },
  {
    name: "EASYTRIEVE PLUS",
    description:
      "The Data Analysis Expressions (DAX) language provides a specialized syntax for querying Analysis Services tabular model. DAX is not a programming language. DAX is primarily a formula language and is also a query language. You can use DAX to define custom calculations for Calculated Columns, Measures, Calculated Tables, Calculation Groups, Custom Format Strings, and filter expressions in role-based security in Tabular models. The same Analysis Services engine for Tabular models is also used in Power BI and Power Pivot for Excel. Power BI also uses DAX for conditional formatting expressions and other dynamic properties of visual components. DAX was developed by the SQL Server Analysis Services team at Microsoft as part of Project Gemini and released in 2009 with the first version of the PowerPivot for Excel 2010 Add-in. Both DAX and MDX can be used to query PowerPivot and Tabular models, however only MDX may be used to query multidimensional SSAS models (cubes) in versions of SSAS up to SQL Server 2012 RTM. Future versions of SSAS (both multidimensional & tabular models) will support DAX natively. 2016 marks a significant improvement with the rapid adoption of Microsoft Power BI and SQL Server 2016. Power BI is a subscription-based self-service analytic tool and Power BI Desktop is a desktop analytic and report authoring application. SQL Server 2016 includes a new release of SQL Analysis Services Tabular with many improvements over previous versions. Enhancements to the DAX language after 2015 include support for calculated tables, automatic date table generation, variables and a total of 340 functions. DAX can compute values for seven data types: The BLOB (binary large object) data type is managed by the Tabular model but cannot be directly manipulated by DAX expressions.",
    id: "O2PN",
  },
  {
    name: "E",
    description:
      "The E language is designed with secure computing in mind; this is accomplished chiefly by strict adherence to the object-oriented computing model, which in its pure form has properties that support secure computing. The E language and its standard library employ a capability-based design philosophy throughout in order to help programmers build secure software and to enable software components to co-operate even if they don't fully trust each other. In E, object references serve as capabilities, hence capabilities add no computational or conceptual overhead costs. The language syntax is designed to be easy for people to audit for security flaws. For example, lexical scoping limits the amount of code that has to be examined for its effects on a given variable. As another example, the language uses the == operator for comparison and the := operator for assignment; to avoid the possibility of confusion, there is no = operator. In E, all values are objects and computation is performed by sending messages to objects. Each object belongs to a vat (analogous to a process). Each vat has a single thread of execution, a stack frame, and an event queue. Distributed programming is just a matter of sending messages to remote objects (objects in other vats). All communication with remote parties is encrypted by the E runtime. Arriving messages are placed into the vat's event queue; the vat's event loop processes the incoming messages one by one in order of arrival. E has two ways of sending messages: the immediate call and the eventual send. An immediate call is just like a typical function or method call in a non-concurrent language: the sender waits until the receiver finishes and returns a value. An eventual send sends the message while producing a placeholder for the result called a promise. The sender proceeds immediately with the promise. Later, when the receiver finishes and yields a result, the promise resolves to the result. Since only eventual sends are allowed when communicating with remote objects, deadlocks cannot happen. In distributed systems, the promise mechanism also minimizes delays caused by network latency. E's syntax is most similar to Java, though it also bears some resemblance to Python and Pascal. Variables are dynamically typed and lexically scoped. Unlike Java or Python, however, E is composed entirely of expressions. Here is an extremely simple E program:",
    Paradigm: "Multi-paradigm: object-oriented, message passing",
    "Designed by": "Mark S. Miller",
    "First appeared": "1997",
    "Typing discipline": "Strong, dynamic",
    OS: "Cross-platform",
    License: "Portions in different free licenses",
    Website: "erights.org",
    other_details: {
      type: "programming",
      color: "#ccce35",
      extensions: [".E"],
      interpreters: ["rune"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 92,
    },
    id: "BX0O",
  },
  {
    name: "Ease",
    description:
      "The book Process Interaction Models is the Ease language specification. Ease combines the process constructs of communicating sequential processes (CSP) with logically shared data structures called contexts. Contexts are parallel data types that are constructed by processes and provide a way for processes to interact. The language includes two process constructors. A cooperation includes an explicit barrier synchronization and is written: If one process finishes before the other, then it will wait until the other processes are finished.",
    Paradigms: "Concurrent, communicating sequential processes",
    "Designed by": "Steven Ericsson-Zenith",
    "First appeared": "1991; 31 years ago",
    "Typing discipline": "Strong",
    Platform: "Parallel",
    id: "pfYx",
  },
  {
    name: "PL/I",
    description:
      "PL/I's main domains are data processing, numerical computation, scientific computing, and system programming. It supports recursion, structured programming, linked data structure handling, fixed-point, floating-point, complex, character string handling, and bit string handling. The language syntax is English-like and suited for describing complex data formats with a wide set of functions available to verify and manipulate them. In the 1950s and early 1960s, business and scientific users programmed for different computer hardware using different programming languages. Business users were moving from Autocoders via COMTRAN to COBOL, while scientific users programmed in Fortran, ALGOL, GEORGE, and others. The IBM System/360 (announced in 1964 and delivered in 1966) was designed as a common machine architecture for both groups of users, superseding all existing IBM architectures. Similarly, IBM wanted a single programming language for all users. It hoped that Fortran could be extended to include the features needed by commercial programmers. In October 1963 a committee was formed composed originally of three IBMers from New York and three members of SHARE, the IBM scientific users group, to propose these extensions to Fortran. Given the constraints of Fortran, they were unable to do this and embarked on the design of a new programming language based loosely on ALGOL labeled NPL. This acronym conflicted with that of the UK's National Physical Laboratory and was replaced briefly by MPPL (MultiPurpose Programming Language) and, in 1965, with PL/I (with a Roman numeral \"I\"). The first definition appeared in April 1964. IBM took NPL as a starting point and completed the design to a level that the first compiler could be written: the NPL definition was incomplete in scope and in detail. Control of the PL/I language was vested initially in the New York Programming Center and later at the IBM UK Laboratory at Hursley. The SHARE and GUIDE user groups were involved in extending the language and had a role in IBM's process for controlling the language through their PL/I Projects. The experience of defining such a large language showed the need for a formal definition of PL/I. A project was set up in 1967 in IBM Laboratory Vienna to make an unambiguous and complete specification. This led in turn to one of the first large scale Formal Methods for development, VDM. Fred Brooks is credited with ensuring PL/I had the CHARACTER data type.",
    Paradigm: "Procedural, imperative, structured",
    "Designed by": "IBM and the SHARE Language Development Committee",
    Developer: "IBM",
    "First appeared": "1964; 58 years ago",
    "Stable release": "IBM Enterprise PL/I for z/OS 5.3 / September 2019",
    Website: "www.ibm.com/products/pli-compiler-zos",
    id: "-tYJ",
  },
  {
    name: "eC",
    description:
      "eC was initially developed as part of the Ecere cross-platform software development kit (SDK) project. The goals of the language are to provide object-oriented constructs, reflection, properties and dynamic modules on top of the C language while maintaining C compatibility and optimal native performance. eC currently relies on GCC or Clang to perform the final steps of compilation, using C as an intermediate language. There are, however, plans to integrate directly with LLVM to skip the intermediate C files. eC is available as part of the ecere-sdk package in Debian/Ubuntu and other derived Linux distributions. A Windows installer also bundling MinGW-w64 is available from the main website. The free and open-source SDK including the eC compiler can also be built for a number of other platforms, including OS X, FreeBSD and Android.",
    Paradigm: "Multi-paradigm: procedural, object-oriented, generic",
    "Designed by": "Jérôme Jacovella-St-Louis",
    "First appeared": "2004; 18 years ago",
    "Stable release": "Ecere SDK 0.44.15 / 4 August 2016; 5 years ago",
    "Typing discipline": "Static, nominative, partially inferred",
    "Implementation language": "eC",
    OS: "Cross-platform",
    License: "BSD-3",
    "Filename extensions": ".ec, .eh",
    Website: "ec-lang.org",
    other_details: {
      type: "programming",
      color: "#913960",
      extensions: [".ec", ".eh"],
      tm_scope: "source.c.ec",
      ace_mode: "text",
      language_id: 413,
    },
    id: "RALe",
  },
  {
    name: "ECMAScript",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/d/d3/Crystal_source.png",
    description:
      'ECMA-262 or the ECMAScript Language Specification defines the ECMAScript Language, or just ECMAScript (aka JavaScript). ECMA-262 only specifies language syntax and semantics of the core API, such as Array, Function, and globalThis, while valid implementations of JavaScript add their own functionality like input/output or file system handling. The ECMAScript specification is a standardised specification of a scripting language developed by Brendan Eich of Netscape; initially named Mocha, then LiveScript, and finally JavaScript. In December 1995, Sun Microsystems and Netscape announced JavaScript in a press release. In November 1996, Netscape announced a meeting of the Ecma International standards organization to advance the standardisation of JavaScript. The first edition of ECMA-262 was adopted by the Ecma General Assembly in June 1997. Several editions of the language standard have been published since then. The name "ECMAScript" was a compromise between the organizations involved in standardising the language, especially Netscape and Microsoft, whose disputes dominated the early standards sessions. Eich commented that "ECMAScript was always an unwanted trade name that sounds like a skin disease." ECMAScript has been formalised through operational semantics by work at Stanford University and the Department of Computing, Imperial College London for security analysis and standardisation. There are eleven editions of ECMA-262 published. Work on version 12 of the standard was finalised in June 2021. In June 2004, Ecma International published ECMA-357 standard, defining an extension to ECMAScript, known as ECMAScript for XML (E4X). Ecma also defined a "Compact Profile" for ECMAScript – known as ES-CP, or ECMA 327 – that was designed for resource-constrained devices, which was withdrawn in 2015.',
    Paradigm: "Multi-paradigm: prototype-based, functional, imperative",
    "Designed by": "Brendan Eich, Ecma International",
    "First appeared": "1997; 25 years ago",
    "Typing discipline": "weak, dynamic",
    Website: "ECMA-262, ECMA-290, ECMA-327, ECMA-357, ECMA-402",
    "Filename extensions": ".es",
    "Internet media type": "application/ecmascript",
    "Developed by": "Sun Microsystems, Ecma International",
    "Initial release": "June 1997; 24 years ago",
    "Latest release": "Edition 12 June 2021; 7 months ago",
    "Type of format": "Scripting language",
    id: "XYaE",
  },
  {
    name: "Edinburgh IMP",
    description:
      "Expressively, IMP is highly similar to ALGOL and includes all the ALGOL-style block structure, reserved words (keywords), and data types such as arrays, and records. It adds to ALGOL-style languages a string type (an array of characters, although these have a predeclared size) and built-in operators for string manipulation and character handling. IMP provides significant control over the storage mapping of data, plus commands for addressing within parts of words. Most IMP compilers offer compiler-generated runtime checks and a stack trace (backtrace) facility by default, even in production code. IMP allows inline assembler machine language instructions in source code. Early IMP compilers were developed for the English Electric KDF9, ICL System 4, UNIVAC 1108, IBM System/360, DEC PDP-9, DEC PDP-15 and CTL Modular One computers. IMP was used to implement the Edinburgh Multiple Access System (EMAS) operating system, and a compiler was written for the ICL 2900 series to allow porting of EMAS to that platform. In later years, a version of IMP named IMP77 was developed by Peter Robertson within the Computer Science department at Edinburgh which was a portable compiler that brought IMP to even more platforms. In 2002, the IMP77 language was resurrected by the Edinburgh Computer History Project for Intel x86 hardware running DOS, Windows, and Linux, and is once again in use by Edinburgh graduates and ex-pats. The diverged IMP and IMP77 were later consolidated into one language with the introduction of the IMP80 standard, supported by implementations from the Edinburgh Regional Computer Centre. IMP80 has also been ported to several platforms including Intel and was actively in use into the 1990s.",
    Paradigms: "Procedural, imperative, structured",
    Family: "ALGOL",
    "Designed by":
      "Bratley, Whitfield, M. M. Barritt, David Rees, Peter D. Schofield, Roderick McLeod, Hamish Dewar, Peter D. Stephens, Peter Robertson",
    Developer: "University of Edinburgh",
    "First appeared": "1966; 56 years ago",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    "Implementation language": "Atlas Autocode, IMP",
    Platform:
      "English Electric KDF9, ICL System 4, UNIVAC 1108, IBM System/360, DEC PDP-9, DEC PDP-15, CTL Modular One, x86",
    OS: "BOS/360, DOS, Windows, Linux",
    id: "htNa",
  },
  {
    name: "EGL (Enterprise Generation Language)",
    description:
      "The language borrows concepts familiar to anyone using statically typed languages like Java, COBOL, C, etc. However, it borrows the concept of stereotype from Unified Modeling Language (UML) that is not typically found in statically typed programming languages. In a nutshell, EGL is a higher-level, universal application development language. EGL is similar in syntax to other common languages so it can be learned by application developers with similar previous programming background. EGL application development abstractions shield programmers from the technical interfaces of systems and middleware allowing them to focus on building business functionality. EGL applications and services are written, tested and debugged at the EGL source level, and once they are satisfactorily functionally tested they can be compiled into COBOL, Java, or JavaScript code to support deployment of business applications that can run in any of the following environments: An EGL Program part is a generatable logic part with one entry point. Each Program part contains a main() function, which represents the logic that runs at program start up. A program can include other functions and can access functions that are outside of the program. The function main() can invoke those other functions. Program functions are composed of a set of EGL statements, variables, and constants. An EGL Record part defines a set of data elements. In this example, a record with the name CustomerRecord is defined with 6 fields.",
    Developer: "IBM",
    License: "Eclipse Public License",
    Website: "www.eclipse.org/edt/",
    id: "fJaW",
  },
  {
    name: "Eiffel",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Eiffel_logo.svg/220px-Eiffel_logo.svg.png",
    description:
      "The design of the language is closely connected with the Eiffel programming method. Both are based on a set of principles, including design by contract, command–query separation, the uniform-access principle, the single-choice principle, the open–closed principle, and option–operand separation. Many concepts initially introduced by Eiffel later found their way into Java, C#, and other languages.[citation needed] New language design ideas, particularly through the Ecma/ISO standardization process, continue to be incorporated into the Eiffel language. The key characteristics of the Eiffel language include: Eiffel emphasizes declarative statements over procedural code and attempts to eliminate the need for bookkeeping instructions.",
    Paradigm: "Object-oriented, Class-based, Generic, Concurrent",
    "Designed by": "Bertrand Meyer",
    Developer: "Eiffel Software",
    "First appeared": "1986",
    "Stable release": "EiffelStudio 20.11 / 21 December 2020; 12 months ago",
    "Preview release": "EiffelStudio 20.11 / 21 December 2020; 12 months ago",
    "Typing discipline": "static",
    "Implementation language": "Eiffel",
    Platform: "Cross-platform",
    OS: "FreeBSD, Linux, Mac OS X, OpenBSD, Solaris, Windows",
    License: "dual and enterprise",
    "Filename extensions": ".e",
    Website: "www.eiffel.org",
    other_details: {
      type: "programming",
      color: "#946d57",
      extensions: [".e"],
      ace_mode: "eiffel",
      codemirror_mode: "eiffel",
      codemirror_mime_type: "text/x-eiffel",
      language_id: 99,
    },
    id: "Qdo3",
  },
  {
    name: "Elixir",
    image:
      "https://upload.wikimedia.org/wikipedia/en/a/a4/Elixir_programming_language_logo.png",
    description:
      "Elixir is used by companies such as PagerDuty, Discord, Brex, E-MetroTel, Pinterest, Moz, Bleacher Report, The Outline, Inverse, Divvy, FarmBot and for building embedded systems. The community organizes yearly events in the United States, Europe and Japan as well as minor local events and conferences. José Valim is the creator of the Elixir programming language, a research and development project created at Plataformatec. His goals were to enable higher extensibility and productivity in the Erlang VM while keeping compatibility with Erlang's ecosystem. José Valim aimed to create a programming language for large-scale sites and apps. Being a Ruby developer, he used features of Ruby, Erlang, and Clojure to develop a high-concurrency and low-latency language. Elixir was designed to handle large data volumes. Its speed and capabilities spread Elixir in telecommunication, eCommerce, and finance industries. On July 12, 2018, Honeypot released a mini-documentary on Elixir.",
    Paradigm:
      "multi-paradigm: functional, concurrent, distributed, process-oriented",
    "First appeared": "2012; 10 years ago",
    "Stable release": "1.12  / 19 May 2021; 7 months ago",
    "Typing discipline": "dynamic, strong, duck",
    Platform: "Erlang",
    License: "Apache License 2.0",
    "Filename extensions": ".ex, .exs",
    Website: "elixir-lang.org",
    other_details: {
      type: "programming",
      color: "#6e4a7e",
      extensions: [".ex", ".exs"],
      ace_mode: "elixir",
      filenames: ["mix.lock"],
      interpreters: ["elixir"],
      language_id: 100,
    },
    id: "SADV",
  },
  {
    name: "Elm",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Elm_logo.svg/120px-Elm_logo.svg.png",
    description:
      'Elm was initially designed by Evan Czaplicki as his thesis in 2012. The first release of Elm came with many examples and an online editor that made it easy to try out in a web browser. Evan joined Prezi in 2013 to work on Elm, and in 2016 moved to NoRedInk as an Open Source Engineer, also starting the Elm Software Foundation. The initial implementation of the Elm compiler targets HTML, CSS, and JavaScript. The set of core tools has continued to expand, now including a REPL, package manager, time-travelling debugger, and installers for macOS and Windows. Elm also has an ecosystem of community created libraries and Ellie, an advanced online editor that allows saved work and inclusion of community libraries. Elm has a small set of language constructs, including traditional if-expressions, let-expressions for local state, and case-expressions for pattern matching. As a functional language, it supports anonymous functions, functions as arguments, and functions can return functions, the latter often by partial application of curried functions. Functions are called by value. Its semantics include immutable values, stateless functions, and static typing with type inference. Elm programs render HTML through a virtual DOM, and may interoperate with other code by using "JavaScript as a service". All values in Elm are immutable, meaning that a value cannot be modified after it is created. Elm uses persistent data structures to implement its Arrays, Sets, and Dictionaries in the standard library.',
    Paradigm: "Functional",
    "Designed by": "Evan Czaplicki",
    "First appeared": "March 30, 2012; 9 years ago",
    "Stable release": "0.19.1 / October 21, 2019; 2 years ago",
    "Typing discipline": "Static, Strong, Inferred",
    License: "Permissive (Revised BSD)",
    "Filename extensions": ".elm",
    Website: "elm-lang.org ",
    other_details: {
      type: "programming",
      color: "#60B5CC",
      extensions: [".elm"],
      tm_scope: "source.elm",
      ace_mode: "elm",
      codemirror_mode: "elm",
      codemirror_mime_type: "text/x-elm",
      language_id: 101,
    },
    id: "BTqg",
  },
  {
    name: "Emacs Lisp",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/EmacsIcon.svg/220px-EmacsIcon.svg.png",
    description:
      "Users of Emacs commonly write Emacs Lisp code to customize and extend Emacs. Other options include the Customize feature that's been in GNU Emacs since version 20. Itself written in Emacs Lisp, Customize provides a set of preferences pages allowing the user to set options and preview their effect in the running Emacs session. When the user saves their changes, Customize simply writes the necessary Emacs Lisp code to the user's config file, which can be set to a special file that only Customize uses, to avoid the possibility of altering the user's own file. Emacs Lisp can also function as a scripting language, much like the Unix Bourne shell or Perl, by calling Emacs in batch mode. In this way it may be called from the command line or via an executable file, and its editing functions, such as buffers and movement commands are available to the program just as in the normal mode. No user interface is presented when Emacs is started in batch mode; it simply executes the passed-in script and exits, displaying any output from the script. Emacs Lisp is most closely related to Maclisp, with some later influence from Common Lisp. It supports imperative and functional programming methods. Richard Stallman chose Lisp as the extension language for his rewrite of Emacs (the original used Text Editor and Corrector (TECO) as its extension language) because of its powerful features, including the ability to treat functions as data. Although the Common Lisp standard had yet to be formulated, Scheme existed at the time Stallman was rewriting Gosling Emacs into GNU Emacs. He chose not to use it because of its comparatively poor performance on workstations (as opposed to the minicomputers that were Emacs' traditional home), and he wanted to develop a dialect which he thought would be more easily optimized. The Lisp dialect used in Emacs differs substantially from the more modern Common Lisp and Scheme dialects used for applications programming. A prominent characteristic of Emacs Lisp is in its use of dynamic rather than lexical scope by default. That is, a function may reference local variables in the scope it is called from, but not in the scope where it was defined. Recently, there has been an ongoing effort to update code to use lexical scoping, for reasons outlined below.",
    Paradigm: "Functional, meta, reflective",
    Family: "Lisp",
    "Designed by": "Richard Stallman, Guy L. Steele, Jr.",
    Developer: "GNU Project",
    "First appeared": "1985; 37 years ago",
    "Stable release": "27.2 / 25 March 2021; 9 months ago",
    "Typing discipline": "Dynamic, strong",
    Scope: "Dynamic, optionally lexical",
    Platform: "Emacs",
    OS: "Cross-platform",
    License: "GPLv3",
    "Filename extensions": ".el, .elc, .eln",
    Website: "www.gnu.org/software/emacs",
    other_details: {
      type: "programming",
      tm_scope: "source.emacs.lisp",
      color: "#c065db",
      aliases: ["elisp", "emacs"],
      filenames: [
        ".abbrev_defs",
        ".emacs",
        ".emacs.desktop",
        ".gnus",
        ".spacemacs",
        ".viper",
        "Cask",
        "Project.ede",
        "_emacs",
        "abbrev_defs",
      ],
      extensions: [".el", ".emacs", ".emacs.desktop"],
      ace_mode: "lisp",
      codemirror_mode: "commonlisp",
      codemirror_mime_type: "text/x-common-lisp",
      language_id: 102,
    },
    id: "6TJ3",
  },
  {
    name: "Epigram",
    description:
      "The Epigram prototype was implemented by Conor McBride based on joint work with James McKinna. Its development is continued by the Epigram group in Nottingham, Durham, St Andrews, and Royal Holloway, University of London in the United Kingdom (UK). The current experimental implementation of the Epigram system is freely available together with a user manual, a tutorial and some background material. The system has been used under Linux, Windows, and macOS. It is currently unmaintained, and version 2, which was intended to implement Observational Type Theory, was never officially released but exists in GitHub. Epigram uses a two-dimensional, natural deduction style syntax, with versions in LaTeX and ASCII. Here are some examples from The Epigram Tutorial: The following declaration defines the natural numbers:",
    Paradigm: "Functional",
    "Designed by": "Conor McBride James McKinna",
    Developer: "Unmaintained",
    "First appeared": "2004; 18 years ago",
    "Stable release": "1 / October 11, 2006; 15 years ago",
    "Typing discipline": "strong, static, dependent",
    OS: "Cross-platform: Linux, Windows, macOS",
    License: "MIT",
    Website:
      "web.archive.org/web/20120717070845/http://www.e-pig.org/darcs/Pig09/web/",
    id: "WHxC",
  },
  {
    name: "Easy Programming Language",
    description:
      "In addition, it is cross-platform, as it currently supports both Microsoft Windows and Linux. It is object-oriented and structured. Hello world program:   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    Paradigm:
      "Multi-paradigm: compiled, imperative, procedural, object-oriented, functional",
    "Designed by": "The Easy Programming Language Company",
    "First appeared": "2004",
    "Stable release": "5.81 / October 9, 2018; 3 years ago",
    "Preview release": "4.01",
    OS: "Cross-platform",
    License: "Proprietary software",
    "Filename extensions": ".e",
    Website: "epl.eyuyan.com",
    id: "WZnq",
  },
  {
    name: "ESPOL",
    description:
      'It was superseded by Zebra Programming Language (ZPL) after Zebra Technologies acquired Eltron. EPL2 is a markup, line-at-a-time language, suitable for printing on media of reduced space, and although it supports bitmaps (and therefore, arbitrary images), its use is usually for labels including barcode information. Each EPL2 line starts with one or more letters (indicating the command), and may be followed by one or more comma-separated arguments. Commands and arguments are case-sensitive. Arguments that are numeric or belong to a fixed set of options (see i.e. the reverse argument for A) are inlined, and any string or set of variable values must be surrounded by double-quotes (" - see i.e. the text argument for A).',
    id: "SD5A",
  },
  {
    name: "Erlang",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/04/Erlang_logo.svg/120px-Erlang_logo.svg.png",
    description:
      "Erlang (/ˈɜːrlæŋ/ UR-lang) is a general-purpose[citation needed], concurrent, functional programming language, and a garbage-collected runtime system. The term Erlang is used interchangeably with Erlang/OTP, or Open Telecom Platform (OTP), which consists of the Erlang runtime system, several ready-to-use components (OTP) mainly written in Erlang, and a set of design principles for Erlang programs. The Erlang runtime system is designed for systems with these traits: The Erlang programming language has immutable data, pattern matching, and functional programming. The sequential subset of the Erlang language supports eager evaluation, single assignment, and dynamic typing. A normal Erlang application is built out of hundreds of small Erlang processes.",
    Paradigms: "Multi-paradigm: concurrent, functional",
    "Designed by": "Joe Armstrong Robert Virding Mike Williams",
    Developer: "Ericsson",
    "First appeared": "1986; 36 years ago",
    "Stable release": "24.1.6  / 18 November 2021; 58 days ago",
    "Typing discipline": "Dynamic, strong",
    License: "Apache License 2.0",
    "Filename extensions": ".erl, .hrl",
    Website: "www.erlang.org",
    other_details: {
      type: "programming",
      color: "#B83998",
      extensions: [
        ".erl",
        ".app.src",
        ".es",
        ".escript",
        ".hrl",
        ".xrl",
        ".yrl",
      ],
      filenames: [
        "Emakefile",
        "rebar.config",
        "rebar.config.lock",
        "rebar.lock",
      ],
      ace_mode: "erlang",
      codemirror_mode: "erlang",
      codemirror_mime_type: "text/x-erlang",
      interpreters: ["escript"],
      language_id: 104,
    },
    id: "Z_dr",
  },
  {
    name: "rc",
    description:
      'A port of the original rc to Unix is part of Plan 9 from User Space. A rewrite of rc for Unix-like operating systems by Byron Rakitzis is also available but includes some incompatible changes. Rc uses C-like control structures instead of the original Bourne shell\'s ALGOL-like structures, except that it uses an if not construct instead of else, and has a Bourne-like for loop to iterate over lists. In rc, all variables are lists of strings, which eliminates the need for constructs like "$@". Variables are not re-split when expanded. The language is described in Duff\'s paper. es (for "extensible shell") is an open source, command line interpreter developed by Rakitzis and Paul Haahr that uses a scripting language syntax influenced by the rc shell. It was originally based on code from Byron Rakitzis\'s clone of rc for Unix. Extensible shell is intended to provide a fully functional programming language as a Unix shell. It does so by introducing "program fragments" in braces as a new datatype, lexical scoping via let, and some more minor improvements. The bulk of es development occurred in the early 1990s, after the shell was introduced at the Winter 1993 USENIX conference in San Diego, Official releases appear to have ceased after 0.9-beta-1 in 1997, and es lacks features as compared to more popular shells, such as zsh and bash. A public domain fork of es is active as of 2019.',
    Paradigm: "imperative, pipeline",
    "Designed by": "Tom Duff",
    Developer: "Bell Labs",
    "First appeared": "1989; 33 years ago",
    "Typing discipline": "weak",
    OS: "Cross-platform (Version 10 Unix, Plan 9, Plan 9 from User Space)",
    Website: "doc.cat-v.org/plan_9/4th_edition/papers/rc",
    id: "chhh",
  },
  {
    name: "Euphoria",
    description:
      "The development of the language started in the early 1980s, and was mainly carried out by a team of Ecole des Mines de Paris and INRIA led by Gérard Berry in France. Current compilers take Esterel programs and generate C code or hardware (RTL) implementations (VHDL or Verilog). The language is still under development, with several compilers out. The commercial version of Esterel is the development environment Esterel Studio. The company that commercialize it (Synfora) initiated a normalization process with the IEEE in April 2007 however the working group (P1778) dissolved March 2011. The Esterel v7 Reference Manual Version v7 30 – initial IEEE standardization proposal is publicly available. The notion of time used in Esterel differs from that of non-synchronous languages in the following way: The notion of physical time is replaced with the notion of order. Only the simultaneity and precedence of events are considered. This means that the physical time does not play any special role. This is called multiform notion of time. An Esterel program describes a totally ordered sequence of logical instants. At each instant, an arbitrary number of events occur (including 0). Event occurrences that happen at the same logical instant are considered simultaneous. Other events are ordered as their instances of occurrences. There are two types of statements: Those that take zero time (execute and terminate in the same instant) and those that delay for a prescribed number of cycles. Signals are the only means of communication. There are valued and non-valued signals. They are further categorized as being input, output, or local signals. A signal has the property of being either present or absent in an instant. Valued signals also contain a value. Signals are broadcast across the program, and that means any process can read or write a signal. The value of a valued signal can be determined in any instant, even if the signal is absent. The default status of a signal is absent. Signals remain absent until they are explicitly set to present using the emit statement. Communication is instantaneous, that means that a signal emitted in a cycle is visible immediately. Note that one can communicate back and forth in the same cycle.",
    id: "CQCc",
  },
  {
    name: "Etoys",
    description:
      "Etoys is a media-rich authoring environment with a scripted object model for many different objects that runs on different platforms and is free and open source. Etoys development was inspired and directed by Alan Kay and his work to advance and support constructionist learning. Primary influences include Seymour Papert and the Logo programming language, a dialect of Lisp optimized for educational use; work done at Xerox Palo Alto Research Center, PARC; Smalltalk, HyperCard, StarLogo and NetLogo. The drag and drop tile-based approach is very similar to AgentSheets. Scott Wallace is the main author. Promotion and development of the main Squeak version of Etoys is co-ordinated by the Viewpoints Research Institute, a U.S. educational non-profit. Etoys was a major influence on a similar Squeak-based programming environment known as Scratch. Scratch was designed with Etoys code in the early 21st century by the MIT Media Lab, initially targeted at after-school computer clubs. The Etoys system is based on the idea of programmable virtual entities behaving on the computer screen.",
    Paradigm: "object-oriented prototype-based, educational",
    "Designed by": "Alan Kay",
    Developer:
      "Scott Wallace, Ted Kaehler, John Maloney, Andreas Raab, Dan Ingalls",
    "First appeared": "1996",
    "Typing discipline": "dynamic",
    License: "MIT and Apache 2.0 licenses",
    id: "UVVl",
  },
  {
    name: "Euler",
    description:
      "Euler is a programming language created by Niklaus Wirth and Helmut Weber, conceived as an extension and generalization of ALGOL 60. The designers' goals were to create a language that is: Available sources indicate that Euler was operational by 1965. Euler employs a general data type concept. In Euler, arrays, procedures, and switches are not quantities which are declared and named by identifiers: in contrast to ALGOL, they are not quantities on the same level as variables. Rather, these quantities are on the level of numeric and boolean constants. Thus, besides the traditional numeric and logical constants, Euler introduces several added types: All constants can be assigned to variables, which have the same form as in ALGOL, but for which no fixed types are specified: Euler uses dynamic typing. Further, a procedure can produce a value of any type when executed, and this type can vary from one call of the procedure to the next.",
    Paradigms: "Multi-paradigm: procedural, imperative, structured",
    Family: "ALGOL Wirth",
    "Designed by": "Niklaus Wirth Helmut Weber",
    Developers: "Stanford University ETH Zurich",
    "First appeared": "1965; 57 years ago",
    "Typing discipline": "dynamic",
    Scope: "Lexical",
    id: "Ki4M",
  },
  {
    name: "Euphoria",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/c/c3/OpenEuphoria_logo.png",
    description:
      "Euphoria is a general-purpose high-level imperative-procedural interpreted language. A translator generates C source code and the GNU compiler collection (GCC) and Open Watcom compilers are supported. Alternatively, Euphoria programs may be bound with the interpreter to create stand-alone executables. A number of graphical user interface (GUI) libraries are supported including Win32lib and wrappers for wxWidgets, GTK+ and IUP. Euphoria has a simple built-in database and wrappers for a variety of other databases. The Euphoria language is a general purpose procedural language that focuses on simplicity, legibility, rapid development and performance via several means. Developed as a personal project to invent a programming language from scratch, Euphoria was created by Robert Craig on an Atari Mega-ST. Many design ideas for the language came from Craig's Master's thesis in computer science at the University of Toronto. Craig's thesis was heavily influenced by the work of John Backus on functional programming (FP) languages. Craig ported his original Atari implementation to the 16-bit DOS platform and Euphoria was first released, version 1.0, in July 1993 under a proprietary licence. The original Atari implementation is described by Craig as \"primitive\" and has not been publicly released. Euphoria continued to be developed and released by Craig via his company Rapid Deployment Software (RDS) and website rapideuphoria.com. In October 2006 RDS released version 3 of Euphoria and announced that henceforth Euphoria would be freely distributed under an open-source software licence.",
    Paradigm: "Imperative, procedural",
    "Designed by":
      "Jeremy Cowgar, Robert Craig (original), Matt Lewis, Derek Parnell",
    Developer: "openEuphoria Group",
    "First appeared": "1993; 29 years ago",
    "Stable release": "4.0.5 / October 19, 2012; 9 years ago",
    "Typing discipline": "static, dynamic",
    OS: "Cross-platform: Win32, Linux, macOS, FreeBSD, NetBSD, OpenBSD",
    License: "BSD",
    "Filename extensions": ".e, .ex, .exw, .edb",
    Website: "openeuphoria.org",
    id: "rAuv",
  },
  {
    name: "F*",
    description:
      'EXEC 2 is similar to CMS EXEC with the following enhancements: XEDIT Macros are files with filetype XEDIT, whose contents are written using the syntax of CMS EXEC, EXEC 2 or REXX. Like regular EXEC 2 "EXEC" command files, they begin with a "&TRACE" statement, to distinguish them from CMS EXEC files. Written in the 1970s, EXEC 2 was preceded by CMS EXEC and superseded by REXX. All three command interpreters—CMS EXEC, EXEC 2 and REXX — continue to be supported by the IBM CMS product.',
    other_details: {
      fs_name: "Fstar",
      type: "programming",
      color: "#572e30",
      aliases: ["fstar"],
      extensions: [".fst"],
      tm_scope: "source.fstar",
      ace_mode: "text",
      language_id: 336943375,
    },
    id: "lOi5",
  },
  {
    name: "Factor",
    description:
      'Executable UML models "can be run, tested, debugged, and measured for performance.", and can be compiled into a less abstract programming language to target a specific implementation. Executable UML supports model-driven architecture (MDA) through specification of platform-independent models, and the compilation of the platform-independent models into platform-specific models. Executable UML is a higher level of abstraction than third-generation programming languages. This allows developers to develop at the level of abstraction of the application. The Executable UML aims for separation of concerns. This is supposed to increase ease of reuse and to lower the cost of software development. This also enables Executable UML domains to be cross-platform. That means it is not tied to any specific programming language, platform or technology. Executable UML also allows for translation of platform-independent models (PIM) into platform-specific models (PSM). The Executable UML method enables valuing the model as intellectual property, since the model is a fully executable solution for the problem space. Actions are specified in action language. This means that the automatic generation of implementation code from Executable UML models can be output in an optimized form.',
    other_details: {
      type: "programming",
      color: "#636746",
      extensions: [".factor"],
      filenames: [".factor-boot-rc", ".factor-rc"],
      ace_mode: "text",
      codemirror_mode: "factor",
      codemirror_mime_type: "text/x-factor",
      language_id: 108,
    },
    id: "Kllm",
  },
  {
    name: "Ezhil",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/8/88/Ezhil_-_A_Tamil_Programming_Language_Logo.png",
    description:
      "In the Ezhil programming language, Tamil keywords and language-grammar are chosen to easily enable the native Tamil speaker write programs in the Ezhil system. Ezhil allows easy representation of computer program closer to the Tamil language logical constructs equivalent to the conditional, branch and loop statements in modern English based programming languages. Ezhil is the first freely available programming language in the Tamil language and one of many known non-English-based programming languages. The language was officially announced in July 2009, while it has been developed since late 2007. The syntax of Ezhil is broadly similar to that of BASIC: blocks of code are run in sequential order, or via functions definitions, in a common control flow structures include while, and if. The termination of function block and statement blocks should have the termination keyword, similar to END in BASIC. Declarations are not necessary as Ezhil is a dynamic typed language, though type conversions must be made explicitly. Ezhil has built-in types for Numbers, Strings, Logicals and Lists. Conditional Statements are modeled after the IF-ELSEIF-ELSE statement . Loop control statements deriving from the WHILE statements are chosen. The function declaration syntax is kept simple. Details include the print statement, and the flow control statements below. Ezhil has four basic types, for Numbers, Strings, Logicals and Lists. It does not allow creation of new types, being a procedural language without structures or objects.",
    Paradigm: "interpreted, imperative, structured",
    "Designed by": "Muthu Annamalai",
    Developer: "Independent/Freelance",
    "First appeared": "2007",
    "Stable release": "version 0.99 / 23 August 2017; 4 years ago",
    "Preview release": "version 10rc0 / 14 March 2021; 9 months ago",
    "Typing discipline": "strong, dynamic",
    OS: "Linux, Windows,Can be run in MacOS using Python's pip (package manager)",
    License: "GPLv3",
    "Filename extensions": ".n",
    Website: "ezhillang.org",
    id: "vdmE",
  },
  {
    name: "F language",
    description:
      "F is designed to be a minimal subset of Fortran, with only about one hundred intrinsic procedures. Language keywords and intrinsic function names are reserved keywords in F and no other names may take this exact form. F contains the same character set used in Fortran 90/95 with a limit of 132 characters. Reserved words are always written in lowercase. Any uppercase letter may appear in a character constant. Variable names do not have restriction and can include upper and lowercase characters. F supports many of the standard operators used in Fortran. The operators supported by F are: The assignment operator is denoted by the equal sign =. In addition, pointer assignment is denoted by =>. Comments are denoted by the ! symbol: Similar to Fortran, the type specification is made up of a type, a list of attributes for the declared variables, and the variable list. F provides all the same types as Fortran as well, with the sole exception of doubles:",
    Paradigm: "procedural, modular",
    Developer: "The Fortran Company",
    "Typing discipline": "static, manifest",
    id: "-2Y6",
  },
  {
    name: "F#",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/F_Sharp_logo.svg/128px-F_Sharp_logo.svg.png",
    description:
      "F# is developed by the F# Software Foundation, Microsoft and open contributors. An open source, cross-platform compiler for F# is available from the F# Software Foundation. F# is a fully supported language in Visual Studio and JetBrains Rider. Plug-ins supporting F# exist for many widely used editors, most notably the Ionide extension for Visual Studio Code, and integrations for other editors such as Vim, and Emacs. F# is a member of the ML language family and originated as a .NET Framework implementation of a core of the programming language OCaml. It has also been influenced by C#, Python, Haskell, Scala, and Erlang. In the course of its development, the language has gone through several versions: JavaScript, GPU",
    Paradigm:
      "Multi-paradigm: functional, imperative, object-oriented, metaprogramming, reflective, concurrent",
    Family: "ML",
    "Designed by": "Don Syme, Microsoft Research",
    Developer: "Microsoft, The F# Software Foundation",
    "First appeared": "2005; 17 years ago, version 1.0",
    "Stable release": "6.0  / 19 October 2021; 2 months ago",
    "Preview release": "5.0 preview / April 2, 2019; 2 years ago",
    "Typing discipline": "Static, strong, inferred",
    OS: "Cross-platform: .NET, .NET Framework, Mono",
    License: "MIT License",
    "Filename extensions": ".fs, .fsi, .fsx, .fsscript",
    Website: "fsharp.org",
    other_details: {
      type: "programming",
      color: "#b845fc",
      aliases: ["fsharp"],
      extensions: [".fs", ".fsi", ".fsx"],
      tm_scope: "source.fsharp",
      ace_mode: "text",
      codemirror_mode: "mllike",
      codemirror_mime_type: "text/x-fsharp",
      language_id: 105,
    },
    id: "VmSl",
  },
  {
    name: "Factor",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/200px-NewFactorLogo.png",
    description:
      "Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFactor, was implemented in Java and ran on the Java Virtual Machine. Though the early language resembled modern Factor superficially in terms of syntax, the modern language is very different in practical terms and the current implementation is much faster. The language has changed significantly over time. Originally, Factor programs centered on manipulating Java objects with Java's reflection capabilities. From the beginning, the design philosophy has been to modify the language to suit programs written in it. As the Factor implementation and standard libraries grew more detailed, the need for certain language features became clear, and they were added. JFactor did not have an object system where you could define your own classes, and early versions of native Factor were the same; the language was similar to Scheme in this way. Today, the object system is a central part of Factor. Other important language features such as tuple classes, combinator inlining, macros, user-defined parsing words and the modern vocabulary system were only added in a piecemeal fashion as their utility became clear. The foreign function interface was present from very early versions to Factor, and an analogous system existed in JFactor. This was chosen over creating a plugin to the C part of the implementation for each external library that Factor should communicate with, and has the benefit of being more declarative, faster to compile and easier to write. The Java implementation initially consisted of just an interpreter, but a compiler to Java bytecode was later added. This compiler only worked on certain procedures. The Java version of Factor was replaced by a version written in C and Factor. Initially, this consisted of just an interpreter, but the interpreter was replaced by two compilers, used in different situations. Over time, the Factor implementation has grown significantly faster.",
    Paradigm: "multi-paradigm: functional, concatenative, stack-oriented",
    Developer: "Slava Pestov",
    "First appeared": "2003",
    "Stable release": "0.98 / July 31, 2018",
    "Typing discipline": "strong, dynamic",
    OS: "Windows, macOS, Linux",
    License: "BSD license",
    Website: "factorcode.org",
    other_details: {
      type: "programming",
      color: "#636746",
      extensions: [".factor"],
      filenames: [".factor-boot-rc", ".factor-rc"],
      ace_mode: "text",
      codemirror_mode: "factor",
      codemirror_mime_type: "text/x-factor",
      language_id: 108,
    },
    id: "rkDJ",
  },
  {
    name: "Fantom",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/8/8c/Fantom-logo.png",
    description:
      "Fantom's type system is simple by design. All variables are statically typed, as they are in C# and Java. Fantom rejects generic types due to their complexity, but it does have a set of built-in generic types: List, Map, and Func. Fantom can also take on the feel of a dynamically typed language through dynamic calls and automatic downcasting. Fantom has an easy to use reflection API and metaprogramming capabilities. Fantom is open source under the Academic Free License 3.0 and is available for Windows and Unix-like platforms (including Mac OS X). In Fantom, the unit of deployment is called a pod. Pods take on the role of namespaces, packages, and modules. They are stored as .pod files, which are zip files containing the FCode (the Fantom bytecode), the documentation, and resource files necessary to run the pod. A pod can define any number of types for use in other libraries and applications. A pod name fully qualifies a type name. For example, fwt::Widget is distinct from webapp::Widget. If a pod contains a type named Main, then it can be executed on the command line with: fan <podName> The Fantom build system can package a set of Pods into a JAR archive through build::JarDist.",
    Paradigm: "multi-paradigm",
    Developer: "Brian Frank, Andy Frank",
    "First appeared": "2005",
    "Stable release": "1.0.75 / August 24, 2020; 16 months ago",
    "Typing discipline": "static, dynamic",
    License: "Academic Free License version 3.0",
    "Filename extensions": ".fan, .fwt, .pod",
    Website: "www.fantom.org",
    other_details: {
      type: "programming",
      color: "#14253c",
      extensions: [".fan"],
      tm_scope: "source.fan",
      ace_mode: "text",
      language_id: 110,
    },
    id: "OjIv",
  },
  {
    name: "FAUST",
    description:
      "The FAUST programming model combines a functional programming approach with a block diagram syntax: A FAUST program doesn’t describe a sound or a group of sounds, but a signal processor. The program source is organized as a set of definitions with at least the definition of the keyword process (the equivalent of main in C): The FAUST compiler translates FAUST code into a C++ object, which may then interface with other C++ code to produce a full program. The generated code works at the sample level. It is therefore suited to implement low-level DSP functions like recursive filters. The code may also be embedded. It is self-contained and does not depend on any DSP library or runtime system. It has a very deterministic behavior and a constant memory size.",
    "Original author(s)": "Yann Orlarey, Dominique Fober, Stéphane Letz",
    "Developer(s)": "GRAME, Centre National de Création Musicale",
    "Initial release": "2002",
    "Stable release": "2.37.3 / October 30, 3021",
    "Written in": "C++",
    "Operating system": "Linux, OS X, Windows, Unix",
    Type: "Functional programming language for audio signal processing",
    License: "GPL",
    Website: "faust.grame.fr",
    id: "O_QF",
  },
  {
    name: "FP",
    description:
      'The FP language was introduced in Backus\'s 1977 Turing Award paper, "Can Programming Be Liberated from the von Neumann Style?", subtitled "a functional style and its algebra of programs." The paper sparked interest in functional programming research, eventually leading to modern functional languages (which are largely founded on the lambda calculus paradigm), and not the function-level paradigm Backus had hoped. In his Turing award paper, Backus described how the FP style is different: An FP system is based on the use of a fixed set of combining forms called functional forms. These, plus simple definitions, are the only means of building new functions from existing ones; they use no variables or substitutions rules, and they become the operations of an associated algebra of programs. All the functions of an FP system are of one type: they map objects onto objects and always take a single argument. FP itself never found much use outside of academia. In the 1980s Backus created a successor language, FL, which was an internal project at IBM Research. The values that FP programs map into one another comprise a set which is closed under sequence formation:',
    Paradigm: "Function-level",
    "Designed by": "John Backus",
    "First appeared": "1977",
    id: "hSB8",
  },
  {
    name: "fish",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Fish_shell_logo_ascii.png/92px-Fish_shell_logo_ascii.png",
    description:
      "Fish has \"search as you type\" automatic suggestions based on history and current directory. This is essentially like Bash's Ctrl+R history search, but because it is always on instead of being a separate mode, the user gets continuous feedback while writing the command line, and can select suggestions with the arrow keys, or as in Bash, press Tab ↹ for a tab completion instead. Tab-completion is feature-rich, expanding file paths (with wildcards and brace expansion), variables, and many command specific completions. Command-specific completions, including options with descriptions, can to some extent be generated from the commands' manpages. Fish has few syntactic rules, preferring features as commands rather than syntax. This makes features discoverable in terms of commands with options and help texts. Functions can also carry a human readable description. A special help command gives access to all the fish documentation in the user's web browser. The syntax resembles a POSIX compatible shell (such as Bash), but deviates in important ways where the creators believe the POSIX shell was badly designed. Some language constructs, like pipelines, functions and loops, have been implemented using so called subshells in other shell languages. Subshells are simply child programs that run a few commands for the shell and then exit. Unfortunately, this implementation detail typically has the side effect that any state changes made in the subshell, such as variable assignments, do not propagate to the main shell, which may surprise the user. Fish never forks off so-called subshells; all builtins are always fully functional.",
    "Original author(s)": "Axel Liljencrantz",
    "Developer(s)": "Fish-shell developers",
    "Initial release": "13 February 2005; 16 years ago",
    "Stable release": "3.3.1  / 6 July 2021; 6 months ago",
    Repository: "github.com/fish-shell/fish-shell ",
    "Operating system": "Unix-like",
    Type: "Unix shell",
    License: "GPL-2.0-only",
    Website: "fishshell.com",
    other_details: {
      type: "programming",
      group: "Shell",
      interpreters: ["fish"],
      extensions: [".fish"],
      tm_scope: "source.fish",
      ace_mode: "text",
      language_id: 415,
    },
    id: "39Vh",
  },
  {
    name: "FLOW-MATIC (B0)",
    description:
      "The first FlagShip version was introduced by multisoft Datentechnik GmbH in 1992 to port Clipper, dBASE III+, FoxBase and FoxPro applications to different operating systems, i.e. OpenServer, AIX, Solaris, HP-UX, SINIX and many other Unix systems. In 1995 also Linux ports became available. In 2002, Visual FlagShip (abbreviated as VFS) was announced for Linux, and in 2004 additionally for 32/64-bit based Windows operating systems. The current VFS product line covers all common 32-bit and 64-bit operating systems (Windows NT, 2000, XP, Vista, 7, Server 2008). FlagShip is a programming and development tool designed mainly for professional software developers. Visual FlagShip makes a GUI-based application from textual xBase codem which can then be modified using object-oriented programming or procedural programming. The same source and the same application supports GUI, textual and stream mode (e.g. for Web or background). The i/o mode is either detected automatically from the current environment (heterogenal application), or can be specified at compile time or at run-time using command-line switch. For example, these few statements, stored in text file address.prg",
    id: "vqml",
  },
  {
    name: "FOCAL (Formulating On-Line Calculations in Algebraic Language/FOrmula CALculator)",
    description:
      "Flavors, an early object-oriented extension to Lisp developed by Howard Cannon at the MIT Artificial Intelligence Laboratory for the Lisp machine and its programming language Lisp Machine Lisp, was the first programming language to include mixins. Symbolics used it for its Lisp machines, and eventually developed it into New Flavors; both the original and new Flavors were message passing OO models. It was hugely influential in the development of the Common Lisp Object System (CLOS). Implementations of Flavors are also available for Common Lisp. New Flavors replaced message sending with calling generic functions. Flavors offers :before and :after daemons with the default method combination (called :daemon).",
    id: "_T9F",
  },
  {
    name: "Flix",
    description:
      "The Flix type and effect system supports Hindley-Milner-style type inference. The system separates pure and impure code: if an expression is typed as pure then it cannot produce an effect at run-time. Higher-order functions can enforce that they are given pure (or impure) function arguments. The type and effect system supports effect polymorphism which means that the effect of a higher-order function may depend on the effect(s) of its argument(s). Flix supports Datalog programs as first-class values. A Datalog program value, i.e. a collection of Datalog facts and rules, can be passed to and returned from functions, stored in data structures, and composed with other Datalog program values. The minimal model of a Datalog program value can be computed and is itself a Datalog program value. In this way, Flix can be viewed as a meta programming language for Datalog. Flix supports stratified negation and the Flix compiler ensures stratification at compile-time. Flix also supports an enriched form of Datalog constraints where predicates are given lattice semantics. Flix is a programming language in the ML-family of languages. Its type and effect system is based on Hindley-Milner with several extensions, including row polymorphism and Boolean unification. The syntax of Flix is inspired by Scala and uses short keywords and curly braces. Flix supports uniform function call syntax which allows a function call f(x, y, z) to be written as x.f(y, z). The concurrency model of Flix is inspired by Go and based on channels and processes. A process is a light-weight thread that does not share (mutable) memory with another process. Processes communicate over channels which are bounded or unbounded queues of immutable messages. While many programming languages support a mixture of functional and imperative programming, the Flix type and effect system tracks the purity of every expression making it possible to write parts of a Flix program in a purely functional style with purity enforced by the effect system.",
    Paradigm: "Multi-paradigm: functional, imperative, logic",
    Developer: "Aarhus University, open-source contributors",
    "Typing discipline": "inferred, static, strong, structural",
    Platform: "JVM",
    License: "Apache License 2.0.",
    "Filename extensions": ".flix",
    Website: "flix.dev",
    id: "WLUN",
  },
  {
    name: "FORMAC (FORMula MAnipulation Compiler)",
    description:
      "FlooP is identical to BlooP except that it supports unbounded loops; it is a Turing-complete language and can express all computable functions. For example, it can express the Ackermann function, which (not being primitive recursive) cannot be written in BlooP. Borrowing from standard terminology in mathematical logic, Hofstadter calls FlooP's unbounded loops MU-loops. Like all Turing-complete programming languages, FlooP suffers from the halting problem: programs might not terminate, and it is not possible, in general, to decide which programs do. BlooP and FlooP can be regarded as models of computation, and have sometimes been used in teaching computability. The only variables are OUTPUT (the return value of the procedure) and CELL(i) (an unbounded sequence of natural-number variables, indexed by constants, as in the Unlimited Register Machine). The only operators are ⇐ (assignment), + (addition), × (multiplication), < (less-than), > (greater-than) and = (equals). Each program uses only a finite number of cells, but the numbers in the cells can be arbitrarily large. Data structures such as lists or stacks can be handled by interpreting the number in a cell in specific ways, that is, by Gödel numbering the possible structures.",
    id: "8-IV",
  },
  {
    name: "FLOW-MATIC",
    description:
      "Hopper had found that business data processing customers were uncomfortable with mathematical notation: I used to be a mathematics professor. At that time I found there were a certain number of students who could not learn mathematics. I then was charged with ¨the job of making it easy for businessmen to use our computers. I found it was not a question of whether they could learn mathematics or not, but whether they would. […] They said, ‘Throw those symbols out — I do not know what they mean, I have not time to learn symbols.’ I suggest a reply to those who would like data processing people to use mathematical symbols that they make the first attempt to teach those symbols to vice-presidents or a colonel or admiral. I assure you that I tried it.¨ In late 1953, she proposed that data processing problems should be expressed using English keywords, but Rand management considered the idea infeasible. In early 1955, she and her team wrote a specification for such a programming language and implemented a prototype. The FLOW-MATIC compiler became publicly available in early 1958 and was substantially complete in 1959. FLOW-MATIC was the first programming language to express operations using English-like statements. It was also the first system to distinctly separate the description of data from the operations on it. Its data definition language, unlike its executable statements, was not English-like; rather, data structures were defined by filling in pre-printed forms.",
    Paradigm: "imperative",
    "Designed by": "Remington Rand, Grace Hopper",
    "First appeared": "1955",
    Platform: "UNIVAC I",
    id: "myCf",
  },
  {
    name: "FOCAL",
    description:
      "FOCAL is very similar to JOSS in the commands it supports and the general syntax of the language. It differs in that many of JOSS' advanced features like ranges and user-defined functions were removed to simplify the parser. Some of the reserved words (keywords) were renamed so that they all start with a unique first letter. This allows users to type in programs using one-character statements, further reducing memory needs. This was an important consideration on the PDP-8, which was often limited to a few kilobytes (KB). Like JOSS, and later BASICs, FOCAL on the PDP-8 was a complete environment that included a line editor, an interpreter, and input/output routines. The package as a whole was named FOCAL-8, which also ran on the PDP-5 and PDP-12. When ported to the PDP-11, the resulting FOCAL-11 relied on the underlying operating system, RT-11, to provide file support and editing. The language definition was updated twice, to FOCAL-69 and a very slightly modified FOCAL-71. A port to the Intel 8080 was also available. FOCAL is notable as the language in which the original versions of the early video games Hamurabi and Lunar Lander were written. Both were later ported to BASIC, where they became much better known. FOCAL was not popular outside the PDP platform and largely disappeared during the move to the VAX-11. It had a strong revival in the Soviet Union where PDP-11 clones were used as educational and home computers. JOSS was released in May 1963 on the one-off JOHNNIAC computer at RAND Corporation. In RAND, use grew rapidly, and the machine, originally built in 1953, quickly ran out of capability. JOHNNIAC was decommissioned in 1966 and JOSS was reimplemented on a newly purchased PDP-6, Digital Equipment Corporation's (DEC) first \"big\" machine. Use continued to grow and by 1970, the system was being used by 500 to 600 users across the country and had spawned several innovations such as mobile computer terminals that could be wheeled from room to room and plugged in for quick access.",
    Paradigm: "imperative",
    Family: "JOSS",
    "Designed by": "Richard Merrill",
    Developer: "DEC",
    "First appeared": "1968; 54 years ago",
    id: "PE72",
  },
  {
    name: "Fortran – ISO/IEC 1539",
    description:
      "Information Builders's FOCUS product began as an alternate product to Mathematica's RAMIS, the first Fourth-generation programming language (4GL). National CSS (NCSS), a Time-sharing vendor, licensed rights to make RAMIS available on its VP/CSS system. At some point Mathematica changed its licensing price. The interested parties were:",
    id: "x977",
  },
  {
    name: "Fortress",
    description:
      "The first FOIL was a CAI language developed at the University of Michigan in 1967. The acronym stood for File-Oriented Interpretive Language and it was very similar to other CAI languages like COURSEWRITER and PILOT. However, it tried to make the language somewhat block-structured using whitespace which ended up making the language vaguely similar to BASIC or ABC. The second FOIL was a music generation language for the Touché computer instrument in 1979. The Touché was a keyboard that had digital tone generation and allowed you to program software for performances. The acronym stood for Far Out Instrument Language and was succeeded by MetaFOIL and FOIL-83. The language was developed by David Rosenboom and was based on Forth.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    id: "JaBg",
  },
  {
    name: "FoxBase/FoxPro",
    description:
      "It was created by Ray Ozzie during the early development of Lotus Notes. He borrowed the compiler and decompiler from the Lotus 1-2-3 spreadsheet, but unlike the spreadsheet language Formula Language was designed primarily for string and list processing, not numerical processing. It was originally a Functional programming language with unique text list-handling features inspired by Ray Ozzie's prior use of Icon and Lisp. The Formula language engine was rewritten by Damien Katz for Notes and Domino 6. New features were added to the language, such as looping and dynamic execution, and performance was improved. The Formula language has two parts: @Functions can be used in several places throughout Lotus Notes. The most important uses are:",
    id: "gECz",
  },
  {
    name: "Forth",
    description:
      "Forth is a procedural, stack-oriented programming language and interactive environment designed by Charles H. \"Chuck\" Moore and first used by other programmers in 1970. Although not an acronym, the language's name in its early years was often spelled in all capital letters as FORTH, but Forth is more common. Forth combines a compiler with an integrated command shell, where the user interacts via subroutines called words. Words can be defined, tested, redefined, and debugged without recompiling or restarting the whole program. All syntactic elements, including variables and basic operators, are defined as words. A stack is used to pass parameters between words, leading to a Reverse Polish Notation style. For much of Forth's existence, the standard technique was to compile to threaded code, which can be interpreted faster than bytecode. One of the early benefits of Forth was size: an entire development environment—including compiler, editor, and user programs—could fit in memory on an 8-bit or similarly limited system. No longer constrained by space, there are modern implementations that generate optimized machine code like other language compilers. Forth is used in the Open Firmware boot loader, in space applications such as the Philae spacecraft, and in other embedded systems which involve interaction with hardware. The relative simplicity of creating a basic Forth system has led to many personal and proprietary variants, such as the custom Forth used to implement the bestselling 1986 video game Starflight from Electronic Arts. The free software Gforth implementation is actively maintained, as are several commercially supported systems.",
    Paradigm: "Procedural, stack-oriented, reflective, concatenative",
    "Designed by": "Charles H. Moore",
    "First appeared": "1970; 52 years ago",
    "Typing discipline": "Typeless",
    "Filename extensions": ".fs, .fth, .forth",
    other_details: {
      type: "programming",
      color: "#341708",
      extensions: [
        ".fth",
        ".4th",
        ".f",
        ".for",
        ".forth",
        ".fr",
        ".frt",
        ".fs",
      ],
      ace_mode: "forth",
      codemirror_mode: "forth",
      codemirror_mime_type: "text/x-forth",
      language_id: 114,
    },
    id: "0BY6",
  },
  {
    name: "Fortran",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Fortran_logo.svg/120px-Fortran_logo.svg.png",
    description:
      "Fortran (/ˈfɔːrtræn/; formerly FORTRAN) is a general-purpose, compiled imperative programming language that is especially suited to numeric computation and scientific computing. Fortran was originally developed by IBM in the 1950s for scientific and engineering applications, and subsequently came to dominate scientific computing. It has been in use for over six decades in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, geophysics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing and is used for programs that benchmark and rank the world's fastest supercomputers. Fortran has had numerous versions, each of which has added extensions while largely retaining compatibility with preceding versions. Successive versions have added support for structured programming and processing of character-based data (FORTRAN 77), array programming, modular programming and generic programming (Fortran 90), high performance Fortran (Fortran 95), object-oriented programming (Fortran 2003), concurrent programming (Fortran 2008), and native parallel computing capabilities (Coarray Fortran 2008/2018). Fortran's design was the basis for many other programming languages. Among the better-known is BASIC, which is based on FORTRAN II with a number of syntax cleanups, notably better logical structures, and other changes to work more easily in an interactive environment.",
    Paradigm:
      "Multi-paradigm: structured, imperative (procedural, object-oriented), generic, array",
    "Designed by": "John Backus",
    Developer: "John Backus and IBM",
    "First appeared": "1957; 65 years ago",
    "Stable release":
      "Fortran 2018 (ISO/IEC 1539-1:2018) / 28 November 2018; 3 years ago",
    "Typing discipline": "strong, static, manifest",
    "Filename extensions": ".f, .for, .f90",
    Website: "fortran-lang.org",
    other_details: {
      type: "programming",
      color: "#4d41b1",
      extensions: [
        ".f90",
        ".f",
        ".f03",
        ".f08",
        ".f77",
        ".f95",
        ".for",
        ".fpp",
      ],
      tm_scope: "source.fortran.modern",
      ace_mode: "text",
      codemirror_mode: "fortran",
      codemirror_mime_type: "text/x-fortran",
      language_id: 107,
    },
    id: "Z3QG",
  },
  {
    name: "Fortress",
    description:
      'The name "Fortress" was intended to connote a secure Fortran, i.e., "a language for high-performance computation that provides abstraction and type safety on par with modern programming language principles". Language features included implicit parallelism, Unicode support and concrete syntax similar to mathematical notation. The language was not designed to be similar to Fortran. Syntactically, it most resembles Scala, Standard ML, and Haskell. Fortress was designed from the outset to have multiple syntactic stylesheets. Source code can be rendered as ASCII text, in Unicode, or as a prettied image. This would allow for support of mathematical symbols and other symbols in the rendered output for easier reading. An emacs-based tool called fortify transforms ASCII-based Fortress source code into LaTeX output. Fortress was also designed to be both highly parallel and have rich functionality contained within libraries, drawing from Java. For example, the for loop construct was a parallel operation, which would not necessarily iterate in a strictly linear manner, depending on the underlying implementation. However, the for construct was a library function and could be replaced by another version of the programmer\'s liking rather than being built into the language. Fortress\' designers made its syntax as close as possible to pseudocode and analyzed hundreds of computer science and mathematics papers, courses, books and journals using pseudocode to extract the common usage patterns of the English language and standard mathematical notation when used to represent algorithms in pseudocode. Then they made the compiler trying to maintain a one-to-one correspondence between pseudocode and executable Fortress.[better source needed] Fortress was one of three languages created with funding from the High Productivity Computing Systems project; the others were X10 from IBM and Chapel from Cray, Inc. In November 2006, when DARPA approved funding for the third phase of the HPCS project, X10 and Chapel were funded, but Fortress was not, leading to uncertainty about the future of Fortress.',
    Developer: "Sun Labs",
    "First appeared": "2006",
    "Final release": "1.0_5033 / September 7, 2011; 10 years ago",
    "Typing discipline": "Static",
    Platform: "Java SE 1.6+",
    OS: "Cross-platform",
    License: "BSD",
    Website: "github.com/stokito/fortress-lang",
    id: "iDAH",
  },
  {
    name: "FP",
    description:
      'The FP language was introduced in Backus\'s 1977 Turing Award paper, "Can Programming Be Liberated from the von Neumann Style?", subtitled "a functional style and its algebra of programs." The paper sparked interest in functional programming research, eventually leading to modern functional languages (which are largely founded on the lambda calculus paradigm), and not the function-level paradigm Backus had hoped. In his Turing award paper, Backus described how the FP style is different: An FP system is based on the use of a fixed set of combining forms called functional forms. These, plus simple definitions, are the only means of building new functions from existing ones; they use no variables or substitutions rules, and they become the operations of an associated algebra of programs. All the functions of an FP system are of one type: they map objects onto objects and always take a single argument. FP itself never found much use outside of academia. In the 1980s Backus created a successor language, FL, which was an internal project at IBM Research. The values that FP programs map into one another comprise a set which is closed under sequence formation:',
    Paradigm: "Function-level",
    "Designed by": "John Backus",
    "First appeared": "1977",
    id: "ZDVI",
  },
  {
    name: "GAMS (General Algebraic Modeling System)",
    description:
      "FoxPro was a text-based procedurally oriented programming language and database management system (DBMS), and it was also an object-oriented programming language, originally published by Fox Software and later by Microsoft, for MS-DOS, Windows, Macintosh, and UNIX. The final published release of FoxPro was 2.6. Development continued under the Visual FoxPro label, which in turn was discontinued in 2007. FoxPro was derived from FoxBase (Fox Software, Perrysburg, Ohio), which was in turn derived from dBase III (Ashton-Tate) and dBase II. dBase II was the first commercial version of a database program written by Wayne Ratliff, called Vulcan, running on CP/M, as does dBase II. FoxPro was both a DBMS and a relational database management system (RDBMS), since it extensively supported multiple relationships between multiple DBF files (tables). However, it lacked transactional processing. FoxPro was sold and supported by Microsoft after they acquired Fox Software in its entirety in 1992. At that time there was an active worldwide community of FoxPro users and programmers. FoxPro 2.6 for UNIX (FPU26) has even been successfully installed on Linux and FreeBSD using the Intel Binary Compatibility Standard (ibcs2) support library.",
    id: "OfsO",
  },
  {
    name: "Franz Lisp",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/4.3_BSD_UWisc_VAX_Emulation_Lisp_Manual.png/300px-4.3_BSD_UWisc_VAX_Emulation_Lisp_Manual.png",
    description:
      "The name is a pun on the composer and pianist Franz Liszt. It was written specifically to be a host for running the Macsyma computer algebra system on VAX. The project began at the end of 1978, soon after UC Berkeley took delivery of their first VAX 11/780 (named Ernie CoVax, after Ernie Kovacs, the first of many systems with pun names at UCB). Franz Lisp was available free of charge to educational sites, and was also distributed on Eunice, a Berkeley Unix emulator that ran on VAX VMS. At the time of Franz Lisp's creation, the Macsyma computer algebra system ran mainly on a DEC PDP-10. This computer's limited address space caused difficulties. Attempted remedies included ports of Maclisp to Multics or Lisp machines, but even if successful, these would only be solutions for the Massachusetts Institute of Technology (MIT) as these machines were costly and uncommon. Franz Lisp was the first example of a framework where large Lisp programs could be run outside the Lisp machines environment; Macsyma was then considered a very large program. After being ported to Franz Lisp, Macsyma was distributed to about 50 sites under a license restricted by MIT's interest in making Macsyma proprietary. The VAX Macsyma that ran on Franz Lisp was called Vaxima. When Symbolics Inc., bought the commercial rights to Macsyma from MIT to sell along with its Lisp machines, it eventually was compelled to sell Macsyma also on DEC VAX and Sun Microsystems computers, paying royalties to the University of California for the use of Franz Lisp. Other Lisp implementations for the VAX were MIT's NIL (never fully functional), University of Utah's Portable Standard Lisp, DEC's VAX Lisp, Xerox's Interlisp-VAX, and Le Lisp.",
    Paradigms: "Multi-paradigm: functional, procedural, reflective, meta",
    Family: "Lisp",
    "Designed by": "Richard Fateman, John Foderaro, Kevin Layer, Keith Sklower",
    Developer: "University of California, Berkeley",
    "First appeared": "1980; 42 years ago",
    "Final release": "Final / 1988; 34 years ago",
    "Typing discipline": "Dynamic, strong",
    Scope: "Static, lexical",
    "Implementation language": "C, Franz Lisp",
    Platform: "VAX, 68000",
    OS: "VMS, Unix, Unix-like, Eunice, SunOS",
    License: "Proprietary, freeware",
    id: "Eiuk",
  },
  {
    name: "F-Script",
    description:
      "F-Script is based on a pure object paradigm: every entity manipulated within the language is an object. Its base syntax and concepts are identical to those of the language Smalltalk (the canonical example of an object-oriented language) with specific extensions to support array programming as in the language APL. F-Script provides an interpreted, interactive environment with support for workspaces, which provide a rich set of functions including object persistence, distributed objects, graphical user interface (GUI) framework, database access, among other things. Like Smalltalk, F-Script's syntax is very simple, without requiring specific notation for control structures which are provided in a unified manner by the message send operation. Unlike Smalltalk, F-Script provides specific notational extensions to support the Array class, using curly brackets to describe literal arrays, which may contain any F-Script expressions. For example, {1+3, 'name', true} is a valid array literal. The empty array is denoted by {}. Arrays of arrays are supported transparently, since any array is just another object.",
    Paradigm: "multi-paradigm: object-oriented, array",
    "Designed by": "Philippe Mougin",
    Developer: "Jonathan Mitchell, Ilya Kulakov, others",
    "First appeared": "June 28, 2009; 12 years ago",
    "Stable release": "2.2.1 / February 5, 2014; 7 years ago",
    "Typing discipline": "dynamic",
    Platform: "x86",
    OS: "macOS",
    License: "Open-source",
    Website: "github.com/pmougin/F-Script",
    id: "SA8w",
  },
  {
    name: "GameMaker",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/7/7a/GameMaker_Studio_2.svg/220px-GameMaker_Studio_2.svg.png",
    description:
      "GameMaker (originally Animo and later Game Maker until 2011) is a series of cross-platform game engines created by Mark Overmars in 1999 and developed by YoYo Games since 2007. The latest iteration is GameMaker Studio 2, released in 2017. GameMaker accommodates the creation of cross-platform and multi-genre video games using a custom drag-and-drop visual programming language or a scripting language known as Game Maker Language, which can be used to develop more advanced games that could not be created just by using the drag and drop features. GameMaker was originally designed to allow novice computer programmers to be able to make computer games without much programming knowledge by use of these actions. Recent versions of software also focus on appealing to advanced developers. GameMaker is primarily intended for making games with 2D graphics, allowing out-of-box use of raster graphics, vector graphics (via SWF), and 2D skeletal animations (via Esoteric Software's Spine) along with a large standard library for drawing graphics and 2D primitives. While the software allows for limited use of 3D graphics, this is in form of vertex buffer and matrix functions, and as such not intended for novice users. The engine uses Direct3D on Windows, UWP, and Xbox One; OpenGL on macOS and Linux; OpenGL ES on Android and iOS, WebGL or 2d canvas on HTML5, and proprietary APIs on consoles.",
    "Original author(s)": "Mark Overmars",
    "Developer(s)": "YoYo Games",
    "Initial release": "15 November 1999; 22 years ago",
    "Stable release": "v2.3.7 / 25 November 2021; 52 days ago",
    "Written in": "C++ (runtime)C# (IDE)",
    "Operating system": "Microsoft WindowsmacOS",
    Platform:
      "Microsoft WindowsmacOSUbuntuHTML5AndroidiOSAmazon Fire TVAndroid TVUniversal Windows PlatformPlayStation 4Xbox One",
    "Available in": "EnglishFrenchSpanishGerman",
    License: "Proprietary",
    Website: "yoyogames.com/gamemaker",
    id: "xEKo",
  },
  {
    name: "GDL (Geometric Description Language)",
    description:
      "A scripting language's primitives are usually elementary tasks or API calls[clarification needed], and the scripting language allows them to be combined into more programs. Environments that can be automated through scripting include application software, text editors, web pages, operating system shells, embedded systems, and computer games. A scripting language can be viewed as a domain-specific language for a particular environment; in the case of scripting an application, it is also known as an extension language. Scripting languages are also sometimes referred to as very high-level programming languages, as they sometimes operate at a high level of abstraction, or as control languages, particularly for job control languages on mainframes. The term scripting language is also used in a wider sense, namely, to refer to dynamic high-level programming languages in general; some are strictly interpreted languages, while others use a form of compilation. In this context, the term script refers to a small program in such a language; typically, contained in a single file, and no larger than a few thousand lines of code. The spectrum of scripting languages ranges from small to large, and from highly domain-specific language to general-purpose programming languages. A language may start as small and highly domain-specific and later develop into a portable and general-purpose language; conversely, a general-purpose language may later develop special domain-specific dialects. Some game systems have been extensively extended in functionality by scripting extensions using custom languages, notably the Second Life virtual world (using Linden Scripting Language) and the Trainz franchise of Railroad simulators (using TrainzScript). In some games, such as Wesnoth, users play custom variants of the game defined by user-contributed scripts.",
    id: "gacB",
  },
  {
    name: "GAMS",
    description:
      "GAMS was the first algebraic modeling language (AML) and is formally similar to commonly used fourth-generation programming languages. GAMS contains an integrated development environment (IDE) and is connected to a group of third-party optimization solvers. Among these solvers are BARON, COIN-OR solvers, CONOPT, CPLEX, DICOPT, MOSEK, SNOPT, SULUM, and XPRESS. GAMS allows the users to implement a sort of hybrid algorithm combining different solvers. Models are described in concise, human-readable algebraic statements. GAMS is among the most popular input formats for the NEOS Server.[citation needed] Although initially designed for applications related to economics and management science, it has a community of users from various backgrounds of engineering and science. The driving force behind the development of GAMS were the users of mathematical programming who believed in optimization as a powerful and elegant framework for solving real life problems in science and engineering. At the same time, these users were frustrated by high costs, skill requirements, and an overall low reliability of applying optimization tools. Most of the system's initiatives and support for new development arose in response to problems in the fields of economics, finance, and chemical engineering, since these disciplines view and understand the world as a mathematical program. GAMS’s impetus for development arose from the frustrating experience of a large economic modeling group at the World Bank. In hindsight, one may call it a historic accident that in the 1970s mathematical economists and statisticians were assembled to address problems of development. They used the best techniques available at that time to solve multi-sector economy-wide models and large simulation and optimization models in agriculture, steel, fertilizer, power, water use, and other sectors. Although the group produced impressive research, initial success was difficult to reproduce outside their well functioning research environment. The existing techniques to construct, manipulate, and solve such models required several manual, time-consuming, and error-prone translations into different, problem-specific representations required by each solution method. During seminar presentations, modelers had to defend the existing versions of their models, sometimes quite irrationally, because of time and money considerations. Their models just could not be moved to other environments, because special programming knowledge was needed, and data formats and solution methods were not portable.",
    "Developer(s)": "GAMS Development Corporation",
    "Stable release": "37.1.0 / 12 November 2021 (56 days ago)",
    Platform: "Cross-platform",
    Type: "Algebraic Modeling Language (AML)",
    License: "Proprietary",
    Website: "www.gams.com",
    other_details: {
      type: "programming",
      extensions: [".gms"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 118,
    },
    id: "qz8u",
  },
  {
    name: "GAP",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/GAP_computer_algebra_system_icon.png/220px-GAP_computer_algebra_system_icon.png",
    description:
      "GAP (Groups, Algorithms and Programming) is a computer algebra system for computational discrete algebra with particular emphasis on computational group theory. GAP was developed at Lehrstuhl D für Mathematik (LDFM), Rheinisch-Westfälische Technische Hochschule Aachen, Germany from 1986 to 1997. After the retirement of Joachim Neubüser from the chair of LDFM, the development and maintenance of GAP was coordinated by the School of Mathematical and Computational Sciences at the University of St Andrews, Scotland. In the summer of 2005 coordination was transferred to an equal partnership of four 'GAP Centres', located at the University of St Andrews, RWTH Aachen, Technische Universität Braunschweig, and Colorado State University at Fort Collins; in April 2020, a fifth GAP Centre located at the TU Kaiserslautern was added  GAP and its sources, including packages (sets of user contributed programs), data library (including a list of small groups) and the manual, are distributed freely, subject to \"copyleft\" conditions. GAP runs on any Unix system, under Windows, and on Macintosh systems. The standard distribution requires about 300 MB (about 400 MB if all the packages are loaded). The user contributed packages are an important feature of the system, adding a great deal of functionality. GAP offers package authors the opportunity to submit these packages for a process of peer review, hopefully improving the quality of the final packages, and providing recognition akin to an academic publication for their authors. As of March 2021, there are 151 packages distributed with GAP, of which approximately 71 have been through this process.",
    "Developer(s)":
      "University of St Andrews RWTH Aachen TU Braunschweig Colorado State University TU Kaiserslautern",
    "Stable release": "4.11.1 / 2 March 2021; 10 months ago",
    Repository: "github.com/gap-system/gap ",
    "Written in": "C",
    "Operating system": "Cross-platform",
    Type: "Computer algebra system",
    License: "GNU General Public License",
    Website: "www.gap-system.org",
    other_details: {
      type: "programming",
      extensions: [".g", ".gap", ".gd", ".gi", ".tst"],
      tm_scope: "source.gap",
      ace_mode: "text",
      language_id: 119,
    },
    id: "nmR5",
  },
  {
    name: "machine codes",
    description:
      "G-code instructions are provided to a machine controller (industrial computer) that tells the motors where to move, how fast to move, and what path to follow. The two most common situations are that, within a machine tool such as a lathe or mill, a cutting tool is moved according to these instructions through a toolpath cutting away material to leave only the finished workpiece and/or an unfinished workpiece is precisely positioned in any of up to nine axes around the three dimensions relative to a toolpath and, either or both can move relative to each other. The same concept also extends to noncutting tools such as forming or burnishing tools, photoplotting, additive methods such as 3D printing, and measuring instruments. The first implementation of a numerical control programming language was developed at the MIT Servomechanisms Laboratory in the late 1950s. In the decades since, many implementations have been developed by many (commercial and noncommercial) organizations. G-code has often been used in these implementations. The main standardized version used in the United States was settled by the Electronic Industries Alliance in the early 1960s.[citation needed] A final revision was approved in February 1980 as RS-274-D. In other countries, the standard ISO 6983 is often used, but many European countries use other standards. For example, DIN 66025 is used in Germany, and PN-73M-55256 and PN-93/M-55251 were formerly used in Poland. Extensions and variations have been added independently by control manufacturers and machine tool manufacturers, and operators of a specific controller must be aware of differences of each manufacturer's product. One standardized version of G-code, known as BCL (Binary Cutter Language), is used only on very few machines. Developed at MIT, BCL was developed to control CNC machines in terms of straight lines and arcs.",
    Paradigm: "Procedural, Imperative",
    "Designed by": "Massachusetts Institute of Technology",
    "First appeared": "1950s (first edition)",
    "Filename extensions": ".gcode, .mpt, .mpf, .nc and several others",
    id: "qRS1",
  },
  {
    name: "Godot Engine",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Godot_logo.svg/200px-Godot_logo.svg.png",
    description:
      'Godot aims to offer a fully integrated game development environment. It allows developers to create a game, needing no other tools beyond those used for content creation (visual assets, music, etc.). The engine\'s architecture is built around the concept of a tree of "nodes". Nodes are organized inside of "scenes", which are reusable, instanceable, inheritable, and nestable groups of nodes. All game resources, including scripts and graphical assets, are saved as part of the computer\'s file system (rather than in a database). This storage solution is intended to facilitate collaboration between game development teams using software version control systems. The engine supports deployment to multiple platforms and allows specification of texture compression and resolution settings for each platform. Even though Godot Website provides binaries only for Linux, macOS and Microsoft Windows, the software can be tweaked to work on additional operating systems, like BSD. The Engine supports multiple platforms including desktop and mobile. Currently supported platforms as of Godot 3.4.1  are: There is also a web-based editor hosted by the Godot community available for testing purposes. Even though the Godot engine can be run on consoles, Godot does not support it officially as it is an open-source project rather than a licensed company and they cannot publish platform-specific code under open-source license. However, it is still possible to port games to consoles thanks to services provided by third-party companies. Godot supports a variety of programming languages for making games, including the integrated language GDScript, C++ and C#. Additionally, the engine includes GDNative, a facility for creating bindings with other languages. Officially-supported GDNative languages include C and C++. Community-supported languages include Rust, Nim, JavaScript, Haskell, Clojure, Swift, and D. Visual coding is also supported, via the built-in language VisualScript, designed to be a visual equivalent to GDScript.',
    "Original author(s)": "Juan Linietsky, Ariel Manzur",
    "Initial release": "14 January 2014; 8 years ago",
    "Stable release": "3.4.1  / 17 December 2021; 30 days ago",
    Repository: "github.com/godotengine/godot ",
    "Written in": "C++",
    "Operating system":
      "Microsoft Windows, macOS, Linux, FreeBSD, NetBSD, OpenBSD",
    Platform: "See § Supported platforms",
    "Available in": "Multilingual",
    Type: "Game engine",
    License: "MIT License",
    Website: "docs.godotengine.org",
    Paradigm: "Object-oriented",
    Developer: "Godot Community",
    "Typing discipline": "Dynamic, Duck",
    OS: "Cross-platform (multi-platform)",
    "Filename extensions": ".gd",
    id: "3pT3",
  },
  {
    name: "Genie",
    description:
      "Genie's syntax is derived from numerous modern languages like Python, Boo, D and Delphi. In the vein of Python, Genie uses indentation rather than explicit block delimiters (like, for example, curly brackets) to delimit blocks. Like Vala, Genie uses the GObject type system to create classes and interfaces declared in Genie source code, without imposing additional runtime requirements (i.e., unlike Python, Java or C#, it does not require a virtual machine). Genie allows access to C libraries, especially those based in GObject (like GTK), without using a different application binary interface (ABI). During compilation, the code is first translated to C source and header files, which are then compiled to platform-specific machine code using any available C compiler like GCC, thus allowing cross-platform software development. Programs developed in Vala and Genie do not depend on the GNOME Desktop Environment, usually requiring only GLib.",
    Paradigm: "multi-paradigm: imperative, structured, object-oriented",
    "Designed by": "Jamie McCracken",
    "First appeared": "2008; 14 years ago",
    "Stable release": "0.52.3 / May 1, 2021; 8 months ago",
    "Typing discipline": "static, strong",
    OS: "Cross-platform (every platform supported by GLib)",
    License: "LGPLv2.1+",
    "Filename extensions": ".gs",
    Website: "wiki.gnome.org/Projects/Genie ",
    other_details: {
      type: "programming",
      ace_mode: "text",
      extensions: [".gs"],
      color: "#fb855d",
      tm_scope: "none",
      language_id: 792408528,
    },
    id: "shlg",
  },
  {
    name: "GOAL (Game Oriented Assembly Lisp)",
    description:
      "These objects are similar to blocks in AutoCAD, but unlike blocks, these are parametric, and the 2D and 3D features are connected, so in any view one can get the correct visualization (for example a side view on the section, top view on plan, and perspective in the 3D view). GDL scripts define an ArchiCAD library part in its main roles, these are 3D model, 3D model projected to section/elevation or to 2D plan, 2D plan view, user interface display and behaviour and listing quantities. All versions of the ArchiCAD contain their own default libraries, also objects like furniture, windows, doors, trees, people, cars, construction elements, etc. There are several commercial websites for selling high-detailed intelligent parametric objects, which are perhaps better and more variable than the default libraries, for example there are a lot of environmental objects like plants, people or garden elements, which are not included in the original software. GDL is a free technology (although ArchiCAD itself is a commercial software), it is allowed and possible to develop GDL based object libraries using free tools like Graphisoft LP_XMLConverter and Graphisoft GDL Web Plug-In.",
    id: "eOEa",
  },
  {
    name: "Gödel",
    description:
      "It was designed around a push-down pop-up stack for arithmetic operations, and employed reverse Polish notation. The language included loops, subroutines, conditionals, vectors, and matrices. Algebraic expressions were written in reverse Polish notation; thus,  {\\displaystyle a+b}  was written a b +, and similarly for the other arithmetic operations of subtraction, multiplication, and division. The algebraic expression  {\\displaystyle ax^{2}+bx+c}  was written a x dup × × b x × + c +, where 'dup' meant 'duplicate the value'.",
    id: "pnwh",
  },
  {
    name: "Golo",
    description:
      "With advances in graphics cards, new features have been added to allow for increased flexibility in the rendering pipeline at the vertex and fragment level. Programmability at this level is achieved with the use of fragment and vertex shaders. Originally, this functionality was achieved by writing shaders in ARB assembly language – a complex and unintuitive task. The OpenGL ARB created the OpenGL Shading Language to provide a more intuitive method for programming the graphics processing unit while maintaining the open standards advantage that has driven OpenGL throughout its history. Originally introduced as an extension to OpenGL 1.4, GLSL was formally included into the OpenGL 2.0 core in 2004 by the OpenGL ARB. It was the first major revision to OpenGL since the creation of OpenGL 1.0 in 1992. Some benefits of using GLSL are:",
    other_details: {
      type: "programming",
      color: "#88562A",
      extensions: [".golo"],
      tm_scope: "source.golo",
      ace_mode: "text",
      language_id: 133,
    },
    id: "jslM",
  },
  {
    name: "GNU Guile",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/GNU-Guile-logo.svg/220px-GNU-Guile-logo.svg.png",
    description:
      'For extending programs, Guile offers libguile which allows the language to be embedded in other programs, and integrated closely through the C language application programming interface (API); similarly, new data types and subroutines defined through the C API can be made available as extensions to Guile. Guile is used in programs such as GnuCash, LilyPond, GNU Guix, GNU Debugger, GNU TeXmacs and Google\'s schism. Guile Scheme is a general-purpose, high-level programming language whose flexibility allows expressing concepts in fewer lines of code than would be possible in languages such as C. For example, its hygienic macro system allows adding domain specific syntax-elements without modifying Guile. Guile implements the Scheme standard R5RS, most of R6RS and R7RS, several Scheme Requests for Implementation (SRFI), and many extensions of its own. The core idea of Guile Scheme is that "the developer implements critical algorithms and data structures in C or C++ and exports the functions and types for use by interpreted code. The application becomes a library of primitives orchestrated by the interpreter, combining the efficiency of compiled code with the flexibility of interpretation." Thus Guile Scheme (and other languages implemented by Guile) can be extended with new data types and subroutines implemented through the C API.',
    Family: "Lisp",
    "Designed by": "Aubrey Jaffer, Tom Lord, Miles Bader",
    Developer: "GNU Project",
    "First appeared": "1993; 29 years ago",
    "Stable release": "3.0.7 / 10 May 2021; 8 months ago",
    Platform:
      "IA-32, x86-64, AArch64, armel, armhf, mips, mips64el, mipsel, ppc64el, s390x",
    OS: "Linux, BSD, Windows (through MinGW or Cygwin)",
    License: "GNU LGPLv3+",
    "Filename extensions": ".scm .go (Guile object)",
    Website: "gnu.org/software/guile",
    id: "rbee",
  },
  {
    name: "Go",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Go_Logo_Blue.svg/215px-Go_Logo_Blue.svg.png",
    description:
      "Go is a statically typed, compiled programming language designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson. Go is syntactically similar to C, but with memory safety, garbage collection, structural typing, and CSP-style concurrency. The language is often referred to as Golang because of its former domain name, golang.org, but the proper name is Go. There are two major implementations: A third-party source-to-source compiler, GopherJS, compiles Go to JavaScript for front-end web development. Go was designed at Google in 2007 to improve programming productivity in an era of multicore, networked machines and large codebases. The designers wanted to address criticism of other languages in use at Google, but keep their useful characteristics:",
    Paradigm: "Multi-paradigm: concurrent imperative, object-oriented",
    "Designed by": "Robert Griesemer Rob Pike Ken Thompson",
    Developer: "The Go Authors",
    "First appeared": "November 10, 2009; 12 years ago",
    "Stable release": "1.17.6  / 6 January 2022; 9 days ago",
    "Typing discipline": "Inferred, static, strong, structural, nominal",
    "Implementation language": "Go, Assembly language (gc); C++ (gofrontend)",
    OS: "DragonFly BSD, FreeBSD, Linux, macOS, NetBSD, OpenBSD, Plan 9, Solaris, Windows",
    License: "3-clause BSD + patent grant",
    "Filename extensions": ".go",
    Website: "go.dev",
    other_details: {
      type: "programming",
      color: "#375eab",
      aliases: ["golang"],
      extensions: [".go"],
      ace_mode: "golang",
      codemirror_mode: "go",
      codemirror_mime_type: "text/x-go",
      language_id: 132,
    },
    id: "7d7D",
  },
  {
    name: "Go!",
    description:
      'The authors of Go! describe it as "a multi-paradigm programming language that is oriented to the needs of programming secure, production quality and agent-based applications. It is multi-threaded, strongly typed and higher order (in the functional programming sense). It has relation, function and action procedure definitions. Threads execute action procedures, calling functions and querying relations as needed. Threads in different agents communicate and coordinate using asynchronous messages. Threads within the same agent can also use shared dynamic relations acting as Linda-style tuple stores." The authors also propose that the language is suitable for representing ontologies due to its integration of logic, functional and imperative styles of programming. The following example illustrates the "ontology-oriented" type and declarations style of Go!: The ::= rule defines a new algebraic data type, a data type with only data constructors.',
    Paradigm:
      "Multi-paradigm: concurrent, logic, functional, imperative (object-based)",
    "Designed by": "Francis McCabe, Keith Clark",
    "First appeared": "2003; 19 years ago",
    "Preview release": "9-30-07 / September 30, 2007; 14 years ago",
    "Typing discipline": "strong",
    OS: "Unix-like",
    License: "GPLv2",
    id: "HN0r",
  },
  {
    name: "Game Oriented Assembly Lisp",
    description:
      "It was written using Allegro Common Lisp and used in the development of the entire Jak and Daxter series of games. GOAL's syntax resembles the Lisp dialect Scheme, though with many idiosyncratic object-oriented programming features such as classes, inheritance, and virtual functions. GOAL encourages an imperative programming style: programs tend to consist of a sequence of events to be executed rather than the functional programming style of functions to be evaluated recursively. This is a diversion from Scheme, which allows such side effects but does not encourage imperative style. GOAL does not run in an interpreter, but instead is compiled directly into PlayStation 2 machine code to execute. It offers limited facilities for garbage collection, relying extensively on runtime support. It offers dynamic memory allocation primitives designed to make it well-suited to running in constant memory on a video game console. GOAL has extensive support for inlined assembly language code using a special rlet form, allowing programs to freely mix assembly and higher-level constructs within one function. The GOAL compiler is implemented in Allegro Common Lisp. It supports a long term compiling listener session which gives the compiler knowledge about the state of the compiled and thus running program, including the symbol table. This, in addition to dynamic linking, allows a function to be edited, recompiled, uploaded, and inserted into a running game without having to restart. The process is similar to the edit and continue feature offered by some C++ compilers, but allows programs to replace arbitrary amounts of code (even up to entire object files), and does not interrupt the running game with the debugger. This feature was used to implement code and to level streaming in the Jak and Daxter games.",
    Paradigms: "Multi-paradigm",
    Family: "Lisp",
    "Designed by": "Andy Gavin",
    Developer: "Naughty Dog",
    "First appeared": "3 December 2001; 20 years ago",
    "Stable release": "3 / 7 February 2012; 9 years ago",
    "Typing discipline": "Dynamic, latent, strong",
    Scope: "Lexical",
    "Implementation language": "Allegro Common Lisp",
    Platform: "PlayStation 2, PlayStation Portable, PlayStation 3",
    License: "Proprietary",
    id: "3Dfi",
  },
  {
    name: "Golo",
    description:
      "It has been built as a showcase on how to build a language runtime with invokedynamic. Golo is largely interoperable with the programming language Java and other JVM languages (e.g., numeric types are boxing classes from java.lang, and collection literals leverage java.util classes), that runs on the JVM. In June 2015, Golo became an official Eclipse Foundation project, currently under incubation. The language features have been initially designed around the abilities of invokedynamic – JSR 292 that appeared in Java SE 7. Golo uses ahead-of-time compilation of bytecode. While the bytecode remains stable over a program execution, the invokedynamic-based reconfigurable call sites support the adaptive dispatch mechanisms put in place for helping the HotSpot just-in-time compiler (JIT) to extract reasonable performance. List of JVM languages",
    Developer: "INSA Lyon",
    "First appeared": "2012; 10 years ago",
    "Stable release": "3.4.0 / October 20, 2021; 2 months ago",
    "Typing discipline": "Dynamic, weak",
    Platform: "Java virtual machine",
    OS: "Cross-platform",
    License: "Eclipse Public 2.0",
    Website: "golo-lang.org",
    other_details: {
      type: "programming",
      color: "#88562A",
      extensions: [".golo"],
      tm_scope: "source.golo",
      ace_mode: "text",
      language_id: 133,
    },
    id: "GPHN",
  },
  {
    name: "MAD",
    description:
      "The archives at the Bentley Historical Library of the University of Michigan contain reference materials on the development of MAD and MAD/I, including three linear feet of printouts with hand-written notations and original printed manuals. There are three MAD compilers: While MAD was motivated by ALGOL 58, it does not resemble ALGOL 58 in any significant way. Programs written in MAD included MAIL, RUNOFF, one of the first text processing systems, and several other utilities all under Compatible Time-Sharing System (CTSS). Work was done on a design for a MAD compiler for Multics, but it was never implemented.",
    Paradigm: "Imperative",
    Developer: "Galler, Arden, and Graham",
    "First appeared": "1959",
    OS: "UMES, MTS, CTSS, others",
    id: "Q_sN",
  },
  {
    name: "Gosu",
    description:
      "Gosu can serve as a scripting language, having free-form Program types (.gsp files) for scripting as well as statically verified Template files (.gst files). Gosu can optionally execute these and all other types directly from source without precompilation, which also distinguishes it from other static languages. Gosu began in 2002 as a scripting language called GScript at Guidewire Software. It has been described as a Java variant that attempts to make useful improvements while retaining the fundamental utility and compatibility with Java. It was used to configure business logic in Guidewire's applications and was more of a simple rule definition language. In its original incarnation it followed ECMAScript guidelines. Guidewire enhanced the scripting language over the next 8 years, and released Gosu 0.7 beta to the community in November 2010. The 0.8 beta was released in December 2010, and 0.8.6 beta was released in mid-2011 with additional typeloaders, making Gosu capable of loading XML schema definition files and XML documents as native Gosu types. The latest version is 1.10, released in January 2016, along with a new IntelliJ IDEA editor plugin. Guidewire continues to support and use Gosu extensively within InsuranceSuite applications. Guidewire has decided to freeze the development of new Gosu programming language constructs at this time. Guidewire continues to evolve InsuranceSuite through RESTful APIs and Integration Frameworks that can be accessed using Java. Gosu language creator and development lead, Scott McKinney, emphasizes pragmatism, found in readability and discoverability, as the overriding principle that guides the language's design. For instance, Gosu's rich static type system is a necessary ingredient toward best of breed tooling via static programming analysis, rich parser feedback, code completion, deterministic refactoring, usage analysis, navigation, and the like.",
    Developer: "Guidewire and open source contributors",
    "Stable release": "1.14.23 / August 10, 2021; 4 months ago",
    "Typing discipline": "static",
    Platform:
      "Execute on the Java Virtual Machine, statically and dynamically compiles to bytecode",
    OS: "any supporting JVM",
    License: "Apache License 2.0",
    "Filename extensions": ".gs, .gsp, .gst, .gsx",
    Website: "gosu-lang.github.io",
    other_details: {
      type: "programming",
      color: "#82937f",
      extensions: [".gs", ".gst", ".gsx", ".vark"],
      tm_scope: "source.gosu.2",
      ace_mode: "text",
      language_id: 134,
    },
    id: "tznc",
  },
  {
    name: "IBM 1620",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/IBM_Logo_1956_1972.svg/120px-IBM_Logo_1956_1972.svg.png",
    description:
      'Being variable-word-length decimal, as opposed to fixed-word-length pure binary, made it an especially attractive first computer to learn on – and hundreds of thousands of students had their first experiences with a computer on the IBM 1620. Core memory cycle times were 20 microseconds for the (earlier) Model I, 10 microseconds for the Model II (about a thousand times slower than typical computer main memory in 2006). The Model II was introduced in 1962. The IBM 1620 was a variable "word" length decimal (BCD) computer with a magnetic-core memory that could hold: The above was in the Model I. The Model II deployed the IBM 1625 core-storage memory unit, whose memory cycle time was halved by using faster cores, compared to the Model I\'s (internal or 1623 memory unit): to 10 µs (i.e., the cycle speed was raised to 100 kHz).',
    Manufacturer: "IBM",
    Type: "Scientific minicomputer",
    "Release date": "1959",
    Memory: "20,000-60,000 words",
    Predecessor: "IBM 650; IBM 610; IBM 608",
    Successor: "IBM 1130",
    "Related articles": "IBM 1710, IBM 1720",
    id: "y0X2",
  },
  {
    name: "Halide (programming language)",
    description:
      "GPSS was developed by IBM's Geoffrey Gordon at the beginning of the 1960s. He named it Gordon's Programmable Simulation System. The name was changed when IBM decided to release it as a product. The \"General Purpose\" part of the new name was to create a standard in waiting-line simulations. The original releases were for IBM's 7044 & 7090 mainframes. Subsequently, there were releases for IBM 360, Univac 1108 and CDC.   Over time, other implementations, in other languages and targeted at different size systems, were developed, including DEC's VAX, a specialized APL version for large-scale Univac systems, and Macintosh, among others.",
    id: "4E5I",
  },
  {
    name: "Computer Sciences Corporation",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/CSC_Logo.svg/220px-CSC_Logo.svg.png",
    description:
      "Computer Sciences Corporation (CSC) was an American multinational corporation that provided information technology (IT) services and professional services. On April 3, 2017, it merged with the Enterprise Services line of business of HP Enterprise (formerly Electronic Data Systems) to create DXC Technology. CSC was founded in April 1959 in Los Angeles, California, by Roy Nutt and Fletcher Jones. CSC initially provided programming tools such as assembler and compiler software. In the 1960s, CSC provided software programming services to major computer manufacturers like IBM and Honeywell and secured their first contracts for the U.S. public sector with NASA (among others). By 1963, CSC became the largest software company in the United States and the first software company to be listed on the American Stock Exchange. By the end of 1968, CSC was listed on the New York Stock Exchange and had operations in Canada, India, the United Kingdom, Germany, Spain, Italy, Brazil, and the Netherlands.",
    Type: "Public",
    "Traded as": "NYSE: CSC",
    Industry: "IT services, IT consulting",
    Founded: "April 1959; 62 years ago",
    Founder: "Roy Nutt Fletcher R. Jones",
    Defunct: "April 3, 2017",
    Fate: "Merged with HP Enterprise Services; formed DXC Technology",
    Successor: "DXC Technology",
    Headquarters: "Tysons Corner, Virginia, United States",
    "Area served": "Worldwide",
    "Key people": "John Michael Lawrie (Chairman, President and CEO)",
    Services: "IT, business consulting and outsourcing services",
    Subsidiaries: "Computer Sciences Raytheon, Xchanging",
    id: "MHTX",
  },
  {
    name: "Harbour",
    description:
      'As part of a later partnership with Midway Games, the language was ported to the Midway\'s Z80-based Z Box. This machine used raster graphics and a form of sprites, which required extensive changes to support, along with animating color changes. This version was known as ZGrass. The original version of GRASS was developed by Tom DeFanti for his 1974 Ohio State University Ph.D. thesis. It was developed on a PDP-11/45 driving a Vector General 3DR display. As the name implies, this was a purely vector graphics machine. GRASS included a number of vector-drawing commands, and could organize collections of them into a hierarchy, applying the various animation effects to whole "trees" of the image at once (stored in arrays). After graduation, DeFanti moved to the University of Illinois, Chicago Circle. There he joined up with Dan Sandin and together they formed the Circle Graphics Habitat (today known as the Electronic Visualization Laboratory, or EVL). Sandin had joined the university in 1971 and built the Sandin Image Processor, or IP. The IP was an analog computer which took two video inputs, mixed them, colored the results, and then re-created TV output. He described it as the video version of a Moog synthesizer. DeFanti added the existing GRASS system as the input to the IP, creating the GRASS/Image Processor, which was used throughout the mid-1970s. In order to make the system more useful, DeFanti and Sandin added all sorts of "one-off" commands to the existing GRASS system, but these changes also made the language considerably more idiosyncratic. In 1977 another member of the Habitat, Nola Donato, re-designed many of GRASS\'s control structures into more general forms, resulting in the considerably cleaner GRASS3.',
    other_details: {
      type: "programming",
      color: "#0e60e3",
      extensions: [".hb"],
      tm_scope: "source.harbour",
      ace_mode: "text",
      language_id: 156,
    },
    id: "HdJw",
  },
  {
    name: "Grasshopper",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Grasshopper_MainWindow.png/300px-Grasshopper_MainWindow.png",
    description:
      'Grasshopper is primarily used to build generative algorithms, such as for generative art. Many of Grasshopper\'s components create 3D geometry. Programs may also contain other types of algorithms including numeric, textual, audio-visual and haptic applications. Advanced uses of Grasshopper include parametric modelling for structural engineering, parametric modelling for architecture and fabrication, lighting performance analysis for eco-friendly architecture and building energy consumption. The first version of Grasshopper, then called Explicit History, was released in September 2007. Grasshopper has become part of the standard Rhino toolset in Rhino 6.0 and later. AEC Magazine stated that Grasshopper is "Popular among students and professionals, McNeel Associate’s Rhino modelling tool is endemic in the architectural design world. The new Grasshopper environment provides an intuitive way to explore designs without having to learn to script." Research supporting this claim has come from product design and architecture.',
    Paradigm: "visual programming",
    "Designed by": "David Rutten",
    Developer: "Robert McNeel and associates",
    "First appeared": "September 2007; 14 years ago",
    "Stable release": "1.0 / April 4, 2014; 7 years ago",
    OS: "Windows 2000 and later, MacOS",
    License: "Proprietary",
    "Filename extensions": ".gh (binary), .ghx (ascii), .gha (plugins)",
    Website: "grasshopper3d.com",
    id: "bbqy",
  },
  {
    name: "Groovy",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Groovy-logo.svg/220px-Groovy-logo.svg.png",
    description:
      'Groovy 1.0 was released on January 2, 2007, and Groovy 2.0 in July, 2012. Since version 2, Groovy can be compiled statically, offering type inference and performance near that of Java. Groovy 2.4 was the last major release under Pivotal Software\'s sponsorship which ended in March 2015. Groovy has since changed its governance structure to a Project Management Committee in the Apache Software Foundation. James Strachan first talked about the development of Groovy on his blog in August 2003. In March 2004, Groovy was submitted to the JCP as JSR 241 and accepted by ballot. Several versions were released between 2004 and 2006. After the Java Community Process (JCP) standardization effort began, the version numbering changed, and a version called "1.0" was released on January 2, 2007. After various betas and release candidates numbered 1.1, on December 7, 2007, Groovy 1.1 Final was released and immediately renumbered as Groovy 1.5 to reflect the many changes made. In 2007, Groovy won the first prize at JAX 2007 innovation award. In 2008, Grails, a Groovy web framework, won the second prize at JAX 2008 innovation award. In November 2008, SpringSource acquired the Groovy and Grails company (G2One). In August 2009 VMware acquired SpringSource.',
    Paradigm: "Object-oriented, imperative, scripting",
    "Designed by": "James Strachan",
    Developer:
      "Guillaume Laforge (PMC Chair) Jochen Theodorou (Tech Lead) Paul King Cedric Champeau",
    "First appeared": "2003; 19 years ago",
    "Stable release": "3.0.9 (September 2, 2021; 4 months ago) [±]",
    "Preview release": "4.0.0-beta-1 / September 6, 2021; 4 months ago",
    "Typing discipline": "Dynamic, static, strong, duck",
    Platform: "Java SE",
    License: "Apache License 2.0",
    "Filename extensions": ".groovy, .gvy, .gy, .gsh",
    Website: "groovy-lang.org ",
    other_details: {
      type: "programming",
      ace_mode: "groovy",
      codemirror_mode: "groovy",
      codemirror_mime_type: "text/x-groovy",
      color: "#e69f56",
      extensions: [".groovy", ".grt", ".gtpl", ".gvy"],
      interpreters: ["groovy"],
      filenames: ["Jenkinsfile"],
      language_id: 142,
    },
    id: "zA8y",
  },
  {
    name: "Hack",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Hack_%28programming_language%29_logo.svg/43px-Hack_%28programming_language%29_logo.svg.png",
    description:
      'Hack allows programmers to use both dynamic typing and static typing. This kind of a type system is called gradual typing, which is also implemented in other programming languages such as ActionScript. Hack\'s type system allows types to be specified for function arguments, function return values, and class properties; however, types of local variables are always inferred and cannot be specified. Hack was introduced on March 20, 2014. Before the announcement of the new programming language, Facebook had already implemented the code and "battle tested" it on a large portion of its web site. Hack is designed to interoperate seamlessly with PHP, which is a widely used open-source scripting language that has a focus on web development and can be embedded into HTML. A majority of valid PHP scripts are also valid in Hack; however, numerous less frequently used PHP features and language constructs are not supported in Hack. Hack extends the type hinting available in PHP 5 through the introduction of static typing, by adding new type hints (for example, for scalar types such as integer or string), as well as by extending the use of type hints (for example, for class properties or function return values). However, types of local variables cannot be specified. Since Hack uses a gradual typing system, in the default mode, type annotations are not mandatory even in places they cannot be inferred; the type system will assume the author is correct and admit the code. However, a "strict" mode is available which requires such annotations, and thus enforces fully sound code.',
    "Designed by":
      "Julien Verlaguet, Alok Menghrajani, Drew Paroski, and others",
    Developer: "Facebook",
    "First appeared": "2014",
    "Typing discipline": "Static, dynamic, weak, gradual",
    OS: "Cross-platform",
    License: "MIT License",
    Website: "hacklang.org",
    other_details: {
      type: "programming",
      ace_mode: "php",
      codemirror_mode: "php",
      codemirror_mime_type: "application/x-httpd-php",
      extensions: [".hh", ".php"],
      tm_scope: "text.html.php",
      color: "#878787",
      language_id: 153,
    },
    id: "aENw",
  },
  {
    name: "Hermes",
    description:
      "Haggis is not based on any one language but a mixture that is intended to allow a pupil familiar with any of the many languages used in classrooms to easily understand the syntactic construct being used in an example. It has multiple programming paradigms of functional, imperative and object-oriented to suit this purpose. There are three separate language definitions, one for each level at which computing is assessed by the SQA; these are proper subsets of each other, so for example any program contained by the National 5 level language is also well-defined at Higher and Advanced Higher levels. Higher includes the definition of procedures and functions and the use of record types and files, while Advanced Higher includes object-orientation. Online Haggis interpreters have been developed to provide a way for examiners and teachers to check their programs are correctly defined and behave as expected. In Scotland, school-level computing qualifications are awarded by the Scottish Qualifications Authority. A decision was made for computing courses that a single choice of programming language for examination should not be mandated: this allows teachers to choose languages as appropriate to context. This however leaves the issue of how to examine programming, especially in the light of recent educational research which encourages the teaching of reading and understanding code as a core discipline, which should therefore be examined.",
    id: "rgpY",
  },
  {
    name: "High Level Assembly (HLA)",
    description:
      'The three key principles in designing the language were reliability, efficiency, and machine-independence. The language is designed to allow aerospace-related tasks (such as vector/matrix arithmetic) to be accomplished in a way that is easily understandable by people who have spaceflight knowledge, but may not necessarily have proficiency with computer programming. HAL/S was designed not to include some constructs that were thought to be the cause of errors. For instance, there is no support for dynamic memory allocation. The language provides special support for real-time execution environments. Some features, such as "GOTO" were provided chiefly to ease mechanical translations from other languages. (page 82)  "HAL" was suggested as the name of the new language by Ed Copps, a founding director of Intermetrics, to honor Hal Laning, a colleague at MIT. On the Preface page of the HAL/S Language Specification, it says,',
    id: "I9wZ",
  },
  {
    name: "Hamilton C shell",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Hamilton_C_shell_x64_on_Windows_7.png/300px-Hamilton_C_shell_x64_on_Windows_7.png",
    description:
      'Hamilton C shell differs from the Unix C shell in several respects. These include its compiler architecture, its use of threads, and the decision to follow Windows rather than Unix conventions. The original C shell uses an ad hoc parser. This has led to complaints about its limitations. It works well enough for the kinds of things users type interactively but not very well for the more complex commands a user might take time to write in a script. It is not possible, for example, to pipe the output of a foreach statement into grep. There was a limit to how complex a command it could handle. By contrast, Hamilton uses a top-down recursive descent parser that allows it to compile statements to an internal form before running them. As a result, statements can be nested or piped arbitrarily. The language has also been extended with built-in and user-defined procedures, local variables, floating point and additional expression, editing and wildcarding operators, including an "indefinite directory" wildcard construct written as "..." that matches zero or more directory levels as required to make the rest of the pattern match. Lacking fork or a high performance way to recreate that functionality, Hamilton uses the Windows threads facilities instead. When a new thread is created, it runs within the same process space and it shares all of the process state. If one thread changes the current directory or the contents of memory, it\'s changed for all the threads. It\'s much cheaper to create a thread than a process but there\'s no isolation between them. To recreate the missing isolation of separate processes, the threads cooperate to share resources using locks.',
    "Original author(s)": "Nicole Hamilton",
    "Initial release": "December 12, 1988; 33 years ago",
    "Stable release": "5.2.g / March 5, 2017; 4 years ago",
    "Written in": "C",
    "Operating system": "Windows (historically OS/2)",
    Type: "Unix Shell on Windows",
    License: "Commercial proprietary software",
    Website: "hamiltonlabs.com/Cshell.htm",
    id: "UpJ7",
  },
  {
    name: "Harbour Project",
    description:
      'Harbour is a computer programming language, primarily used to create database/business programs. It is a modernized, open sourced and cross-platform version of the older Clipper system, which in turn developed from the dBase database market of the 1980s and 1990s. Harbour code using the same databases can be compiled under a wide variety of platforms, including Microsoft Windows, Linux, Unix variants, several BSD descendants, Mac OS X, MINIX 3, Windows CE, Pocket PC, Symbian, iOS, Android, QNX, VxWorks, OS/2 (including eComStation and ArcaOS), BeOS/Haiku, AIX and MS-DOS. The idea of a free software Clipper compiler had been floating around for a long time and the subject has often cropped up in discussion on comp.lang.clipper. Antonio Linares founded the Harbour project and the implementation was started in March 1999. The name "Harbour" was proposed by Linares, it is a play on a Clipper as a type of ship. Harbour is a synonym for port (where ships dock), and Harbour is a port of the Clipper language. In 2009 Harbour was substantially redesigned, mainly by Viktor Szakáts and Przemyslaw Czerpak.',
    Paradigm:
      "multi-paradigm: imperative, functional, object-oriented, reflective",
    "Designed by": "Antonio Linares",
    Developer: "Viktor Szakáts and community",
    "First appeared": "1999; 23 years ago",
    "Stable release": "3.0.0 / 17 July 2011; 10 years ago",
    "Preview release": "3.2.0dev",
    "Typing discipline": "Optionally duck, dynamic, safe, partially strong",
    OS: "Cross-platform",
    License: "Open-source GPL-compatible",
    "Filename extensions": ".prg, .ch, .hb, .hbp",
    Website: "harbour.github.io",
    id: "RHU-",
  },
  {
    name: "Pipelines",
    image: "https://upload.wikimedia.org/wikipedia/en/0/0c/Pipjarg1.jpeg",
    description:
      "CMS Pipelines provides a CMS command, PIPE. The argument string to the PIPE command is the pipeline specification. PIPE selects programs to run and chains them together in a pipeline to pump data through. Because CMS programs and utilities don't provide a device independent stdin and stdout interface, CMS Pipelines has a built-in library of programs that can be called in a pipeline specification. These built-in programs interface to the operating system, and perform many utility functions. Data on CMS is structured in logical records rather than a stream of bytes. For textual data a line of text corresponds to a logical record. In CMS Pipelines the data is passed between the stages as logical records. CMS Pipelines users issue pipeline commands from the terminal or in EXEC procedures. Users can write programs in REXX that can be used in addition to the built-in programs.",
    Paradigm: "Dataflow programming",
    "Designed by": "John P. Hartmann (IBM)",
    Developer: "IBM",
    "First appeared": "1986",
    "Stable release": "1.1.12/0012 / 2020-06-03",
    Platform: "IBM z Systems",
    OS: "z/VM 7.1",
    Website: "http://vm.marist.edu/~pipeline",
    id: "dBwc",
  },
  {
    name: "Haskell",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/4/4d/Logo_of_the_Haskell_programming_language.svg/250px-Logo_of_the_Haskell_programming_language.svg.png",
    description:
      "Haskell (/ˈhæskəl/) is a general-purpose, statically-typed, purely functional programming language with type inference and lazy evaluation. Designed for teaching, research and industrial application, Haskell has pioneered a number of advanced programming language features such as type classes, which enable type-safe operator overloading. Haskell's main implementation is the Glasgow Haskell Compiler (GHC). It is named after logician Haskell Curry. Haskell's semantics are historically based on those of the Miranda programming language, which served to focus the efforts of the initial Haskell working group. The last formal specification of the language was made in July 2010, while the development of GHC has expanded Haskell via language extensions. The next formal specification was planned for 2020. On 29 October 2021 GHC2021 was released in GHC version 9.2.1. Haskell is used in academia and industry. As of May 2021, Haskell was the 28th most popular programming language by Google searches for tutorials, and made up less than 1% of active users on the GitHub source code repository. Following the release of Miranda by Research Software Ltd. in 1985, interest in lazy functional languages grew. By 1987, more than a dozen non-strict, purely functional programming languages existed. Miranda was the most widely used, but it was proprietary software. At the conference on Functional Programming Languages and Computer Architecture (FPCA '87) in Portland, Oregon, there was a strong consensus that a committee be formed to define an open standard for such languages. The committee's purpose was to consolidate existing functional languages into a common one to serve as a basis for future research in functional-language design.",
    Paradigm: "Purely functional",
    "Designed by":
      "Lennart Augustsson, Dave Barton, Brian Boutel, Warren Burton, Joseph Fasel, Kevin Hammond, Ralf Hinze, Paul Hudak, John Hughes, Thomas Johnsson, Mark Jones, Simon Peyton Jones, John Launchbury, Erik Meijer, John Peterson, Alastair Reid, Colin Runciman, Philip Wadler",
    "First appeared": "1990; 32 years ago",
    "Stable release": "Haskell 2010 / July 2010; 11 years ago",
    "Preview release": "Haskell 2020 announced",
    "Typing discipline": "Inferred, static, strong",
    OS: "Cross-platform",
    "Filename extensions": ".hs, .lhs",
    Website: "www.haskell.org",
    other_details: {
      type: "programming",
      color: "#5e5086",
      extensions: [".hs", ".hsc"],
      interpreters: ["runhaskell"],
      ace_mode: "haskell",
      codemirror_mode: "haskell",
      codemirror_mime_type: "text/x-haskell",
      language_id: 157,
    },
    id: "UNVJ",
  },
  {
    name: "Haxe",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Haxe_logo.svg/64px-Haxe_logo.svg.png",
    description:
      "Haxe includes a set of features and a standard library supported across all platforms, like numeric data types, strings, arrays, maps, binary, reflection, math, HTTP, file system and common file formats. Haxe also includes platform-specific API's for each compiler target. Kha, OpenFL and Heaps.io are popular Haxe frameworks that enable creating multi-platform content from one codebase. Haxe originated with the idea of supporting client-side and server-side programming in one language, and simplifying the communication logic between them. Code written in the Haxe language can be compiled into JavaScript, C++, Java, PHP, C#, Python, Lua and Node.js. Haxe can also directly compile SWF, HashLink and NekoVM bytecode and also runs in interpreted mode. Haxe supports externs (definition files) that can contain type information of existing libraries to describe target-specific interaction in a type-safe manner, like C++ header files can describe the structure of existing object files. This enables to use the values defined in the files as if they were statically typed Haxe entities. Beside externs, other solutions exist to access each platform's native capabilities. Many popular IDEs and source code editors have support available for Haxe development. No particular development environment or tool set is officially recommended by the Haxe Foundation, although VS Code, IntelliJ IDEA and HaxeDevelop have most support for Haxe development. The core functionalities of syntax highlighting, code completion, refactoring, debugging, etc. are available to various degrees.",
    Paradigm: "Multi-paradigm",
    Developer: "Haxe Foundation",
    "First appeared": "2006; 16 years ago",
    "Stable release": "4.2.4  / 22 October 2021; 2 months ago",
    "Typing discipline": "Static, dynamic via annotations, nominal",
    "Implementation language": "OCaml",
    Platform:
      "IA-32, x86-64, AArch64, armel, armhf, mips, mips64el, mipsel, ppc64el, s390x",
    OS: "Android, iOS; Linux, macOS, Windows",
    License: "GPL 2.0, library: MIT",
    "Filename extensions": ".hx, .hxml",
    Website: "haxe.org ",
    other_details: {
      type: "programming",
      ace_mode: "haxe",
      codemirror_mode: "haxe",
      codemirror_mime_type: "text/x-haxe",
      color: "#df7900",
      extensions: [".hx", ".hxsl"],
      tm_scope: "source.hx",
      language_id: 158,
    },
    id: "16EH",
  },
  {
    name: "Hume",
    description:
      'It used typestate analysis to check variables transitions errors, to rule out some semantically non meaningful transitions from one state to another (i.e. starting from a value, some sequences of operations on a variable are nonsensical), of which reading an uninitialized variable is a special case. In this role of compile-time checking of data initialization is similar to definite assignment analysis performed by Java, Cyclone and C#. Hermes and its predecessor, NIL (Network Implementation Language), were the earliest programming languages supporting this form of initialization checking. Typestate was actually used more extensively, to generate compiler-inserted "delete" operations.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.',
    id: "u7F6",
  },
  {
    name: "High Level Assembly (HLA)",
    description:
      "HLA was originally conceived as a tool to teach assembly language programming at the college-university level. The goal is to leverage students' existing programming knowledge when learning assembly language to get them up to speed as fast as possible. Most students taking an assembly language programming course have already been introduced to high-level control flow structures, such as IF, WHILE, FOR, etc. HLA allows students to immediately apply that programming knowledge to assembly language coding early in their course, allowing them to master other prerequisite subjects in assembly before learning how to code low-level forms of these control structures. The book The Art of Assembly Language Programming by Randall Hyde uses HLA for this purpose. The HLA v2.x assembler supports the same low-level machine instructions as a regular, low-level, assembler. The difference is that high-level assemblers, such as HLA, Microsoft Macro Assembler (MASM), or Turbo Assembler (TASM), on the Intel x86 processor family, also support high-level-language-like statements, such as IF, WHILE, and so on, and fancier data declaration directives, such as structures-records, unions, and even classes. Unlike most other assembler tools, the HLA compiler includes a Standard Library with thousands of functions, procedures, and macros that can be used to create full applications with the ease of a high-level language. While assembly language libraries are not new, a language that includes a large standardized library makes programmers far more likely to use such library code rather than simply writing their own library functions. HLA supports all the same low-level machine instructions as other x86 assemblers. Further, HLA's high-level control structures are based on the ones found in MASM and TASM, which HLL-like features predated the arrival of HLA by several years. In HLA, low-level assembly code can be written as easily as with any other assembler by simply ignoring the HLL-control constructs. In contrast to HLLs like Pascal and C(++), HLA doesn't require inline asm statements. In HLA, HLL-like features appear to provide a learning aid for beginning assembly programmers by smoothing the learning curve, with the assumption that they will discontinue the use of those statements once they master the low-level instruction set. In practice, many experienced programmers continue to use HLL-like statements in HLA, MASM, and TASM, long after mastering the low-level instruction set, but this is usually done to improve readability.",
    "Developer(s)": "Randall Hyde",
    "Stable release": "2.16 / July 6, 2011; 10 years ago",
    Repository: "sourceforge.net/projects/hlav1",
    "Written in": "Assembly language",
    "Operating system": "Windows, Linux, FreeBSD, macOS",
    Platform: "IA-32",
    "Available in": "English",
    Type: "Assembler",
    License: "Public domain",
    Website: "plantation-productions.com/Webster",
    id: "PLRX",
  },
  {
    name: "Icon",
    description:
      "HLSL is analogous to the GLSL shading language used with the OpenGL standard. It is very similar to the Nvidia Cg shading language, as it was developed alongside it. Early versions of the two languages were considered identical, only marketed differently. HLSL shaders can enable profound speed and detail increases as well as many special effects in both 2D and 3D computer graphics.[citation needed] HLSL programs come in six forms: pixel shaders (fragment in GLSL), vertex shaders, geometry shaders, compute shaders, tessellation shaders (Hull and Domain shaders), and ray tracing shaders (Ray Generation Shaders, Intersection Shaders, Any Hit/Closest Hit/Miss Shaders). A vertex shader is executed for each vertex that is submitted by the application, and is primarily responsible for transforming the vertex from object space to view space, generating texture coordinates, and calculating lighting coefficients such as the vertex's normal, tangent, and bitangent vectors. When a group of vertices (normally 3, to form a triangle) come through the vertex shader, their output position is interpolated to form pixels within its area; this process is known as rasterization. Optionally, an application using a Direct3D 10/11/12 interface and Direct3D 10/11/12 hardware may also specify a geometry shader. This shader takes as its input some vertices of a primitive (triangle/line/point) and uses this data to generate/degenerate (or tessellate) additional primitives or to change the type of primitives, which are each then sent to the rasterizer. D3D11.3 and D3D12 introduced Shader Model 5.1 and later 6.0.",
    id: "vYnC",
  },
  {
    name: "Hollywood",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Hollywood-ide3.jpg/300px-Hollywood-ide3.jpg",
    description:
      "The Hollywood Designer is an add-on for Hollywood with which it is possible to use Hollywood also as a presentation software and an authoring system. Hollywood has its roots on the Amiga computer. Inspired by Amiga programming languages like AMOS, Blitz BASIC, and Amiga E, Hollywood author Andreas Falkenhahn began development of Hollywood in Spring 2002 after finishing his A-levels. Version 1.0 of the software was released in November 2002, but only for 68000-based Amiga systems. A month later, a native version for the PowerPC-based MorphOS followed. Support for WarpOS was introduced with Hollywood 1.9 which appeared in Spring 2004 together with the first release of the Hollywood Designer, a tool which can be used to create presentations with Hollywood. AmigaOS 4 is supported since March 2005. Starting with version 2.0 (released in January 2006), Hollywood is using the Lua programming language as its virtual machine, but with significant modifications in syntax and functionality. Starting with version 3.0 (January 2008), Hollywood for the first time also runs on two non Amiga inspired operating systems: Microsoft Windows and macOS. Since version 4.5 (January 2010) Hollywood is also available with an integrated development environment on Windows. Since version 4.8 (April 2011) Hollywood can also compile executables for Linux. Hollywood 5.0 was released in February 2012 and introduces support for video playback and vector image formats like SVG. Starting with version 5.2 Hollywood also supports Android. Hollywood 6.0 was released in February 2015 and introduces support for OpenGL programming via a dedicated plugin as well as support for the Raspberry Pi. Hollywood 7.0 was released in March 2017 and introduces Unicode support and support for 64-bit architectures. Hollywood's focus is on ease of use and platform independence. It was mainly designed for the creation of games and multimedia applications. The language set comprises roughly 900 different commands from the following fields of application: 2D graphics, sound, file system operations, text output, animations, sprites, layers, transition effects, image manipulation, saving of images and video files, time and date functions, input functions (keyboard, joystick, mouse) as well as mathematical operations and string functions. Programming in Hollywood is done via so called Hollywood scripts (using the file extension *.hws). These scripts are compiled dynamically and can be converted into stand-alone executables. All Hollywood programs run inside a sandbox, which makes it impossible for them to crash. Hollywood was designed to be a completely platform independent programming language. Thus, scripts cannot call any API functions of the host operating system directly and are limited to the inbuilt command set. Text rendering is also implemented via a platform independent font backend that ensures that TrueType text looks exactly the same on every platform. Furthermore, all versions of Hollywood support Amiga specific file formats like IFF ILBM images, IFF 8SVX sounds, or IFF ANIM files, to be fully compatible with scripts written on an Amiga system.",
    "Developer(s)": "Andreas Falkenhahn",
    "Initial release": "November 2002; 19 years ago",
    "Stable release": "5.0 / April 19, 2020; 20 months ago",
    "Operating system": "AmigaOS, MorphOS, WarpOS, AROS",
    Type: "Presentation",
    License: "Proprietary",
    Website: "www.hollywood-mal.com",
    id: "nxIJ",
  },
  {
    name: "TempleOS",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/TempleOS_logo.png/250px-TempleOS_logo.png",
    description:
      "TempleOS (formerly J Operating System, LoseThos, and SparrowOS) is a biblical-themed lightweight operating system (OS) designed to be the Third Temple prophesied in the Bible. It was created by American programmer Terry A. Davis, who developed it alone over the course of a decade after a series of manic episodes that he later described as a revelation from God. The system was characterized as a modern x86-64 Commodore 64, using an interface similar to a mixture of DOS and Turbo C. Davis proclaimed that the system's features, such as its 640x480 resolution, 16-color display, and single-voice audio, were designed according to explicit instructions from God. It was programmed with an original variation of C (named HolyC) in place of BASIC, and included an original flight simulator, compiler and kernel. TempleOS was released as J Operating System in 2005 and as TempleOS in 2013, and was last updated in 2017. Terry A. Davis (1969–2018) began experiencing regular manic episodes in 1996, leading him to numerous stays at mental hospitals. Initially diagnosed with bipolar disorder, he was later declared schizophrenic and remained unemployed for the rest of his life. He suffered from delusions of space aliens and government agents that left him briefly hospitalized for his mental health issues. After experiencing a self-described \"revelation\", he proclaimed that he was in direct communication with God, and that God told him the operating system was for God's third temple.",
    Developer: "Terry A. Davis",
    "Written in": "HolyC and x86 Assembly",
    "Working state": "Finished",
    "Source model": "Open source",
    "Initial release":
      "2005; 17 years ago (as J Operating System) 2013; 9 years ago (as TempleOS)",
    "Latest release": "5.03 / November 20, 2017; 4 years ago",
    Platforms: "x64",
    "Kernel type": "Monolithic",
    "Default user interface": "640x480 16 Color Graphics",
    License: "Public domain",
    "Official website": "templeos.org",
    id: "oFZ6",
  },
  {
    name: "IBM RPG",
    description:
      'The idea sprang from an existing programming tool, Scratch, where the user drags blocks to create a script. This is much easier for children than typing out the code manually like in most programming languages. The developers of Hopscotch wanted to take a step back from Scratch, making it slightly easier to grasp the concepts and easier to use, so removed many blocks and added some of their own. Hopscotch\'s notion of events, and rules combining conditions with actions, is similar to AgentSheets. Hopscotch includes basic programming blocks and functionalities such as variables, sprites (called objects) and text objects, but also features considered more advanced such as self-variables, maths functions and more. The Hopscotch app uses a UI very similar to that of Scratch. Use of the editor is simple, all one has to do is open the editor, tap the object and script you wish to edit, open one of the block tabs, and drag out code blocks. Most code blocks can have numeric, text, or math inputs. e.g. the "move" block. The editor work area is mainly based on a grid divided into X and Y-coordinates. The Hopscotch Editor is available on iPhone and iPad. The iPhone version only supported viewing projects until early 2016, when an update supporting editing and account functionality was released. The Hopscotch iPhone projects play in an iPhone format even on the iPad and web player. A version for Android is not planned for release (as of 2021)',
    id: "P2_i",
  },
  {
    name: "IDL",
    description:
      "Hope was named for Sir Thomas Hope (c. 1681–1771), a Scottish agricultural reformer, after whom Hope Park Square in Edinburgh, the location of the Department of Artificial Intelligence at the time of the development of Hope, was also named. A factorial program in Hope is: Changing the order of the clauses does not change the meaning of the program, because Hope's pattern matching always favors more specific patterns over less specific ones. Explicit type declarations in Hope are required; there is no option to use a type-inference algorithm in Hope. Hope provides two built-in data structures: tuples and lists.",
    other_details: {
      type: "programming",
      color: "#a3522f",
      extensions: [".pro", ".dlm"],
      ace_mode: "text",
      codemirror_mode: "idl",
      codemirror_mime_type: "text/x-idl",
      language_id: 161,
    },
    id: "9y6k",
  },
  {
    name: "Idris",
    description:
      'Hume combines functional programming ideas with ideas from finite state automata. Automata are used to structure communicating programs into a series of "boxes", where each box maps inputs to outputs in a purely functional way using high-level pattern-matching. It is structured as a series of levels, each of which exposes different machine properties. The Hume language design attempts to maintain the essential properties and features required by the embedded systems domain (especially for transparent time and space costing) whilst incorporating as high a level of program abstraction as possible. It aims to target applications ranging from simple micro-controllers to complex real-time systems such as smartphones. This ambitious goal requires incorporating both low-level notions such as interrupt handling, and high-level ones of data structure abstraction etc. Of course such systems will be programmed in widely differing ways, but the language design should accommodate these varying requirements. Hume is a three-layer language: an outer (static) declaration/metaprogramming layer, an intermediate coordination layer describing a static layout of dynamic processes and the associated devices, and an inner layer describing each process as a (dynamic) mapping from patterns to expressions. The inner layer is stateless and purely functional. Rather than attempting to apply cost modeling and correctness proving technology to an existing language framework either directly or by altering a more general language (as with e.g. RTSJ), the approach taken by the Hume designers is to design Hume in such a way that formal models and proofs can definitely be constructed. Hume is structured as a series of overlapping language levels, where each level adds expressibility to the expression semantics, but either loses some desirable property or increases the technical difficulty of providing formal correctness/cost models.',
    other_details: {
      type: "programming",
      color: "#b30000",
      extensions: [".idr", ".lidr"],
      ace_mode: "text",
      tm_scope: "source.idris",
      language_id: 165,
    },
    id: "ZL02",
  },
  {
    name: "HyperTalk",
    description:
      'HyperTalk supported the basic control structures of procedural languages: repeat for/while/until, if/then/else, as well as function and message "handler" calls (a function handler was a subroutine and a message handler a procedure). Data types usually did not need to be specified by the programmer; conversion happened transparently in the background between strings and numbers. There were no classes or data structures in the traditional sense; in their place were special string literals, or "lists" of "items" delimited by commas (in later versions the "itemDelimiter" property allowed choosing an arbitrary character). Code execution typically began as a response to an event such as a mouse click on a UI widget. In the late 1980s Apple considered using HyperCard\'s HyperTalk scripting language as the standard language across the company and within its classic Mac OS operating system, as well as for interprocess communication between Apple and non-Apple products. The company did not oppose the development of imitations like SuperCard, but it created the HyperTalk Standards Committee to avoid incompatibility between language variants. The case-insensitive language was initially interpreted, but gained just-in-time compilation with HyperCard 2.0. For most basic operations including mathematical computations, HyperTalk favored natural-language ordering of predicates over the ordering used in mathematical notation. For example, in HyperTalk\'s put assignment command, the variable was placed at the end of the statement: whereas in the more traditional BASIC programming language (and most others), the same would be accomplished by writing:',
    Paradigm: "procedural, event-driven",
    "Designed by": "Dan Winkler",
    Developer: "Apple Computer Inc.",
    "First appeared": "1987",
    id: "WvON",
  },
  {
    name: "Io",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Io-logo.svg/64px-Io-logo.svg.png",
    description:
      "Remarkable features of Io are its minimal size and openness to using external code resources.[citation needed] Io is executed by a small, portable virtual machine. The language was created by Steve Dekorte in 2002, after trying to help a friend, Dru Nelson, with his language, Cel. He found out that he really didn't know much about how languages worked, and set out to write a tiny language to understand the problems better. Io's goal is to explore conceptual unification and dynamic languages, so the tradeoffs tend to favor simplicity and flexibility over performance. In its simplest form, it is composed of a single identifier:",
    Paradigm: "object-oriented prototype-based",
    "Designed by": "Steve Dekorte",
    Developer: "Steve Dekorte, Jonathan Wright, Jeremy Tregunna",
    "First appeared": "2002; 20 years ago",
    "Stable release": "20170906 / August 11, 2017; 4 years ago",
    "Typing discipline": "dynamic, strong",
    Website: "iolanguage.org",
    other_details: {
      type: "programming",
      color: "#a9188d",
      extensions: [".io"],
      interpreters: ["io"],
      ace_mode: "io",
      language_id: 168,
    },
    id: "PeAD",
  },
  {
    name: "Icon",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/d/d1/Panorama_Icon_logo_Mondadori.png",
    description:
      'Icon was designed by Ralph Griswold after leaving Bell Labs where he was a major contributor to the SNOBOL language. SNOBOL was a string-processing language with what would be considered dated syntax by the standards of the early 1970s. After moving to the University of Arizona, he further developed the underlying SNOBOL concepts in SL5, but considered the result to be a failure. This led to the significantly updated Icon, which blends the short but conceptually dense code of SNOBOL-like languages with the more familiar syntax of ALGOL-inspired languages like C or Pascal. Like the languages that inspired it, the primary area of use of Icon is managing strings and textual patterns. String operations often fail, for instance, finding "the" in "world". In most languages, this requires testing and branching to avoid using a non-valid result. In Icon most of these sorts of tests are simply not required, reducing the amount of code written by the programmer. Complex pattern handling can be accomplished in a few lines of terse code, similar to more dedicated languages like Perl but retaining a more function-oriented syntax familiar to users of other ALGOL-like languages. Icon is not object-oriented, but an object-oriented extension called Idol was developed in 1996 which eventually became Unicon. It also inspired other languages, with its simple generators being especially influential; Icon\'s generators were a major inspiration for the Python programming language. The original SNOBOL effort, retroactively known as SNOBOL1, launched in the fall of 1962 at the Bell Labs Programming Research Studies Department. The effort was a reaction to the frustrations of attempting to use the SCL language for polynomial formula manipulation, symbolic integration and studying Markov chains. SCL, written by the department head Chester Lee, was both slow and had a low-level syntax that resulting in volumes of code for even simple projects. After briefly considering the COMIT language, Ivan Polonsky, Ralph Griswold and David Farber, all members of the six-person department, decided to write their own language to solve these problems.',
    Paradigm: "multi-paradigm: structured, text-oriented",
    "Designed by": "Ralph Griswold",
    "First appeared": "1977; 45 years ago",
    "Stable release": "9.5.20 / August 13, 2020; 17 months ago",
    "Typing discipline": "dynamic",
    Website: "www.cs.arizona.edu/icon",
    id: "FRE4",
  },
  {
    name: "J++ (J plus plus)",
    description:
      'Assemblers on other System/360 operating systems through System/370, System/390, and System z, as well as the UNIVAC Series 90 mainframes made by Sperry Corporation, and the BS2000 Mainframes currently made by Fujitsu, inherited and extended its syntax. The latest derived language is known as the IBM High-Level Assembler (HLASM). Programmers utilizing this family of assemblers also refer to them as ALC, (for Assembly Language Coding), or simply "assembler". BAL is also the mnemonic of the "Branch And Link" instruction. The architecture of IBM mainframes has undergone several extensions over the years, including System/360, System/370, System/370 XA, ESA/370, ESA/390, and z/Architecture. Each of these architectures has retained compatibility with most of the features of its predecessor. BAL uses the native instruction set of these machines. It is thus closer to the hardware than third-generation languages such as COBOL. The instruction set consists of the low-level operations supported by the hardware, such as:',
    id: "Xrh4",
  },
  {
    name: "IBM Informix-4GL",
    description:
      'It includes embedded SQL, a report writer language, a form language, and a limited set of imperative capabilities (functions, if and while statements, and supports arrays etc.). The language is particularly close to a natural language and is easy to learn and use. It has two versions of compiler which either produce 1) intermediate byte code for an interpreter (known as the rapid development system), or 2) C Programming Language code for compilation with a C compiler into machine-code (which executes faster, but compiles slower, and executables are bigger). It is specifically designed to run as a client on a network, connected to an IBM Informix database engine service. It has a mechanism for calling C Programming Language functions and conversely, to be called from executing C programs. The RDS version also features an interactive debugger for Dumb terminals. A particular feature is the comprehensive error checking which is built into the final executable and the extremely helpful error messages produced by both compilers and executables. It also features embedded modal statements for changing compiler and executable behaviour (e.g. causing the compiler to include memory structures matching database schema structures and elements, or to continue executing in spite of error conditions, which can be trapped later on). The Informix-4GL project was started in 1985, with Chris Maloney as chief architect. Roy Harrington was in charge of the related Informix Turbo (later renamed Online) engine, which bypassed the "cooked" file system in favour of "raw" disk. A Rapid Application Development Tool called FourGen CASE Tools, was bundled with Informix-4GL from 1989 to 1996. Another flavor of Informix programming-tool was produced, called "NewEra", which supported object-oriented programming and a level of code-compatibility with Informix-4GL. Informix was acquired by IBM in April 2001.',
    "Initial release": "15 February 1986",
    id: "mSyV",
  },
  {
    name: "RPG Report Program Generator",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/IBM_RPG_logo.png/220px-IBM_RPG_logo.png",
    description:
      "The RPG programming language originally was created by IBM for their 1401 systems. They also produced an implementation for the System/360, and it became the primary programming language for their midrange computer product line, (the System/3, System/32, System/34, System/38, System/36 and AS/400). There have also been implementations for the Digital VAX, Sperry Univac BC/7, Univac system 80, Siemens BS2000, Burroughs B700, B1700, Hewlett Packard HP 3000, the ICL 2900 series, Honeywell 6220 and 2020, Four-Phase IV/70 and IV/90 series, Singer System 10 and WANG VS, as well as miscellaneous compilers and runtime environments for Unix-based systems, such as Infinite36 (formerly Unibol 36), and PCs (Baby/400, Lattice-RPG). RPG II applications are still supported under the IBM z/VSE and z/OS operating systems, Unisys MCP, Microsoft Windows and OpenVMS. Originally developed by IBM in 1959, the name Report Program Generator was descriptive of the purpose of the language: generation of reports from data files. FOLDOC accredits Wilf Hey with work at IBM that resulted in the development of RPG. FARGO (Fourteen-o-one Automatic Report Generation Operation) was the predecessor to RPG on the IBM 1401. Both languages were intended to facilitate ease of transition for IBM tabulating machine (Tab) unit record equipment technicians to the then-new computers. Tab machine technicians were accustomed to plugging wires into control panels to implement input, output, control and counter operations (add, subtract, multiply, divide). Tab machines programs were executed by impulses emitted in a machine cycle; hence, FARGO and RPG emulated the notion of the machine cycle with the program cycle. RPG was superior to and rapidly replaced FARGO as the report generator program of choice.",
    Paradigm: "Multi-paradigm",
    Developer: "IBM",
    "First appeared": "1959; 63 years ago",
    "Stable release": "RPG IV version 7 release 4 / October 6, 2020",
    "Typing discipline": "Strong, static",
    OS: "CPF, SSP, OS/400, IBM i, OS/VS1, z/OS, DOS/VSE, VSE/SP, VSE/ESA, z/VSE, VS/9, PRIMOS, OpenVMS, Wang VS, Burroughs MCP, HP MPE, MS-DOS, OS/2, Microsoft Windows",
    id: "BdRe",
  },
  {
    name: "IDL (Interactive Data Language)",
    description:
      "IDL is vectorized, numerical, and interactive, and is commonly used for interactive processing of large amounts of data (including image processing). The syntax includes many constructs from Fortran and some from C. IDL originated from early VMS Fortran, and its syntax still shows its heritage: The findgen function in the above example returns a one-dimensional array of floating point numbers, with values equal to a series of integers starting at 0. Note that the operation in the second line applies in a vectorized manner to the whole 100-element array created in the first line, analogous to the way general-purpose array programming languages (such as APL, J or K) would do it. This example contains a division by zero; IDL will report an arithmetic overflow, and store a NaN value in the corresponding element of the y array (the first one), but the other array elements will be finite. The NaN is excluded from the visualization generated by the plot command.",
    Paradigm: "vector-oriented programming",
    "Designed by": "David Stern",
    Developer: "David Stern & ITT Visual Information Solutions (ITT VIS)",
    "First appeared": "1977",
    "Stable release": "IDL 8.8 / August 2020",
    "Typing discipline": "Dynamic",
    Website: "www.harrisgeospatial.com/Software-Technology/IDL",
    id: "FT7o",
  },
  {
    name: "Idris",
    description:
      "The Idris type system is similar to Agda's, and proofs are similar to Coq's, including tactics (theorem proving functions/procedures) via elaborator reflection. Compared to Agda and Coq, Idris prioritizes management of side effects and support for embedded domain-specific languages. Idris compiles to C (relying on a custom copying garbage collector using Cheney's algorithm) and JavaScript (both browser- and Node.js-based). There are third-party code generators for other platforms, including JVM, CIL, and LLVM. Idris is named after a singing dragon from the 1970s UK children's television program Ivor the Engine. Idris combines a number of features from relatively mainstream functional programming languages with features borrowed from proof assistants. The syntax of Idris shows many similarities with that of Haskell. A hello world program in Idris might look like this:",
    Paradigm: "Functional",
    "Designed by": "Edwin Brady",
    "First appeared": "2007; 15 years ago",
    "Stable release": "1.3.3 / May 24, 2020; 19 months ago",
    "Preview release": "0.5.1 (Idris 2) / September 20, 2021; 3 months ago",
    OS: "Cross-platform",
    License: "BSD",
    "Filename extensions": ".idr, .lidr",
    Website: "idris-lang.org",
    other_details: {
      type: "programming",
      color: "#b30000",
      extensions: [".idr", ".lidr"],
      ace_mode: "text",
      tm_scope: "source.idris",
      language_id: 165,
    },
    id: "gzTG",
  },
  {
    name: "Inform",
    image:
      "https://upload.wikimedia.org/wikipedia/en/4/4c/Inform_7_IDE_Icon.png",
    description:
      "Inform is a programming language and design system for interactive fiction originally created in 1993 by Graham Nelson. Inform can generate programs designed for the Z-code or Glulx virtual machines. Versions 1 through 5 were released between 1993 and 1996. Around 1996, Nelson rewrote Inform from first principles to create version 6 (or Inform 6). Over the following decade, version 6 became reasonably stable and a popular language for writing interactive fiction. In 2006, Nelson released Inform 7 (briefly known as Natural Inform), a completely new language based on principles of natural language and a new set of tools based around a book-publishing metaphor. The Inform compilers translate Inform code to story files for Glulx or Z-code, two virtual machines designed specifically for interactive fiction. Glulx, which can support larger games, is the default. The Z-machine was originally developed by Infocom in 1979 for their interactive fiction titles. Because there is at least one such interpreter for nearly every major and minor platform, this means that the same Z-code file can be run on a multitude of platforms with no alterations. Originally Inform targeted the Z-machine only. Andrew Plotkin created an unofficial version of Inform 6 that was also capable of generating files for Glulx, a virtual machine he had designed to overcome many of the limitations of the several-decades-old Z-machine. Starting with Inform 6.3, released February 29, 2004, Inform 6 has included official support for both virtual machines, based on Andrew Plotkin's work. Early release of Inform 7 did not support Glulx, but in August 2006 Glulx support was released.",
    "Original author(s)": "Graham Nelson",
    "Developer(s)": "Graham Nelson",
    "Stable release": "6M62 / December 24, 2015; 6 years ago ",
    "Operating system": "Microsoft Windows, Mac OS X, Linux, others",
    Type: "Interactive fiction development and play",
    Website: "http://inform7.com/",
    Paradigm: "declarative, procedural",
    "Designed by": "Graham Nelson",
    Developer: "Graham Nelson",
    "First appeared": "2006",
    "Preview release": "6.33 / May 10, 2014 ",
    OS: "Microsoft Windows, Mac OS X, Linux, others",
    License: "Proprietary but freely redistributable or Artistic License 2.0",
    id: "xuyt",
  },
  {
    name: "ISLISP",
    description:
      "The goal of this standards effort was to define a small, core language to help bridge the gap between differing dialects of Lisp. It attempted to accomplish this goal by studying primarily Common Lisp, EuLisp, Le Lisp, and Scheme and standardizing only those features shared between them. ISLISP has these design goals: ISLISP has separate function and variable namespaces (hence it is a Lisp-2). ISLISP's object system, ILOS, is mostly a subset of the Common Lisp Object System (CLOS).",
    Paradigms:
      "Multi-paradigm: functional, procedural, object-oriented, reflective, meta",
    Family: "Lisp",
    "Designed by": "Many",
    Developers: "Many",
    "Implementation language": "C, C#, Go, Java, JavaScript, Lisp",
    Platform: "IA-32, x86-64",
    OS: "Windows, macOS, Linux, BSD, AIX, Solaris, Android, QNX",
    id: "XkNJ",
  },
  {
    name: "J",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/6/65/J_%28programming_language%29_icon.png/64px-J_%28programming_language%29_icon.png",
    description:
      "To avoid repeating the APL special-character problem, J uses only the basic ASCII character set, resorting to the use of the dot and colon as inflections to form short words similar to digraphs. Most such primary (or primitive) J words serve as mathematical symbols, with the dot or colon extending the meaning of the basic characters available. Also, many characters which in other languages often must be paired (such as [] {} \"\" `` or <>) are treated by J as stand-alone words or, when inflected, as single-character roots of multi-character words. J is a very terse array programming language, and is most suited to mathematical and statistical programming, especially when performing operations on matrices. It has also been used in extreme programming and network performance analysis. Like John Backus's languages FP and FL, J supports function-level programming via its tacit programming features. Unlike most languages that support object-oriented programming, J's flexible hierarchical namespace scheme (where every name exists in a specific locale) can be effectively used as a framework for both class-based and prototype-based object-oriented programming.",
    "Designed by": "Kenneth E. Iverson, Roger Hui",
    Developer: "JSoftware",
    "First appeared": "1990; 32 years ago",
    "Stable release": "J903 / 16 December 2021; 30 days ago",
    "Typing discipline": "dynamic",
    OS: "Cross-platform: Windows, Linux, macOS, Android, iOS, Raspberry Pi",
    License: "GPLv3",
    Website: "www.jsoftware.com",
    other_details: {
      type: "programming",
      color: "#9EEDFF",
      extensions: [".ijs"],
      interpreters: ["jconsole"],
      tm_scope: "source.j",
      ace_mode: "text",
      language_id: 172,
    },
    id: "gOyj",
  },
  {
    name: "Visual J#",
    description:
      "J# worked with Java bytecode as well as source so it could be used to transition applications that used third-party libraries even if their original source code was unavailable.[citation needed] It was developed by the Hyderabad-based Microsoft India Development Center at HITEC City in India. The implementation of Java in Visual J++, MSJVM, did not pass Sun's compliance tests leading to a lawsuit from Sun, Java's creator, and creation of J#. Microsoft ceased such support for the MSJVM on December 31, 2007 (later Oracle bought Sun, and with it Java and its trademarks). Microsoft however, officially started distributing Java again in 2021 (though not bundled with Windows or its web browsers as before with J++), i.e. their build of Oracle's OpenJDK, which Microsoft plans to support for at least 6 years, for LTS versions, i.e. to September 2027 for Java 17. Java and J# use the same general syntax but there are non-Java conventions in J# to support the .NET environment. For example, to use .NET \"properties\" with a standard JavaBean class, it is necessary to prefix getter and setter methods with the Javadoc-like annotation: …and change the corresponding private variable name to be different from the suffix of the getXxx/setXxx names[citation needed].",
    Paradigm: "Object-oriented, structured, imperative",
    Developer: "Microsoft",
    "First appeared": "2002; 20 years ago",
    "Stable release": "v2.0 Second Edition / 18 May 2007; 14 years ago",
    Platform: ".NET Framework",
    Website: "msdn2.microsoft.com/en-us/vjsharp/default.aspx",
    id: "c0TY",
  },
  {
    name: "Jess",
    description:
      "The implementation, MSJVM, did not pass Sun's compliance tests leading to a lawsuit from Sun, Java's creator. Microsoft ceased such support for the MSJVM on December 31, 2007 (later Oracle bought Sun, and with it Java and its trademarks). Microsoft however, officially started distributing Java again in 2021 (though not bundled with Windows or its web browsers as before), i.e. their build of Oracle's OpenJDK, which Microsoft plans to support for at least 6 years, for LTS versions, i.e. to September 2027 for Java 17. While J++ conformed to the Java language specification, Microsoft did not implement certain features of the official Sun Java implementation in its Visual J++ product line. Remote Method Invocation (Java RMI) and Java Native Interface (JNI) are such examples. In addition, J++ implemented other extensions that were not part of Sun's Java implementation. The inclusion of callbacks and delegates for event handling further contributed to defining J++ as a completely different language merely based on an already existing design concept. Furthermore, J++ applications did not conform to the same standardized method of accessing the underlying operating system functions as any other Java application under Sun's Java SDK. In Microsoft's implementation, an underlying framework called J/Direct provided a base mechanism that allowed J++ applications to completely circumvent Java's class libraries and API in accessing the underlying operating system. Due to this short-cut around the original Java framework, J++ applications were more efficient in taking advantage of Win32 API functions than Java applications.",
    id: "yluI",
  },
  {
    name: "JCL",
    description:
      "JADE is a proprietary object-oriented software development and deployment platform product from the New Zealand-based Jade Software Corporation, first released in 1996. It consists of the JADE programming language, Integrated development environment and debugger, integrated application server and object database management system. Designed as an end-to-end development environment to allow systems to be coded in one language from the database server down to the clients, it also provides APIs for other languages, including .NET Framework, Java, C/C++ and Web services. Although a free limited licence is available for development, using the JADE platform requires per-process fees to be paid. In syntax, JADE is very similar to Pascal; its syntax is based on the language Modula-2, which was derived from Pascal. While it includes innovations lacking in Pascal or Modula-2, it lacks certain features of other modern object-oriented languages such as C# and Java.",
    id: "T8Be",
  },
  {
    name: "JEAN",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Jonathan_Blow_GDC.jpg/220px-Jonathan_Blow_GDC.jpg",
    description:
      "Jonathan David Blow (born November 3, 1971) is an American video game designer, programmer and Twitch streamer, who is best known as the creator of the independent video games Braid (2008) and The Witness (2016), both of which were released to critical acclaim. From 2001 to 2004, Blow wrote the Inner Product column for Game Developer Magazine. He was the primary host of the Experimental Gameplay Workshop each March at the Game Developers Conference, which has become a premier showcase for new ideas in video games. In addition, Blow was a regular participant in the Indie Game Jam. Blow is also a founding partner of the Indie Fund, an angel investor fund for independent game projects. Blow was born in 1971. His mother was a devout ex-nun. Blow's father, an aerospace engineer manager, worked for the defense contractor TRW. Blow would say in an interview with The Atlantic, \"Early on, I detected that there weren't good examples at home, so I kind of had to figure things out on my own ... I had to adopt a paradigm of self-sufficiency.\" Blow grew up in La Palma until he was 8, then he moved to Rancho Peñasquitos, San Diego, where he attended Mt. Carmel High School[citation needed]. He then studied computer science and creative writing at the University of California, Berkeley and was president of the Computer Science Undergraduate Association for a semester. He left the university in 1994, a semester before he would have graduated.",
    Born: "November 3, 1971 (age 50) San Francisco, California, United States",
    Nationality: "American",
    "Alma mater": "University of California, Berkeley (dropped out)",
    Occupation: "Game designer Programmer",
    Organization: "Thekla, Inc.",
    "Known for": "Braid, The Witness, Jai Language",
    Website: "http://number-none.com/blow",
    id: "U_1w",
  },
  {
    name: "Janus",
    description:
      "Janus is an imperative programming language with a global store (there is no stack or heap allocation). Janus is a reversible programming language, i.e. it supports deterministic forward and backward computation by local inversion. We specify the syntax of Janus using Backus–Naur form. A Janus program is a sequence of one or more variable declarations, followed by a sequence of one or more procedure declarations: Note, Janus as specified in the 2007 paper, allows zero or more variables, but a program that starts with an empty store, produces an empty store. A program that does nothing is trivially invertible, and not interesting in practice.",
    Paradigm: "imperative(procedural), reversible",
    "Designed by":
      "Christopher Lutz, Howard Derby, Tetsuo Yokoyama, and Robert Glück",
    "First appeared": "1982, 2007",
    Website: "http://tetsuo.jp/ref/janus.html",
    id: "Jq18",
  },
  {
    name: "JOVIAL",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/6/66/WarcraftIII.jpg/220px-WarcraftIII.jpg",
    description:
      "Warcraft III: Reign of Chaos is a high fantasy real-time strategy computer video game developed and published by Blizzard Entertainment released in July 2002. It is the second sequel to Warcraft: Orcs & Humans, after Warcraft II: Tides of Darkness, the third game set in the Warcraft fictional universe, and the first to be rendered in three dimensions. An expansion pack, The Frozen Throne, was released in July 2003. Warcraft III is set several years after the events of Warcraft II, and tells the story of the Burning Legion's attempt to conquer the fictional world of Azeroth with the help of an army of the Undead, led by fallen paladin Arthas Menethil. It chronicles the combined efforts of the Human Alliance, Orcish Horde, and Night Elves to stop them before they can corrupt the World Tree. In the game, as in many real-time strategy (RTS) games, players collect resources, train individual units and heroes, and build bases in order to achieve various goals (in single-player mode), or to defeat the enemy player. Four playable factions can be chosen from: Humans, Orcs, (both of which appeared in the previous games) and two new factions: the Night Elves and the Undead. Warcraft III's single-player campaign is laid out similarly to that of StarCraft, and is told through the races in a progressive manner. Players can also play matches against the computer, or against others—using local area networking (LAN) or Blizzard's Battle.net gaming platform. After Warcraft II: Beyond the Dark Portal, the last in the Warcraft II saga, was released in 1996, Blizzard began development of a point-and-click adventure game called Warcraft Adventures: Lord of the Clans, which was supposed to continue the story. Lord of the Clans was canceled in favor of Warcraft III in 1998, which was presented to the public at the European Computer Trade Show in September 1999. The game's design and gameplay was significantly altered during development, with the final game sharing little similarities with the originally presented version (see similarities to StarCraft). The game received acclaim from critics, who praised the game's presentation and multiplayer features. It is considered an influential example of RTS video games. Warcraft III was a commercial success, shipping 4.4 million copies to retail stores, selling over a million within a month. In 2020, Blizzard released a remastered version of both Warcraft III and its expansion, The Frozen Throne, called Warcraft III: Reforged.",
    "Developer(s)": "Blizzard Entertainment",
    "Publisher(s)": "Blizzard Entertainment",
    "Director(s)": "Frank Pearce Jr.",
    "Producer(s)": "Chris Sigaty",
    "Designer(s)": "Rob Pardo",
    "Writer(s)": "Chris Metzen",
    "Composer(s)": "Tracy W. Bush Derek Duke Glenn Stafford",
    Series: "Warcraft",
    "Platform(s)": "Microsoft Windows, Classic Mac OS, Mac OS X",
    Release: "NA: July 3, 2002 EU: July 5, 2002",
    "Genre(s)": "Real-time strategy",
    "Mode(s)": "Single-player, multiplayer",
    id: "O2g4",
  },
  {
    name: "Java",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/3/30/Java_programming_language_logo.svg/121px-Java_programming_language_logo.svg.png",
    description:
      "Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let programmers write once, run anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture. The syntax of Java is similar to C and C++, but has fewer low-level facilities than either of them. The Java runtime provides dynamic capabilities (such as reflection and runtime code modification) that are typically not available in traditional compiled languages. As of 2019, Java was one of the most popular programming languages in use according to GitHub, particularly for client–server web applications, with a reported 9 million developers. Java was originally developed by James Gosling at Sun Microsystems (which has since been acquired by Oracle) and released in 1995 as a core component of Sun Microsystems' Java platform. The original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licenses. As of May 2007, in compliance with the specifications of the Java Community Process, Sun had relicensed most of its Java technologies under the GPL-2.0-only license. Oracle offers its own HotSpot Java Virtual Machine, however the official reference implementation is the OpenJDK JVM which is free open-source software and used by most developers and is the default JVM for almost all Linux distributions. As of October 2021, Java 17 is the latest version. Java 8, 11 and 17 are the current long-term support (LTS) versions. Oracle released the last zero-cost public update for the legacy version Java 8 LTS in January 2019 for commercial use, although it will otherwise still support Java 8 with public updates for personal use indefinitely. Other vendors have begun to offer zero-cost builds of OpenJDK 8 and 11 that are still receiving security and other upgrades. Oracle (and others) highly recommend uninstalling outdated and unsupported versions of Java, because of serious risks due to unresolved security issues. Oracle advises its users to immediately transition to a supported version, such as one of the LTS versions (8, 11, 17).",
    Paradigm:
      "Multi-paradigm: generic, object-oriented (class-based), functional, imperative, reflective, concurrent",
    "Designed by": "James Gosling",
    Developer: "Oracle Corporation",
    "First appeared": "May 23, 1995; 26 years ago",
    "Stable release": "Java SE 17  / 14 September 2021; 4 months ago",
    "Typing discipline": "Static, strong, safe, nominative, manifest",
    "Filename extensions": ".java, .class, .jar, .jmod",
    Website: "oracle.com/java/",
    other_details: {
      type: "programming",
      ace_mode: "java",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-java",
      color: "#b07219",
      extensions: [".java"],
      language_id: 181,
    },
    id: "9B6e",
  },
  {
    name: "JavaFX",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/c/cc/JavaFX_Logo.png/200px-JavaFX_Logo.png",
    description:
      "JavaFX targeted the Rich Internet Application domain (competing with Adobe Flex and Microsoft Silverlight), specializing in rapid development of visually rich applications for the desktop and mobile markets. JavaFX Script works with integrated development environments such as NetBeans, Eclipse and IntelliJ IDEA. JavaFX is released under the GNU General Public License, via the Sun sponsored OpenJFX project. JavaFX Script used to be called F3 for Form Follows Function. F3 was primarily developed by Chris Oliver, who became a Sun employee through their acquisition of SeeBeyond Technology Corporation in September 2005. Its name was changed to JavaFX Script, and it became open sourced at JavaOne 2007. JavaFX 1.0 was released on December 4, 2008. On September 10, 2010 Oracle announced at JavaOne that JavaFX Script would be discontinued, although the JavaFX API would be made available to other languages for the Java Virtual Machine.",
    Developer: "Sun Microsystems",
    "Stable release": "1.2 / June 2, 2009",
    Platform: "Java Runtime Environment",
    OS: "Cross-platform",
    License: "GPL",
    Website: "http://javafx.com/",
    id: "bzDz",
  },
  {
    name: "JavaScript",
    description:
      "JavaScript (/ˈdʒɑːvəˌskrɪpt/), often abbreviated JS, is a programming language that is one of the core technologies of the World Wide Web, alongside HTML and CSS. Over 97% of websites use JavaScript on the client side for web page behavior, often incorporating third-party libraries. All major web browsers have a dedicated JavaScript engine to execute the code on users' devices. JavaScript is a high-level, often just-in-time compiled language that conforms to the ECMAScript standard. It has dynamic typing, prototype-based object-orientation, and first-class functions. It is multi-paradigm, supporting event-driven, functional, and imperative programming styles. It has application programming interfaces (APIs) for working with text, dates, regular expressions, standard data structures, and the Document Object Model (DOM). The ECMAScript standard does not include any input/output (I/O), such as networking, storage, or graphics facilities. In practice, the web browser or other runtime system provides JavaScript APIs for I/O. JavaScript engines were originally used only in web browsers, but are now core components of some servers and a variety of applications. The most popular runtime system for this usage is Node.js.",
    Paradigm:
      "Multi-paradigm: event-driven, functional, imperative, object-oriented programming",
    "Designed by":
      "Brendan Eich of Netscape initially; others have also contributed to the ECMAScript standard",
    "First appeared": "December 4, 1995; 26 years ago",
    "Stable release": "ECMAScript 2021  / June 2021; 7 months ago",
    "Preview release": "ECMAScript 2022  / 22 July 2021; 5 months ago",
    "Typing discipline": "Dynamic, weak, duck",
    "Filename extensions": ".js.cjs.mjs",
    Website:
      "www.ecma-international.org/publications-and-standards/standards/ecma-262/",
    other_details: {
      type: "programming",
      tm_scope: "source.js",
      ace_mode: "javascript",
      codemirror_mode: "javascript",
      codemirror_mime_type: "text/javascript",
      color: "#f1e05a",
      aliases: ["js", "node"],
      extensions: [
        ".js",
        "._js",
        ".bones",
        ".es",
        ".es6",
        ".frag",
        ".gs",
        ".jake",
        ".jsb",
        ".jscad",
        ".jsfl",
        ".jsm",
        ".jss",
        ".mjs",
        ".njs",
        ".pac",
        ".sjs",
        ".ssjs",
        ".xsjs",
        ".xsjslib",
      ],
      filenames: ["Jakefile"],
      interpreters: ["node"],
      language_id: 183,
    },
    id: "yvZG",
  },
  {
    name: "Jess",
    description:
      "Rather than a procedural paradigm, where a single program has a loop that is activated only one time, the declarative paradigm used by Jess continuously applies a collection of rules to a collection of facts by a process called pattern matching. Rules can modify the collection of facts, or they can execute any Java code. It uses the Rete algorithm to execute rules. While CLIPS is licensed as open source, Jess is not open source. JESS is free for educational and government use but a license is required to use JESS for commercial systems. Code examples: Sample code:",
    "Developer(s)": "Sandia National Laboratories",
    "Stable release": "7.1p2 / November 5, 2008; 13 years ago",
    Platform: "Java",
    License: "Closed source / Public Domain",
    Website: "www.jessrules.com",
    id: "AXm7",
  },
  {
    name: "JythonK",
    description:
      "More specifically, the purpose of JCL is to say which programs to run, using which files or devices  for input or output, and at times to also indicate under what conditions to skip a step. There are two distinct IBM Job Control languages: They share some basic syntax rules and a few basic concepts, but are otherwise very different. The VM operating system does not have JCL as such; the CP and CMS components each have command languages. Certain words or phrases used in conjunction to JCL are specific to IBM mainframe technology.",
    id: "BgJC",
  },
  {
    name: "Join Java",
    description:
      "The Join Java extension introduces three new language constructs: Concurrency in most popular programming languages is implemented using constructs such as semaphores and monitors. Libraries are emerging (such as the Java concurrency library JSR-166) that provide higher-level concurrency semantics. Communicating Sequential Processes (CSP), Calculus of Communicating Systems (CCS) and Pi have higher-level synchronization behaviours defined implicitly through the composition of events at the interfaces of concurrent processes. Join calculus, in contrast, has explicit synchronization based on a localized conjunction of events defined as reduction rules. Join semantics try to provide explicit expressions of synchronization without breaching the object-oriented idea of modularization, including dynamic creation and destruction of processes and channels. The Join Java language can express virtually all published concurrency patterns without explicit recourse to low-level monitor calls. In general, Join Java programs are more concise than their Java equivalents. The overhead introduced in Join Java by the higher-level expressions derived from the Join calculus is manageable. The synchronization expressions associated with monitors (wait and notify) which are normally located in the body of methods can be replaced by Join Java expressions (the Join methods) which form part of the method signature. A Join method is defined by two or more Join fragments. A Join method will execute once all the fragments of the Join pattern have been called. If the return type is a standard Java type then the leading fragment will block the caller until the Join pattern is complete and the method has executed. If the return type is of type signal then the leading fragment will return immediately. All trailing fragments are asynchronous so will not block the caller.",
    Paradigm: "Procedural, Reflective",
    "Designed by": "G. Stewart von Itzstein",
    "First appeared": "2000",
    Website: "joinjava.unisa.edu.au",
    id: "Zn5A",
  },
  {
    name: "JOSS",
    description:
      "JOSS was initially implemented on the JOHNNIAC machine at RAND Corporation and put online in 1963. It proved very popular, and the users quickly bogged the machine down. By 1964, a replacement was sought with higher performance. JOHNNIAC was retired in 1966 and replaced by a PDP-6, which ultimately grew to support hundreds of computer terminals based on the IBM Selectric. The terminals used green ink for user input and black for the computer's response. Any command that was not understood elicited the response Eh? or SORRY. The system was highly influential, spawning a variety of ports and offshoots. Some remained similar to the original, like TELCOMP and STRINGCOMP, CAL, CITRAN, ISIS, PIL/I, JEAN (ICT 1900 series), Algebraic Interpretive Dialogue (AID, on PDP-10); while others, such as FOCAL and MUMPS, developed in distinctive directions. It also bears a strong resemblance to the BASIC interpreters found on microcomputers in the 1980s, differing mainly in syntax details. In 1959, Willis Ware wrote a RAND memo on the topic of computing in which he stated future computers would have \"a multiplicity of personal input-output stations, so that many people can interact with the machine at the same time.\" The memo gained the interest of the US Air Force, Rand's primary sponsors, and in 1960, they formed the Information Processor Project to explore this concept, what would soon be known as time-sharing. The project was not specifically about time-sharing, but aimed to improve human-computer interaction overall. The idea at the time was that constant interaction between the user and the computer in a back-and-forth manner would make such interactions more natural. As JOSS director Keith Uncapher later put it: There were two perceptions that I think drove the experiment. One was, from at least 1950, when I joined Rand, there was always a focus in the computer science part of Rand toward smooth user interaction. It was just built into us. We learned it from Gunning. ... all we thought about. The other was, seeing the mathematicians struggling with Marchant calculators, not being able to use JOHNNIAC in its raw form. It was just too hard. They had to learn to be programmers. It was just a frustrating experience for them. We wanted something that would look to them as being a natural way of thinking about an aid to the solution of their problems without very much training, and without any perception of becoming a programmer, because that would have kept them away.",
    Paradigms: "non-structured, procedural, imperative",
    Family: "JOSS",
    "Designed by": "Cliff Shaw",
    Developer: "RAND Corporation",
    "First appeared": "1963; 59 years ago",
    Scope: "Lexical",
    "Implementation language": "assembly language",
    Platform: "JOHNNIAC, PDP-6",
    id: "SEHo",
  },
  {
    name: "Joule",
    description:
      "Joule development started in 1994 at Agorics in Palo Alto, California. It is considered the precursor to the E programming language. Numerals consist of ASCII digits 0–9; identifiers are Unicode sequences of digits, letters, and operator characters that begin with a letter. It is also possible to form identifiers by using Unicode sequences (including whitespace) enclosed by either straight (' ') or standard (‘ ’) single quotes, where the backslash is the escape character. Keywords have to start with a letter, except the • keyword to send information. Operators consist of Unicode sequences of digits, letters, and operator characters, beginning with an operator character. Labels are identifiers followed by a colon (':'). At the root, Joule is an imperative language and because of that a statement-based language. It has a rich expression syntax, which transforms easily to its relational syntax underneath. Complex expressions become separate statements, where the site of the original expression is replaced by a reference to the acceptor of the results channel. Therefore, nested expressions still compute completely concurrently with their embedding statement. An identifiers may name a channel to communicate with the server. If this is the case, it is said to be bound to that channel.",
    Paradigm: "multi-paradigm: object-oriented, distributed, Dataflow",
    "Designed by": "E. Dean Tribble",
    "First appeared": "1996",
    "Typing discipline": "untyped",
    id: "np6y",
  },
  {
    name: "JOVIAL",
    description:
      'JOVIAL was developed as a new "high-order"[citation needed] programming language starting in 1959 by a team at System Development Corporation (SDC) headed by Jules Schwartz to compose software for the electronics of military aircraft. The name JOVIAL is an acronym for Jules\' Own Version of the International Algebraic Language; International Algorithmic Language (IAL) was a name proposed originally for ALGOL 58. According to Schwartz, the language was originally called OVIAL, but this was opposed for various reasons. JOVIAL was then suggested, with no meaning attached to the J. Somewhat jokingly it was suggested that the language be named after Schwartz, since he was the meeting chairperson, and this unofficial name stuck. During the 1960s, JOVIAL was a part of the US Military L-project series, particularly the ITT 465L Strategic Air Command Control System (the Strategic Automated Command and Control System (SACCS) project), due to a lack of real-time computing programming languages available. Some 95 percent of the SACCS project, managed by International Telephone & Telegraph (ITT) with software mainly written by SDC, was written in JOVIAL. The software project took two years and fewer than 1,400 programmer years, less than half of the equivalent time in the SAGE L-project. During the late 1970s and early 1980s, the United States Air Force adopted a standardized central processing unit (CPU), the MIL-STD-1750A, and subsequent JOVIAL programs were built for that processor. Several commercial vendors provided compilers and related programming tools to build JOVIAL for processors such as the MIL-STD-1750A, including Advanced Computer Techniques (ACT), TLD Systems, Proprietary Software Systems (PSS), and others.',
    Paradigms: "Procedural, imperative, structured",
    Family: "ALGOL",
    "Designed by": "System Development Corporation",
    Developer: "Software Engineering Associates",
    "First appeared": "1960; 62 years ago",
    "Typing discipline": "static, strong, safe, structural",
    Scope: "Lexical",
    id: "0_k3",
  },
  {
    name: "Joy",
    description:
      "Joy is unusual among functional programming languages (except for function-level programming languages and some esoteric ones, such as Unlambda) in its lack of a lambda operator, and therefore lack of formal parameters. To illustrate this with a common example, here is how the square function might be defined in an imperative programming language (C): The variable x is a parameter which is replaced by the argument to be squared when the function is called. In a functional language (Scheme), the same function could be defined: This is different in many ways, but it still uses the parameter x in the same way.",
    Paradigm: "multi-paradigm: functional, concatenative, stack-oriented",
    "Designed by": "Manfred von Thun",
    Developer: "Manfred von Thun John Cowan",
    "First appeared": "2001",
    "Stable release": "March 17, 2003 / March 17, 2003",
    "Typing discipline": "strong, dynamic",
    id: "_QOs",
  },
  {
    name: "JScript",
    image: "https://upload.wikimedia.org/wikipedia/en/e/e8/Jscript_icon.gif",
    description:
      'JScript is implemented as an Active Scripting engine. This means that it can be "plugged in" to OLE Automation applications that support Active Scripting, such as Internet Explorer, Active Server Pages, and Windows Script Host. It also means such applications can use multiple Active Scripting languages, e.g., JScript, VBScript or PerlScript. JScript was first supported in the Internet Explorer 3.0 browser released in August 1996. Its most recent version is JScript 9.0, included in Internet Explorer 9. JScript 10.0 is a separate dialect, also known as JScript .NET, which adds several new features from the abandoned fourth edition of the ECMAScript standard. It must be compiled for .NET Framework version 2 or version 4, but static type annotations are optional. As explained by Douglas Crockford in his talk titled The JavaScript Programming Language on YUI Theater,',
    Developer: "Microsoft",
    "First appeared": "1996; 26 years ago",
    "Stable release": "9.0 / March 2011",
    "Typing discipline": "Dynamic, weak, duck",
    OS: "Microsoft Windows",
    "Filename extensions": ".js, .jse, .wsf, .wsc (.htm, .html, .hta, .asp)",
    Website: "msdn.microsoft.com/library/hbxc2t98.aspx",
    id: "Mtwk",
  },
  {
    name: "JScript .NET",
    description:
      "The primary differences between JScript and JScript .NET can be summarized as follows: Firstly, JScript is a scripting language, and as such programs (or more suggestively, scripts) can be executed without the need to compile the code first. This is not the case with the JScript .NET command-line compiler, since this next-generation version relies on the .NET Common Language Runtime (CLR) for execution, which requires that the code be compiled to Common Intermediate Language (CIL), formerly called Microsoft Intermediate Language (MSIL), code before it can be run. Nevertheless, JScript .NET still provides full support for interpreting code at runtime (e.g., via the Function constructor or the eval function) and indeed the interpreter can be exposed by custom applications hosting the JScript .NET engine via the VSA[jargon] interfaces. Secondly, JScript has a strong foundation in Microsoft's ActiveX/COM technologies, and relies primarily on ActiveX components to provide much of its functionality (including database access via ADO, file handling, etc.), whereas JScript .NET uses the .NET Framework to provide equivalent functionality. For backwards-compatibility (or for where no .NET equivalent library exists), JScript .NET still provides full access to ActiveX objects via .NET / COM Interop using both the ActiveXObject constructor and the standard methods of the .NET Type class. Although the .NET Framework and .NET languages such as C# and Visual Basic .NET have seen widespread adoption, JScript .NET has never received much attention, by the media or by developers. It is not supported in Microsoft's premier development tool, Visual Studio .NET. However, ASP.NET supports JScript .NET.",
    Paradigm: "multi-paradigm",
    Developer: "Microsoft Corporation",
    "Typing discipline": "duck, weak, dynamic",
    Platform: ".NET Framework",
    "Filename extension": ".js",
    id: "u4mD",
  },
  {
    name: "Julia",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Julia_Programming_Language_Logo.svg/120px-Julia_Programming_Language_Logo.svg.png",
    description:
      'Julia is a high-level, high-performance, dynamic programming language. While it is a general-purpose language and can be used to write any application, many of its features are well suited for numerical analysis and computational science. Distinctive aspects of Julia\'s design include a type system with parametric polymorphism in a dynamic programming language; with multiple dispatch as its core programming paradigm. Julia supports concurrent, (composable) parallel and distributed computing (with or without using MPI or the built-in corresponding[clarification needed] to "OpenMP-style" threads), and direct calling of C and Fortran libraries without glue code. Julia uses a just-in-time (JIT) compiler that is referred to as "just-ahead-of-time" (JAOT) in the Julia community, as Julia compiles all code (by default) to machine code before running it. Julia is garbage-collected, uses eager evaluation, and includes efficient libraries for floating-point calculations, linear algebra, random number generation, and regular expression matching. Many libraries are available, including some (e.g., for fast Fourier transforms) that were previously bundled with Julia and are now separate. Several development tools support coding in Julia, such as integrated development environments (e.g. Microsoft\'s Visual Studio Code, with extensions available adding Julia support to IDEs, e.g. providing debugging and linting support); with integrated tools, e.g. a profiler (and flame graph support available for the built-in one), debugger, and the Rebugger.jl package "supports repeated-execution debugging"[a] and more.',
    Paradigm:
      "Multi-paradigm: multiple dispatch (primary paradigm), procedural, functional, meta, multistaged",
    "Designed by":
      "Jeff Bezanson, Alan Edelman, Stefan Karpinski, Viral B. Shah",
    Developer:
      "Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors",
    "First appeared": "2012; 10 years ago",
    "Stable release": "1.7.1  / 22 December 2021; 25 days ago",
    "Preview release":
      "1.8.0-DEV with daily updates and 1.7.2 and 1.6.6 being worked on",
    "Typing discipline": "Dynamic, strong, nominative, parametric, optional",
    "Implementation language": "Julia, C, C++, Scheme, LLVM",
    Platform:
      "Tier 1: x86-64, IA-32; CUDA/Nvidia GPUs (for Linux and Windows) Tier 2: 64-bit ARM, 32-bit Windows (64-bit is tier 1) Tier 3: 32-bit ARM, PowerPC, AMD GPUs. Also supports oneAPI/Intel's GPUs and Google's TPUs, and has web browser support (for JavaScript and WebAssembly), and can work in Android. For more details see \"supported platforms\".",
    OS: "Linux, macOS, Windows and FreeBSD",
    License: "MIT (core), GPL v2; a makefile option omits GPL libraries",
    "Filename extensions": ".jl",
    Website: "JuliaLang.org",
    other_details: {
      type: "programming",
      extensions: [".jl"],
      interpreters: ["julia"],
      color: "#a270ba",
      ace_mode: "julia",
      codemirror_mode: "julia",
      codemirror_mime_type: "text/x-julia",
      language_id: 184,
    },
    id: "_JMg",
  },
  {
    name: "Jython",
    image: "https://upload.wikimedia.org/wikipedia/en/e/ea/Jython.png",
    description:
      "Jython is an implementation of the Python programming language designed to run on the Java platform. The implementation was formerly known as JPython until 1999. Jython programs can import and use any Java class. Except for some standard modules, Jython programs use Java classes instead of Python modules. Jython includes almost all of the modules in the standard Python programming language distribution, lacking only some of the modules implemented originally in C. For example, a user interface in Jython could be written with Swing, AWT or SWT. Jython compiles Python source code to Java bytecode (an intermediate language) either on demand or statically. Jython was initially created in late 1997 to replace C with Java for performance-intensive code accessed by Python programs, moving to SourceForge in October 2000. The Python Software Foundation awarded a grant in January 2005. Jython 2.5 was released in June 2009. The most recent release is Jython 2.7.2. It was released on 21 March 2020 and is compatible with Python 2.7.",
    "Initial release": "January 17, 2001; 20 years ago",
    "Stable release": "2.7.2  / 21 March 2020; 21 months ago",
    Repository: "github.com/jython/jython/ ",
    "Written in": "Python and Java",
    "Operating system": "Cross-platform",
    Platform: "Java Virtual Machine",
    Type: "Python Programming Language Interpreter",
    License:
      "Python Software Foundation License (for older releases see License terms)",
    Website: "www.jython.org ",
    id: "mhNO",
  },
  {
    name: "K",
    description:
      "Before developing K, Arthur Whitney had worked extensively with APL, first at I. P. Sharp Associates alongside Ken Iverson and Roger Hui, and later at Morgan Stanley developing financial applications. At Morgan Stanley, Whitney helped to develop A+, a variant of APL, to facilitate migrating APL applications from IBM mainframe computers to a network of Sun workstations. A+ had a smaller set of primitive functions and was designed for speed and to handle large sets of time series data. In 1993, Whitney left Morgan Stanley and developed the first version of the K language. At the same time he formed Kx Systems to commercialize the product and signed an exclusive contract with Union Bank of Switzerland (UBS). For the next four years he developed various financial and trading applications using K for UBS. The contract ended in 1997 when UBS merged with Swiss Bank. In 1998, Kx Systems released kdb+, a database built on K. kdb was an in-memory, column-oriented database and included ksql, a query language with an SQL-like syntax. Since then, several financial products have been developed with K and kdb+. kdb+/tick and kdb+/taq were developed in 2001. kdb+, a 64-bit version of kdb+ was released in 2003 and kdb+/tick and kdb+/taq were released in 2004. kdb+ included Q, a language that merged the functions of the underlying K language and ksql. Whitney released a derivative of K called Shakti in 2018.",
    Paradigm: "array, functional",
    "Designed by": "Arthur Whitney",
    Developer: "Kx Systems",
    "First appeared": "1993; 29 years ago",
    "Typing discipline": "dynamic, strong",
    Website: "kx.com",
    id: "MSWk",
  },
  {
    name: "KRYPTON",
    description:
      "There are three versions of Kaleidoscope which show an evolution from declarative to an increasingly imperative style. Differences between them are as follows. Compare the two code segments, both of which allow a user to drag the level of mercury in a simple graphical thermometer with the mouse. Without constraints: With constraints:",
    id: "XafW",
  },
  {
    name: "Karel the Robot",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/NikiExample.jpg/220px-NikiExample.jpg",
    description:
      "A program in Karel is used to control a simple robot named Karel that lives in an environment consisting of a grid of streets (left-right) and avenues (up-down). Karel understands five basic instructions: move (Karel moves by one square in the direction he is facing), turnLeft (Karel turns 90 ° left), putBeeper (Karel puts a beeper on the square he is standing at), pickBeeper (Karel lifts a beeper off the square he is standing at), and turnoff (Karel switches himself off, the program ends). Karel can also perform boolean queries about his immediate environment, asking whether there is a beeper where he is standing, whether there are barriers next to him, and about the direction he is facing. A programmer can create additional instructions by defining them in terms of the five basic instructions, and by using conditional control flow statements if and while with environment queries, and by using the iterate construct.[citation needed] The following is a simple example of Karel syntax: The language has inspired the development of various clones and similar educational languages. As the language is intended for beginners, localized variants exist in some languages, notably Czech (the programming language was quite popular in Czechoslovakia). The principles of Karel were updated to the object-oriented programming paradigm in a new programming language called Karel++. Karel++ is conceptually based on Karel, but uses a completely new syntax, similar to Java.",
    Paradigm: "procedural",
    "Designed by": "Richard E. Pattis",
    "First appeared": "1981",
    id: "hpJ3",
  },
  {
    name: "KiXtart",
    description:
      "KiXtart is developed by Ruud van Velsen of Microsoft Netherlands. It is now provided as careware. Development started in 1991 to provide login scripting for the Microsoft LAN Manager environment. It has rich built-in functionality for easy scripting and provides access to ADSI, ADO, WMI, etc. The language can be used to display information, set environment variables, start programs, connect to network drives, read or edit the registry, change the current drive and directory, and much more. With KiXforms, the user can create a GUI for KiXtart. Read the Windows product ID",
    "Developer(s)": "Ruud van Velsen",
    "Initial release": "1991; 31 years ago",
    "Stable release": "4.67 / October 10, 2016; 5 years ago",
    "Operating system": "Microsoft Windows",
    Type: "Scripting language Automation",
    License: "Closed source Careware",
    Website: "KiXtart.org",
    id: "EDnS",
  },
  {
    name: "Ladder",
    description:
      "For input and output, the Klerer–May system used a Friden Flexowriter modified to allow half-line motions for subscripts and superscripts. The character set included digits, upper-case letters, subsets of 14 lower-case Latin letters and 18 Greek letters, arithmetic operators (+ − × / |) and punctuation (. , ( )), and eight special line-drawing characters (resembling ╲ ╱ ⎜ _ ⎨ ⎬ ˘ ⁔) used to construct multi-line brackets and symbols for summation, products, roots, and for multi-line division or fractions. The system was intended to be forgiving of input mistakes, and easy to learn; its reference manual was only two pages. The system was developed by Melvin Klerer and Jack May at Columbia University's Hudson Laboratories in Dobbs Ferry, New York, for the Office of Naval Research, and ran on GE-200 series computers.   This typography-related article is a stub. You can help Wikipedia by expanding it.",
    id: "ex3v",
  },
  {
    name: "LANSA",
    description:
      "KIF has a declarative semantics. It is meant to describe facts about the world rather than processes or procedures. Knowledge can be described as objects, functions, relations, and rules. It is a formal language, i.e., it can express arbitrary statements in first order logic and can support reasoners that can prove the consistency of a set of KIF statements. KIF also supports non-monotonic reasoning. KIF was created by Michael Genesereth, Richard Fikes and others participating in the DARPA knowledge sharing Effort. Although the original KIF group intended to submit to a formal standards body, that did not occur. A later version called Common Logic has since been developed for submission to ISO and has been approved and published. A variant called SUO-KIF is the language in which the Suggested Upper Merged Ontology is written. A practical application of the Knowledge interchange format is an agent communication language in a multi-agent system.  ",
    id: "1ss7",
  },
  {
    name: "Kojo",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/f/fe/Kojo_Logo_with_overlapping_pentagons.png",
    description:
      "Kojo is a programming language and integrated development environment (IDE) for computer programming and learning. It has many different features that enable playing, exploring, creating, and learning in the areas of computer programming, mental skills, (interactive) math, graphics, art, music, science, animation, games, and electronics. Kojo draws ideas from the programming languages Logo and Processing. Kojo is open-source software. It was created, and is actively developed, by Lalit Pant, a computer programmer and teacher living in Dehradun, India. Kojo provides domain-specific languages (DSLs) for its different areas of learning, and as such can be considered an educational programming language. Kojo is written in, and its approach is based on, the programming language Scala, where users begin with a simple subset of the language and progress in steps. Its graphical user interface is based on Java Swing; a former version was based on the Java NetBeans platform. Lalit chose Scala as the underlying language for Kojo because of its low barrier to entry and potential power.",
    Paradigm: "object-oriented, functional",
    "Designed by": "Lalit Pant",
    "First appeared": "2010; 12 years ago",
    "Stable release": "2.9.14 / 7 November 2021; 2 months ago",
    "Typing discipline": "strong",
    Platform: "x86",
    OS: "Cross-platform: Linux, macOS, Windows",
    License: "GPL",
    "Filename extensions": ".scala, .kojo",
    Website: "www.kogics.net/kojo",
    id: "XQQ5",
  },
  {
    name: "Kotlin",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Kotlin_logo_2021.svg/180px-Kotlin_logo_2021.svg.png",
    description:
      "Kotlin (/ˈkɒtlɪn/) is a cross-platform, statically typed, general-purpose programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library, but type inference allows its syntax to be more concise. Kotlin mainly targets the JVM, but also compiles to JavaScript (e.g., for frontend web applications using React) or native code via LLVM (e.g., for native iOS apps sharing business logic with Android apps). Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark. On 7 May 2019, Google announced that the Kotlin programming language is now its preferred language for Android app developers. Since the release of Android Studio 3.0 in October 2017, Kotlin has been included as an alternative to the standard Java compiler. The Android Kotlin compiler produces Java 8 bytecode by default (which runs in any later JVM), but lets the programmer choose to target Java 9 up to 16, for optimization, or allows for more features; has bidirectional record class interoperability support for JVM, introduced in Java 16, considered stable as of Kotlin 1.5. Kotlin support for compilation directly to JavaScript (i.e., the classic back-end) is considered stable since version 1.3, while the new Kotlin/JS(IR) is in beta as of version 1.5.30. The new optimized implementations of Kotlin/JVM(IR) and Kotlin/JS (IR-based) were introduced in version 1.4. Kotlin/JVM(IR) is considered stable and enabled by default since version 1.5. Kotlin/Native (for e.g. Apple silicon support) is considered beta since version 1.3. In July 2011, JetBrains unveiled Project Kotlin, a new language for the JVM, which had been under development for a year. JetBrains lead Dmitry Jemerov said that most languages did not have the features they were looking for, with the exception of Scala. However, he cited the slow compilation time of Scala as a deficiency. One of the stated goals of Kotlin is to compile as quickly as Java. In February 2012, JetBrains open sourced the project under the Apache 2 license.",
    Paradigm:
      "Multi-paradigm: object-oriented, functional, imperative, block structured, declarative, generic, reflective, concurrent",
    "Designed by": "JetBrains",
    Developer: "JetBrains",
    "First appeared": "July 22, 2011; 10 years ago",
    "Stable release": "1.6.10  / 14 December 2021; 32 days ago",
    "Preview release": "build-1.6.20-dev-107 / August 26, 2021; 4 months ago",
    "Typing discipline": "Inferred, static, strong",
    Platform:
      "Android JVM iOS macOS (incl. Apple silicon support) watchOS tvOS Windows Linux JavaScript (Kotlin/JS) WebAssembly LLVM (Kotlin/Native)",
    OS: "Cross-platform",
    License: "Apache License 2.0",
    "Filename extensions": ".kt, .kts, .ktm",
    Website: "kotlinlang.org ",
    other_details: {
      type: "programming",
      color: "#F18E33",
      extensions: [".kt", ".ktm", ".kts"],
      tm_scope: "source.kotlin",
      ace_mode: "text",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-kotlin",
      language_id: 189,
    },
    id: "q5Nm",
  },
  {
    name: "KRL",
    description:
      'KRL was an attempt to produce a language which was nice to read and write for the engineers who had to write programs in it, processed like human memory, so you could have realistic AI programs, had an underlying semantics which was firmly grounded like logic languages, all in one, all in one language. And I think it - again, in hindsight - it just bogged down under the weight of trying to satisfy all those things at once.  "An Overview of KRL, a Knowledge Representation Language", D.G. Bobrow and T. Winograd, Cognitive Sci 1:1 (1977). Daniel G. Bobrow, Terry Winograd, An Overview of KRL, A Knowledge Representation Language, Stanford Artificial Intelligence Laboratory Memo AIM 293, 1976.  ',
    Paradigm: "knowledge representation",
    Developer: "Daniel G. Bobrow and Terry Winograd",
    "First appeared": "1976",
    other_details: {
      type: "programming",
      color: "#28430A",
      extensions: [".krl"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 186,
    },
    id: "AtOq",
  },
  {
    name: "KUKA Robot Language",
    description:
      "Any KRL code consists of two different files with the same name: a permanent data file, with the extension .dat, and a movement command file, with the extension .src. KRL has four basic data types: User can also create custom data types using enumeration. Enumeration and basic data types can be used to create arrays and structures. Motion commands support several types of structures as data formats:",
    "Designed by": "KUKA",
    Developer: "KUKA",
    id: "N1D7",
  },
  {
    name: "Lexico",
    description:
      "There is a whole family of KL-ONE-like systems. One of the innovations that KL-ONE initiated was the use of a deductive classifier, an automated reasoning engine that can validate a frame ontology and deduce new information about the ontology based on the initial information provided by a domain expert. Frames in KL-ONE are called concepts. These form hierarchies using subsume-relations; in the KL-ONE terminology a super class is said to subsume its subclasses. Multiple inheritance is allowed. Actually a concept is said to be well-formed only if it inherits from more than one other concept. All concepts, except the top concept (usually THING), must have at least one super class. In KL-ONE descriptions are separated into two basic classes of concepts: primitive and defined. Primitives are domain concepts that are not fully defined. This means that given all the properties of a concept, this is not sufficient to classify it. They may also be viewed as incomplete definitions. Using the same view, defined concepts are complete definitions. Given the properties of a concept, these are necessary and sufficient conditions to classify the concept. The slot-concept is called roles and the values of the roles are role-fillers. There are several different types of roles to be used in different situations. The most common and important role type is the generic RoleSet that captures the fact that the role may be filled with more than one filler.",
    id: "wQXZ",
  },
  {
    name: "KornShell",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/16/OpenBSD_ksh_Interaction.png/300px-OpenBSD_ksh_Interaction.png",
    description:
      'KornShell, i.e. ksh2020, a "major release for several reasons" (such as removal of EBCDIC support, dropped support for binary plugins written for ksh93u+ and removal of some broken math functions), was released by AT&T, but is not maintained or supported (by AT&T; wasn\'t even on release date). KornShell complies with POSIX.2, Shell and Utilities, Command Interpreter (IEEE Std 1003.2-1992.) Major differences between KornShell and the traditional Bourne shell include: KornShell was originally proprietary software. In 2000 the source code was released under a license particular to AT&T, but since the ksh93q release in early 2005 it has been licensed under the Eclipse Public License. KornShell is available as part of the AT&T Software Technology (AST) Open Source Software Collection. As KornShell was initially only available through a proprietary license from AT&T, a number of free and open source alternatives were created. These include pdksh, mksh, bash, and zsh. The functionality of the original KornShell, ksh88, was used as a basis for the standard POSIX.2, Shell and Utilities, Command Interpreter (IEEE Std 1003.2-1992.)',
    "Original author(s)": "David Korn",
    "Initial release": "1983; 39 years ago",
    "Final release": "2020 / October 10, 2019; 2 years ago",
    "Preview release": "93v- / December 24, 2014; 7 years ago",
    Repository: "github.com/ksh93/ksh",
    "Written in": "C",
    "Operating system":
      "Unix and Unix-like (e.g. Linux and macOS; also works in Windows 10)",
    "Available in": "English",
    Type: "Unix shell",
    License:
      "AT&T KornShell: Eclipse Public License pdksh: Public domain with some ISC-like code mksh: MirOS Licence dtksh: Eclipse Public License with some LGPL",
    Website: "www.kornshell.org",
    "Developer(s)": "Martijn Dekker, community",
    Predecessor: "93u+",
    Licence: "Eclipse Public License",
    id: "t0uq",
  },
  {
    name: "Kodu Game Lab",
    description:
      "Kodu is a visual programming tool which is used to teach basic coding with the use of blocks and pictures. Its design allows it to be accessed by anyone. Kodu is available to download as an Xbox 1 Indie Game. There is also a PC version in an open beta which is available to anyone at their website. Kodu is different from those other projects in several key ways: Kodu Game Lab has also been used as an educational learning tool in selected schools and learning centers.",
    "Initial release": "June 30, 2009; 12 years ago",
    "Stable release": "1.6.11.0 / January 5, 2022; 9 days ago",
    "Written in": "C#",
    "Operating system": "Windows",
    Type: "Visual programming",
    Website: "kodugamelab.com",
    id: "9txw",
  },
  {
    name: "Kivy",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Kivy_logo.png/64px-Kivy_logo.png",
    description:
      "Kivy is the main framework developed by the Kivy organization, alongside Python for Android, Kivy iOS, and several other libraries meant to be used on all platforms. In 2012, Kivy got a $5000 grant from the Python Software Foundation for porting it to Python 3.3. Kivy also supports the Raspberry Pi which was funded through Bountysource. The framework contains all the elements for building an application such as: Kivy is the evolution of the PyMT project, and is recommended for new projects. Here is an example of the Hello world program with just one button:",
    "Developer(s)": "Kivy organization",
    "Initial release": "1 February 2011; 10 years ago",
    "Stable release": "2.0.0 / 10 December 2020; 13 months ago",
    Repository: "github.com/kivy/kivy",
    "Written in": "Python, Cython",
    "Operating system": "Cross-platform",
    Type: "Application framework",
    License: "MIT (Free software)",
    Website: "kivy.org",
    id: "wY5X",
  },
  {
    name: "LabVIEW",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/6/60/LabVIEW_Logo.jpg/300px-LabVIEW_Logo.jpg",
    description:
      'Laboratory Virtual Instrument Engineering Workbench (LabVIEW): 3  is a system-design platform and development environment for a visual programming language from National Instruments. The graphical language is named "G"; not to be confused with G-code. The G dataflow language was originally developed by Labview, LabVIEW is commonly used for data acquisition, instrument control, and industrial automation on a variety of operating systems (OSs), including Microsoft Windows as well as various versions of Unix, Linux, and macOS. The latest versions of LabVIEW are LabVIEW 2021 (released in August 2021) and LabVIEW NXG 5.1 (released in January 2021). NI released the free for non-commercial use LabVIEW and LabVIEW NXG Community editions on April 28th, 2020. The programming paradigm used in LabVIEW, sometimes called G, is based on data availability. If there is enough data available to a subVI or function, that subVI or function will execute. Execution flow is determined by the structure of a graphical block diagram (the LabVIEW-source code) on which the programmer connects different function-nodes by drawing wires. These wires propagate variables and any node can execute as soon as all its input data become available. Since this might be the case for multiple nodes simultaneously, LabVIEW can execute inherently in parallel.: 1–2  Multi-processing and multi-threading hardware is exploited automatically by the built-in scheduler, which multiplexes multiple OS threads over the nodes ready for execution.',
    "Developer(s)": "National Instruments",
    "Initial release": "1986; 36 years ago",
    "Stable release":
      "LabVIEW NXG 5.1  LabVIEW 2021  / August 2021; 5 months ago",
    "Written in": "C, C++",
    "Operating system": "Cross-platform: Windows, macOS, Linux",
    Type: "Data acquisition, instrument control, test automation, analysis and signal processing, industrial control, embedded system design",
    License: "Proprietary",
    Website: "www.ni.com/labview",
    other_details: {
      type: "programming",
      extensions: [".lvproj"],
      tm_scope: "text.xml",
      ace_mode: "xml",
      codemirror_mode: "xml",
      codemirror_mime_type: "text/xml",
      language_id: 194,
    },
    id: "noJZ",
  },
  {
    name: "LINC",
    description:
      'Ladder logic has evolved into a programming language that represents a program by a graphical diagram based on the circuit diagrams of relay logic hardware. Ladder logic is used to develop software for programmable logic controllers (PLCs) used in industrial control applications. The name is based on the observation that programs in this language resemble ladders, with two vertical rails and a series of horizontal rungs between them. While ladder diagrams were once the only available notation for recording programmable controller programs, today other forms are standardized in IEC 61131-3 (For example, as an alternative to the graphical ladder logic form, there is also a language more like C called Structured text within the IEC 61131-3 standard). Ladder logic is widely used to program PLCs, where sequential control of a process or manufacturing operation is required. Ladder logic is useful for simple but critical control systems or for reworking old hardwired relay circuits. As programmable logic controllers became more sophisticated it has also been used in very complex automation systems. Often the ladder logic program is used in conjunction with an HMI program operating on a computer workstation. The motivation for representing sequential control logic in a ladder diagram was to allow factory engineers and technicians to develop software without additional training to learn a language such as FORTRAN or other general purpose computer language. Development and maintenance were simplified because of the resemblance to familiar relay hardware systems. Implementations of ladder logic may have characteristics, such as sequential execution and support for control flow features, that make the analogy to hardware somewhat inaccurate. Ladder logic can be thought of as a rule-based language rather than a procedural language. A "rung" in the ladder represents a rule. When implemented with relays and other electromechanical devices, the various rules execute simultaneously and immediately. When implemented in a programmable logic controller, the rules are typically executed sequentially by software in a continuous loop, or "scan". By executing the loop fast enough, typically many times per second, the effect of simultaneous and immediate execution is achieved. Proper use of programmable controllers requires an understanding of the limitations of the execution order of rungs.',
    id: "3FCu",
  },
  {
    name: "Lingo",
    description:
      "The LANSA development environment includes: LANSA's high-level development language is called RDML, which is an acronym for Rapid Development and Maintenance Language. RDML is an important part of LANSA's low-code development platform. High-level programming languages like RDML, require less hand-crafting of code (a lower volume of coding) than traditional programming languages. They are therefore often referred to as \"low-code\" development platforms. Development, maintenance and debugging of mobile, web and cloud applications is all in the single RDML language, which then generates the underlying code required for the front end and back end application components. This negates the need for developers to learn the multiple languages typically associated with such development. The LANSA development environment includes a metadata repository which is an enhanced type of data dictionary. The repository is a database that contains data and file definitions, business rules, application templates, and RDML code. The repository stores information about fields (or data elements) in the application including descriptions, column headings, edit codes, visualizations, default values, help text, and prompt programs. It holds information about files and application database including physical files, logical files (or views), relationships, file definition attributes, file validation rules, trigger programs, multilingual definitions, virtual fields, and predetermined join fields. Objects and components used for event-driven Windows applications also reside in the repository.",
    id: "32e6",
  },
  {
    name: "Lasso",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/d/dc/LassoSoft_and_Lasso_Logo.png/220px-LassoSoft_and_Lasso_Logo.png",
    description:
      'Lasso is an application server and server management interface used to develop internet applications and is a general-purpose, high-level programming language. Originally a web datasource connection tool, for Filemaker and later included in Apple Computer\'s FileMaker 4.0 and Claris Homepage as CDML, it has since evolved into a complex language used to develop and serve large-scale internet applications and web pages. Lasso includes a simple template system allowing code to control generation of HTML and other content types. Lasso is object-oriented and every value is an object. It also supports procedural programming through unbound methods. The language uses traits and multiple dispatch extensively. Lasso has a dynamic type system, where objects can be loaded and augmented at runtime, automatic memory management, a comprehensive standard library, and three compiling methodologies: dynamic (comparable to PHP-Python), just-in-time compilation (comparable to Java or .NET Framework), and pre-compiled (comparable to C). Lasso also supports Query Expressions, allowing elements within arrays and other types of sequences to be iterated, filtered, and manipulated using a natural language syntax similar to SQL. Lasso includes full Unicode character support in the standard string object, allowing it to serve and support multi-byte characters such as Japanese and Swedish, and supports transparent UTF-8 conversion when writing string data to the network or file system. Lasso is often used as a scripting language, and also used in a wide range of non-scripting contexts. Lasso code can be packaged into standalone executable programs called "LassoApps", in which folder structures are compiled into single files.',
    Paradigm:
      "Multi-paradigm: structured object-oriented (multi-dis),  imperative: procedural, concurrent, exp-oriented,  Meta: reflective",
    "Designed by": "Kyle Jessup",
    Developer: "LassoSoft Inc.",
    "First appeared": "1995; 27 years ago",
    "Stable release": "9.3.1 / October 23, 2015; 6 years ago",
    "Typing discipline":
      "Dynamic with constraints (strict-hybrid), nominative, duck (hybrid)",
    "Implementation language": "C, Lasso",
    Platform: "Cross-platform",
    OS: "(OS X, Windows, Linux)",
    License: "Proprietary",
    "Filename extensions": ".lasso, .LassoApp",
    Website: "www.lassosoft.com",
    other_details: {
      type: "programming",
      color: "#999999",
      extensions: [".lasso", ".las", ".lasso8", ".lasso9", ".ldml"],
      tm_scope: "file.lasso",
      aliases: ["lassoscript"],
      ace_mode: "text",
      language_id: 195,
    },
    id: "0K0m",
  },
  {
    name: "LIS",
    description:
      'Declarations are represented in LavaPE as tree structures whose subtrees may be collapsed or expanded. The properties of the declared Lava entities can be edited through pop-up dialogs. Although executable code has a traditional text representation in LavaPE, it can be edited only as complete syntactic units, rather than character by character. If you insert a new syntactic construct, it will typically contain "placeholders" (syntactic variables) that can then be replaced by concrete constructs; the latter may in turn contain syntactic variables, etc. LavaPE provides a tool button for every type of syntactic construct, and a button is enabled only if it is syntactically correct to insert the associated construct at the selected place. Further characteristic properties of Lava and LavaPE include the following: Lava is open source software using the GPL license (see also Lava at the Free Software Foundation and at KDE-Apps.org). It currently runs on Microsoft Windows, Linux and Mac OS X platforms.',
    id: "oaZV",
  },
  {
    name: "LISA",
    description:
      "It features a relatively simple instruction set, but can be used to write moderately complex assembly programs, and is a viable target for a C compiler. The language is less complex than x86 assembly but has many features similar to those in more complex languages. These features make it useful for beginning instruction, so it is most often used to teach fundamentals of programming and computer architecture to computer science and computer engineering students. The LC-3 was developed by Yale N. Patt at the University of Texas at Austin and Sanjay J. Patel at the University of Illinois at Urbana–Champaign. Their specification of the instruction set, the overall architecture of the LC-3, and a hardware implementation can be found in the second edition of their textbook. Courses based on the LC-3 and Patt and Patel's book are offered in many computer engineering and computer science departments. The LC-3 specifies a word size of 16 bits for its registers and uses a 16-bit addressable memory with a 216-location address space. The register file contains eight registers, referred to by number as R0 through R7. All of the registers are general-purpose in that they may be freely used by any of the instructions that can write to the register file, but in some contexts (such as translating from C code to LC-3 assembly) some of the registers are used for special purposes. Instructions are 16 bits wide and have 4-bit opcodes. The instruction set defines instructions for fifteen of the sixteen possible opcodes, though some instructions have more than one mode of operation. Individual instructions' execution is regulated by a state machine implemented with a control ROM and microsequencing unit.",
    id: "HFYs",
  },
  {
    name: "Lean",
    description:
      'The Lean project is an open source project, hosted on GitHub. It was launched by Leonardo de Moura at Microsoft Research in 2013. Lean has an interface that differentiates it from other interactive theorem provers. Lean can be compiled to JavaScript and accessed in a web browser. It has native support for Unicode symbols. (These can be typed using LaTeX-like sequences, such as "\\times" for "×".) Lean also has an extensive support for meta-programming. Lean has gotten attention from mathematicians Thomas Hales and Kevin Buzzard. Hales is using it for his project, Formal Abstracts. Buzzard uses it for the Xena project. One of the Xena Project\'s goals is to rewrite every theorem and proof in the undergraduate math curriculum of Imperial College London in Lean. Here is how the natural numbers are defined in Lean.',
    "Developer(s)": "Microsoft Research",
    "Initial release": "2013; 9 years ago",
    "Stable release": "4.0.0-m2 / 2 March 2021; 10 months ago",
    Repository: "github.com/leanprover/lean",
    "Written in": "C++",
    "Operating system": "Cross-platform",
    "Available in": "English",
    Type: "Proof assistant",
    License: "Apache License 2.0",
    Website: "leanprover.github.io",
    other_details: {
      type: "programming",
      extensions: [".lean", ".hlean"],
      ace_mode: "text",
      language_id: 197,
    },
    id: "jI8l",
  },
  {
    name: "Lego Mindstorms",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Lego_Mindstorms_Sound_Finder.jpg/220px-Lego_Mindstorms_Sound_Finder.jpg",
    description:
      'Lego Mindstorms is a hardware and software structure which is produced by Lego for the development of programmable robots based on Lego building blocks. Each version of the system includes a computer Lego brick that controls the system, a set of modular sensors and motors, and Lego parts from the Technic line to create the mechanical systems. There have been five generations of the Mindstorms platform: the original Robotics Invention System, NXT, NXT 2.0, EV3, and Robot Inventor kit. With each platform release, the motor and sensor capabilities are expanded. The one before last system, Lego Mindstorms EV3, was released on 1 September 2013. Some robot competitions used this set, such as the FIRST Lego League (until 2021) and the World Robot Olympiad. In 1985 Seymour Papert, Mitchel Resnick and Stephen Ocko created a company called Microworlds with the intent of developing a construction kit that could be animated by computers for educational purposes.: 14  Papert had previously created the Logo programming language as a tool to "support the development of new ways of thinking and learning",: xiv  and employed "Turtle" robots to physically act out the programs in the real world.: 55–56  As the types of programs created were limited by the shape of the Turtle, the idea came up to make a construction kit that could use Logo commands to animate a creation of the learner\'s own design.: 3  Similar to the "floor turtle" robots used to demonstrate Logo commands in the real world, a construction system that ran Logo commands would also demonstrate them in the real world, but allowing the child to construct their own creations benefitted the learning experience by putting them in control  In considering which construction system to partner with, they wanted a "low floor high ceiling" approach, something that was easy to pick up but very powerful. To this end, they decided to use LEGO bricks due to the system and diversity of pieces, and the Logo language due to the groups familiarity with the software and its ease of use.: 14  LEGO was receptive to collaboration, particularly because its educational division had founding goals very similar to those of the Microworlds company. The collaboration very quickly moved to the newly minted MIT Media lab, where there was an open sharing of ideas.: 14  As a sponsor of the entire lab, LEGO was allowed royalty free rights to mass-produce any technology produced by Papert, Resnick and Ocko\'s group; and was also allowed to send an employee over to assist with research, so they sent engineer Alan Tofte (also spelled Toft) who helped with the design of the programmable brick.: 35 : 74  As another part of the MIT Media Lab was community outreach, so the bricks would be used working with children in schools for both research and educational purposes. The first experiments of combining LEGO and the Logo programming language was called LEGO/Logo and it started in 1985. Similar to the "floor turtles" used to demonstrate Logo commands in the real world, LEGO/Logo used Logo commands to animate Lego creations. It is important that children could build their own machines to program, as they would then care more about their projects and be more willing to explore the mathematical concepts involved in making them move. The LEGO/Logo system allowed children to create their own designs and experiments, offered multiple paths for learning and encouraged a sense of community. First, machines are built out LEGO. The machines are then connected to a computer and programmed in a modified version of Logo. The LEGO/Logo system introduced new types of parts for making creations such as: motors, sensors and lights. The motors and sensors are connected to an interface box which is communicates with a computer. LEGO/Logo would later be commercialized by the LEGO group LEGO tc Logo.: 3  It was observed that using the LEGO/Logo system, children developed a form of knowledge about the physical world that allowed those even without mathematics or verbal skills to solve problems effectively using the system. : 23 ',
    Subject: "Robotics",
    Availability: "1998–",
    id: "jjc3",
  },
  {
    name: "LilyPond",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/LilyPond-logo-with-music.png/107px-LilyPond-logo-with-music.png",
    description:
      "LilyPond is a computer program and file format for music engraving. One of LilyPond's major goals is to produce scores that are engraved with traditional layout rules, reflecting the era when scores were engraved by hand. LilyPond is cross-platform, and is available for several common operating systems; released under the terms of the GNU General Public License, LilyPond is free software and part of the GNU Project. The LilyPond project was started in 1996 by Han-Wen Nienhuys and Jan Nieuwenhuizen, after they decided to abandon work on MPP (MusiXTeX PreProcessor), a project they began collaborating on in 1995. Its name was inspired both by the Rosegarden project and an acquaintance of Nienhuys and Nieuwenhuizen named Suzanne, a name that means lily in Hebrew (שׁוֹשַׁנָּה). LilyPond 1.0 was released on July 31, 1998, highlighting the development of a custom music font, Feta, and the complete separation of LilyPond from MusiXTeX.",
    "Developer(s)":
      "David Kastrup, Werner Lemberg, Han-Wen Nienhuys, Jan Nieuwenhuizen, Carl Sorensen, Janek Warchoł, et al.",
    "Initial release": "1996; 26 years ago",
    "Stable release": "2.22.1  / 25 April 2021",
    "Preview release": "2.23.5  / 28 November 2021",
    Repository: "gitlab.com/lilypond/lilypond ",
    "Written in": "C++, Scheme, Metafont, PostScript, Python",
    "Operating system":
      "Windows 2000 and later Mac OS X 10.4 and later Linux FreeBSD",
    Size: "20–100 MB",
    "Standard(s)": "EPS, MIDI, MusicXML, PDF, PS, SVG",
    "Available in":
      "English, Catalan, Dutch, French, German, Hungarian, Italian, Japanese, Spanish",
    Type: "Music software, scorewriter",
    License: "GPL-3.0-or-later",
    Website: "lilypond.org ",
    other_details: {
      type: "programming",
      extensions: [".ly", ".ily"],
      ace_mode: "text",
      language_id: 200,
    },
    id: "cwDz",
  },
  {
    name: "Limbo",
    description:
      "The Limbo compiler generates architecture-independent object code which is then interpreted by the Dis virtual machine or compiled just before runtime to improve performance. Therefore all Limbo applications are completely portable across all Inferno platforms. Limbo's approach to concurrency was inspired by Hoare's communicating sequential processes (CSP), as implemented and amended in Pike's earlier Newsqueak language and Winterbottom's Alef. Limbo supports the following features: The Dis virtual machine that executes Limbo code is a CISC-like VM, with instructions for arithmetic, control flow, data motion, process creation, synchronizing and communicating between processes, loading modules of code, and support for higher-level data-types: strings, arrays, lists, and communication channels. It uses a hybrid of reference counting and a real-time garbage-collector for cyclic data.",
    Paradigm: "Concurrent",
    "Designed by": "Sean Dorward, Phil Winterbottom, Rob Pike",
    Developer: "Bell Labs / Vita Nuova Holdings",
    "First appeared": "1995; 27 years ago",
    "Typing discipline": "Strong",
    OS: "Inferno",
    License: "Open source",
    Website: "www.vitanuova.com/inferno/limbo.html",
    other_details: {
      type: "programming",
      extensions: [".b", ".m"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 201,
    },
    id: "zosR",
  },
  {
    name: "Logo",
    description:
      'An action is defined by Action-Executer, Action-Data, and Action-Condition. An action has an owner which defines the scope of data available for the action. There are three types of actions: Action data can be a constant, a variable, a method/event parameter, a property of a class/variable/parameter/property, or a math expression. An Action Condition is a math expression evaluated to a Boolean value. A math expression is a math formula with its variables linked to constants, properties, variables, parameters, and math expressions. A math expression must be displayed and edited graphically for codeless and visual programming and for intuitive using of the programming tools. The math expression programming tool must be able to handle math elements and functions developed by third parties to enable unlimited expansions. Limnor Studio is a newer implementation of codeless visual programming by "properties, methods, events and actions".',
    id: "o1e-",
  },
  {
    name: "Logtalk",
    description:
      'LINC was originally developed as a short-cut (or template) by two programmers to reproduce and automate the production of computer applications for different companies, that had similar requirements and specifications. The requirements were similar, because the companies followed a common, generic, business model. That is, these businesses dealt with "commodities", or "parts", or "suppliers", or "customers" (named "components" in LINC terminology). These were "manufactured", or "assembled", or "purchased", or "sold" (actions termed "events" in LINC terminology). These components and events were the "interface specifications" or "ispecs" and contained the database definitions, screen designs, and business rules of the application system. LIRC (Logic and Information Report Compiler) was part of LINC and was developed to allow the programmer to produce reports (e.g. "purchase orders", "invoices", "credit notes", "consignment notes", "bills of sale"). The information in these reports were accessed by using various user-defined views of these components and events called "profiles".',
    other_details: {
      type: "programming",
      extensions: [".lgt", ".logtalk"],
      ace_mode: "text",
      language_id: 210,
    },
    id: "tBov",
  },
  {
    name: "LotusScript",
    description:
      "Lingo is the primary programming language on the Adobe Shockwave platform, which dominated the interactive multimedia product market during the 1990s. Various graphic adventure games were developed with Lingo during the 1990s, including The Journeyman Project, Total Distortion, Mia's Language Adventure, Mia's Science Adventure, and the Didi & Ditto series. Hundreds of free online video games were developed using Lingo, and published on websites such as Miniclip and Shockwave.com. Lingo can be used to build user interfaces, to manipulate raster graphics, vector graphics and 3D computer graphics, and other data processing tasks. Lingo supports specialized syntax for image processing and 3D object manipulation. 3D meshes can also be created on the fly using Lingo. Lingo was invented by John H. Thompson at MacroMind in 1989, and first released with Director 2.2. Jeff Tanner developed and tested Lingo for Director 2.2 and 3.0, created custom XObjects for various media device producers, language extension examples using XFactory including the XFactory application programming interface (API), and wrote the initial tutorials on how to use Lingo. Dave Shields tested and documented Object-based Lingo for Director 3.13 and 4.0. He ran build scripts to create weekly releases for testing, originated the Macromedia KnowledgeBase, created examples of how to write Lingo XTRA plug-ins in C++, and assembled the Golden Master disks of Macromedia Director that were shipped to the duplicator. Lingo was quickly adopted by burgeoning multimedia community during the 1990s and the already popular Director product. Initially, about 90% of the users only used 10% of Lingo's features; primarily go to the frame by multimedia authors of tutorials and presentations. However, 10% of the users were game developers who took a wider interest in the other 90% of its abilities, including their own function extensions by creating their own XFactories/XObjects. The Journeyman Project is a prominent example of this.",
    id: "Z7vk",
  },
  {
    name: "Language Integrated Query",
    description:
      "LINQ extends the language by the addition of query expressions, which are akin to SQL statements, and can be used to conveniently extract and process data from arrays, enumerable classes, XML documents, relational databases, and third-party data sources. Other uses, which utilize query expressions as a general framework for readably composing arbitrary computations, include the construction of event handlers or monadic parsers. It also defines a set of method names (called standard query operators, or standard sequence operators), along with translation rules used by the compiler to translate query syntax expressions into expressions using fluent-style (called method syntax by Microsoft) with these method names, lambda expressions and anonymous types. Many of the concepts that LINQ introduced were originally tested in Microsoft's Cω research project. Ports of LINQ exist for PHP (PHPLinq), JavaScript (linq.js), TypeScript (linq.ts), and ActionScript (ActionLinq), although none are strictly equivalent to LINQ in the .NET inspired languages C#, F# and VB.NET (where it is a part of the language, not an external library, and where it often addresses a wider range of needs).[citation needed] In what follows, the descriptions of the operators are based on the application of working with collections. Many of the operators take other functions as arguments. These functions may be supplied in the form of a named method or anonymous function. The set of query operators defined by LINQ is exposed to the user as the Standard Query Operator (SQO) API. The query operators supported by the API are:",
    "Designed by": "Microsoft Corporation",
    Developer: "Microsoft Corporation",
    "Typing discipline": "Strongly typed",
    Website: "docs.microsoft.com/en-us/dotnet/standard/using-linq",
    id: "yrjz",
  },
  {
    name: "LISA",
    description:
      "LISA has been used to re-implement the hardware of existing processor cores, keeping the binary compatibility with the legacy version, as all software tools did already exist and legacy compiled software images could be executed on the newly created hardware. Another application has been to generate the ISS (instruction set simulator) for RISC processors such the ARM architecture ISSes. LISA is not focused on the modeling of other on-chip components around the processor core itself, such as peripherals, hardware accelerators, buses and memories; Other languages such as SystemC can be used for these. The language has not been yet standardised by IEEE or ISO and is currently owned by RWTH Aachen University, in Germany. LISA was initially developed at Institute for Integrated Signal Processing Systems (ISS) Aachen, belonging to RWTH Aachen University, in Germany. The current official version from RWTH Aachen is LISA 2.0. The language is still in evolution to cover research on processors, including Reconfigurable computing (in LISA 3.0), multi-core, parallel programming.",
    "Designed by": "Vojin Zivojnovic, Stefan Pees, version 1.0",
    "First appeared": "1997, last revised 2007",
    Website: "http://www.ice.rwth-aachen.de/research/tools-projects/lisa/lisa",
    id: "Tr0q",
  },
  {
    name: "Language H",
    description:
      'Language H programs consist of a heading section followed by sets of statements called "chapters." Comments are introduced and terminated by asterisks. It has 84 reserved keywords. Some of them are: READ, PRINT, PUNCH, NUMBER, MAX, BEING, FROM, CHANNEL, DIGIT, STERLING, CHARACTERS, UP, TO, RADICES, QUANTITY, DECIMAL, POINT, INADMISSIBLE, INPUT, CONTROL, ERROR, SEEN-CHARACTER, OPERAND, CALCULATE, HOLD, OFF, ON, SEE, AT, POSITION, PLACES, FILE, GET, AGAIN, WITH, FINISH, REEL-END, UNOBTAINABLE, END-OF-FILE, MARKER, BRANCH, OR, GET-AGAIN, ACCORDING, SEQUENTIAL, FILING, DUMP, DATA, PROCESSING, PROGRAM, FOR, CHAPTER, NOTE, IN, OBEY, AND, ARE, AT, BY, IN, IS   This programming-language-related article is a stub. You can help Wikipedia by expanding it.',
    Paradigm: "procedural",
    "First appeared": "1962",
    id: "xE8o",
  },
  {
    name: "Lisp",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Lisp_logo.svg/120px-Lisp_logo.svg.png",
    description:
      'Lisp was originally created as a practical mathematical notation for computer programs, influenced by (though not originally derived from) the notation of Alonzo Church\'s lambda calculus. It quickly became the favored programming language for artificial intelligence (AI) research. As one of the earliest programming languages, Lisp pioneered many ideas in computer science, including tree data structures, automatic storage management, dynamic typing, conditionals, higher-order functions, recursion, the self-hosting compiler, and the read–eval–print loop. The name LISP derives from "LISt Processor". Linked lists are one of Lisp\'s major data structures, and Lisp source code is made of lists. Thus, Lisp programs can manipulate source code as a data structure, giving rise to the macro systems that allow programmers to create new syntax or new domain-specific languages embedded in Lisp. The interchangeability of code and data gives Lisp its instantly recognizable syntax. All program code is written as s-expressions, or parenthesized lists. A function call or syntactic form is written as a list with the function or operator\'s name first, and the arguments following; for instance, a function f that takes three arguments would be called as (f arg1 arg2 arg3). John McCarthy developed Lisp in 1958 while he was at the Massachusetts Institute of Technology (MIT). McCarthy published its design in a paper in Communications of the ACM in 1960, entitled "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I". He showed that with a few simple operators and a notation for anonymous functions borrowed from Church, one can build a Turing-complete language for algorithms.',
    Paradigm: "Multi-paradigm: functional, procedural, reflective, meta",
    "Designed by": "John McCarthy",
    Developer: "Steve Russell, Timothy P. Hart, and Mike Levin",
    "First appeared": "1958; 64 years ago",
    "Typing discipline": "Dynamic, strong",
    id: "tXO5",
  },
  {
    name: "Lite-C",
    description:
      "Lite-C claims to allow very fast programming with a minimum of code, and easy access to non-programmers. For this, the developer provides a 25-lesson workshop that especially deals with the game and multimedia related objects of the language. Lite-C supports the Windows API and the Component Object Model (COM); therefore OpenGL and DirectX programs can directly be written in lite-C. It has integrated the free A8 rendering engine. The lite-C language and compiler was originally developed in 2007 by Conitec, Inc. for Atari, Inc., with the focus on creating computer games by non-programmers. Since 2010, lite-C is also used for defining automatic trade algorithms in day trading software. Lite-C has the following differences to standard C:",
    Developer: "Atari, Inc",
    "First appeared": "2007",
    "Stable release": "8.45 / February 9, 2014; 7 years ago",
    OS: "Windows XP, Vista, 7, 8",
    License: "free",
    Website: "www.3dgamestudio.de/litec.php",
    id: "9-L_",
  },
  {
    name: "Lucid",
    description:
      "The standard class-based programming model does not specify a mechanism by which to manipulate objects: where Smalltalk uses message passing, Lithe uses syntax-directed translation (SDT). SDT is a method of translating a string into a sequence of actions by attaching on such action to each rule of a grammar. Thus, parsing a string of the grammar produces a sequence of rule applications. Lithe merges SDT with the class model by using classes as the non-terminal alphabet of the grammar. Since the grammar class used by Lithe properly contains all context-free grammars, a wide variety of syntax can be described, and SDT provides a simple way to attach semantics to any such syntax. The package is the unit of program modularity in Lithe. A package is divided into two parts: one that defines classes and another that defines rules. Information hiding is achieved by requiring both export keywords on those rules and classes that are to be seen outside a package and that the source package names be included in the with clause of the consumer package. Programming in Lithe consists of defining rule-action pairs and classes. Take the task of computing the absolute value of a number, for example: After this rule-action pair has been defined, it can be freely used within Lithe source code, for example, the following expression will thereafter be valid:",
    id: "3yaN",
  },
  {
    name: "Ethereum",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Ethereum-icon-purple.svg/220px-Ethereum-icon-purple.svg.png",
    description:
      "Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether (ETH or Ξ) is the native cryptocurrency of the platform. Amongst cryptocurrencies, Ether is second only to Bitcoin in market capitalization. Ethereum was conceived in 2013 by programmer Vitalik Buterin. Additional founders of Ethereum included Gavin Wood, Charles Hoskinson, Anthony Di Iorio and Joseph Lubin. In 2014, development work commenced and was crowdfunded, and the network went live on 30 July 2015. The platform allows anyone to deploy permanent and immutable decentralized applications onto it, with which users can interact. Decentralized finance (DeFi) applications provide a broad array of financial services without the need for typical financial intermediaries like brokerages, exchanges, or banks, such as allowing cryptocurrency users to borrow against their holdings or lend them out for interest. Ethereum also allows for the creation and exchange of NFTs, which are non-interchangeable tokens connected to digital works of art or other real-world items and sold as unique digital property. Additionally, many other cryptocurrencies operate as ERC-20 tokens on top of the Ethereum blockchain and have utilized the platform for initial coin offerings. Ethereum has started implementing a series of upgrades called Ethereum 2.0, which includes a transition to proof of stake and aims to increase transaction throughput using sharding. Ethereum was initially described in a white paper by Vitalik Buterin, a programmer and co-founder of Bitcoin Magazine, in late 2013 with a goal of building decentralized applications. Buterin argued to the bitcoin core developers that Bitcoin and blockchain technology could benefit from other applications besides money and needed a more robust language for application development that could lead to attaching real-world assets, such as stocks and property, to the blockchain. In 2013, Buterin briefly worked with eToro CEO Yoni Assia on the Colored Coins project and drafted its white paper outlining additional use cases for blockchain technology. However, after failing to gain agreement on how the project should proceed, he proposed the development of a new platform with a more robust scripting language—a Turing-complete programming language—that would eventually become Ethereum.",
    "Original author(s)": "Vitalik Buterin Gavin Wood",
    "Developer(s)":
      "Ethereum Foundation, Hyperledger, Nethermind, OpenEthereum, EthereumJS",
    "Initial release": "30 July 2015; 6 years ago",
    "Stable release": "London / 5 August 2021; 5 months ago",
    "Development status": "Active",
    "Software used": "EVM 1 Bytecode",
    "Written in": "Go, Rust, C#, C++, Java, Python",
    "Operating system": "Cross-platform",
    Platform: "x86-64, ARM",
    Size: "991.56 GB (2021-09-30)",
    "Available in": "Multilingual, but primarily English",
    Type: "Distributed computing",
    License: "Open-source licenses",
    "Active hosts": "3,481 nodes (2021-09-30)",
    Website: "ethereum.org",
    id: "Ld9o",
  },
  {
    name: "Logo",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/FarfalladiIvanaNiccolai.jpg/220px-FarfalladiIvanaNiccolai.jpg",
    description:
      'A general-purpose language, Logo is widely known for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on screen or with a small robot termed a turtle. The language was conceived to teach concepts of programming related to Lisp and only later to enable what Papert called "body-syntonic reasoning", where students could understand, predict, and reason about the turtle\'s motion by imagining what they would do if they were the turtle. There are substantial differences among the many dialects of Logo, and the situation is confused by the regular appearance of turtle graphics programs that are named Logo. Logo is a multi-paradigm adaptation and dialect of Lisp, a functional programming language. There is no standard Logo, but UCBLogo has the best facilities for handling lists, files, I/O, and recursion in scripts, and can be used to teach all computer science concepts, as UC Berkeley lecturer Brian Harvey did in his Computer Science Logo Style trilogy. Logo is usually an interpreted language, although compiled Logo dialects (such as Lhogho and Liogo) have been developed. Logo is not case-sensitive but retains the case used for formatting purposes. Logo was created in 1967 at Bolt, Beranek and Newman (BBN), a Cambridge, Massachusetts research firm, by Wally Feurzeig, Cynthia Solomon, and Seymour Papert. Its intellectual roots are in artificial intelligence, mathematical logic and developmental psychology. The first four years of Logo research, development and teaching work was done at BBN. The first implementation of Logo, called Ghost, was written in LISP on a PDP-1. The goal was to create a mathematical land where children could play with words and sentences. Modeled on LISP, the design goals of Logo included accessible power[clarification needed] and informative error messages. The use of virtual Turtles allowed for immediate visual feedback and debugging of graphic programming.',
    Paradigms:
      "Multi-paradigm: functional, educational, procedural, reflective",
    Family: "Lisp",
    "Designed by": "Wally Feurzeig, Seymour Papert, Cynthia Solomon",
    Developer: "Bolt, Beranek and Newman",
    "First appeared": "1967; 55 years ago",
    "Typing discipline": "dynamic",
    id: "k1tR",
  },
  {
    name: "Logtalk",
    description:
      "The Logtalk language implementation is distributed under an open source license and can run using a Prolog implementation (compliant with official and de facto standards) as the back-end compiler. Logtalk aims to bring together the advantages of object-oriented programming and logic programming. Object-orientation emphasizes developing discrete, reusable units of software, while logic programming emphasizes representing the knowledge of each object in a declarative way. As an object-oriented programming language, Logtalk's major features include support for both classes (with optional metaclasses) and prototypes, parametric objects, protocols (interfaces), categories (components, aspects, hot patching), multiple inheritance, public/protected/private inheritance, event-driven programming, high-level multi-threading programming, reflection, and automatic generation of documentation. For Prolog programmers, Logtalk provides wide portability, featuring predicate namespaces (supporting both static and dynamic objects), public/protected/private object predicates, coinductive predicates, separation between interface and implementation, simple and intuitive meta-predicate semantics, lambda expressions, definite clause grammars, term-expansion mechanism, and conditional compilation. It also provides a module system based on de facto standard core module functionality (internally, modules are compiled as prototypes).",
    Paradigm:
      "Logic programming, object-oriented programming, prototype-based programming",
    "Designed by": "Paulo Moura",
    "First appeared": "1998; 24 years ago",
    "Stable release": "3.48.0 / 6 July 2021; 6 months ago",
    OS: "Cross-platform",
    License: "Artistic License 2.0 (2.x) / Apache License 2.0 (3.01.x)",
    Website: "logtalk.org",
    other_details: {
      type: "programming",
      extensions: [".lgt", ".logtalk"],
      ace_mode: "text",
      language_id: 210,
    },
    id: "l5cj",
  },
  {
    name: "FluffOS",
    description:
      'Pensjö had been an avid player of TinyMUD and AberMUD. He wanted to create a world with the flexibility of TinyMUD and the style of AberMUD. Furthermore, he did not want to have sole responsibility for creating and maintaining the game world. He once said, "I didn\'t think I would be able to design a good adventure. By allowing wizards coding rights, I thought others could help me with this." The result was the creation of a new, C-based, object-oriented programming language, LPC, that made it simple for people with minimal programming skills to add elements like rooms, weapons, and monsters to a virtual world. To accomplish his goal, Lennart Augustsson convinced Pensjö to write what today would be called a virtual machine, the LPMud driver. The driver managed the interpretation of LPC code as well as providing basic operating system services to the LPC code. By virtue of this design, Pensjö made it more difficult for common programming errors like infinite loops and infinite recursion made by content builders to harm the overall stability of the server. His choice of an OO approach made it easy for new programmers to concentrate on the task of "building a room" rather than programming logic. Pensjö\'s interest in LPMuds eventually waned in the early 1990s, but by that time LPMud had become one of the most popular forms of MUD.[citation needed] His work has been extended or reverse engineered in a number of projects: Though an LPMud server can be used to implement nearly any style of game, LPMuds are often thought of as having certain common characteristics as a genre, such as a mixture of hack and slash with role-playing, quests as an element of advancement, and "guilds" as an alternative to character classes.',
    "Original author(s)": "Wodan",
    "Developer(s)": "Yucong Sun",
    "Stable release": "v2019",
    Repository: "https://github.com/fluffos/fluffos",
    "Written in": "C++",
    Platform: "Linux, Mac OS X, Windows",
    Type: "MUD driver",
    Website: "www.fluffos.info",
    id: "ktiW",
  },
  {
    name: "Second Life Viewer",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Second_Life_Logo.svg/220px-Second_Life_Logo.svg.png",
    description:
      'Second Life is an on-line multimedia platform that allows people to create an avatar for themselves and have a second life in an online virtual world. Developed and owned by the San Francisco-based firm Linden Lab and launched on June 23, 2003, it saw rapid growth for some years and in 2013 it had approximately one million regular users. Growth eventually stabilized, and by the end of 2017 the active user count had declined to "between 800,000 and 900,000". In many ways, Second Life is similar to massively multiplayer online role-playing games; nevertheless, Linden Lab is emphatic that their creation is not a game: "There is no manufactured conflict, no set objective". The virtual world can be accessed freely via Linden Lab\'s own client software or via alternative third-party viewers. Second Life users, also called residents, create virtual representations of themselves, called avatars, and are able to interact with places, objects and other avatars. They can explore the world (known as the grid), meet other residents, socialize, participate in both individual and group activities, build, create, shop, and trade virtual property and services with one another. The platform principally features 3D-based user-generated content. Second Life also has its own virtual currency, the Linden Dollar, which is exchangeable with real world currency. Second Life is intended for people aged 16 and over, with the exception of 13–15-year-old users, who are restricted to the Second Life region of a sponsoring institution (e.g., a school).',
    "Developer(s)": "Linden Lab",
    "Initial release": "June 23, 2003; 18 years ago",
    "Stable release":
      "2019-11-08T19:37:19.532553 / November 12, 2019; 2 years ago",
    Engine: "Havok (physics engine)",
    Platform: "Linux",
    License: "Proprietary",
    Website: "secondlife.com ",
    id: "xppi",
  },
  {
    name: "LiveCode",
    description:
      'The environment was introduced in 2001. The "Revolution" development system was based on the MetaCard engine technology which Runtime Revolution later acquired from MetaCard Corporation in 2003. The platform won the Macworld Annual Editor\'s Choice Award for "Best Development Software" in 2004. "Revolution" was renamed "LiveCode" in the fall of 2010. "LiveCode" is developed and sold by Runtime Revolution Ltd., based in Edinburgh, Scotland. In March, 2015, the company was renamed "LiveCode Ltd.", to unify the company name with the product. In April 2013 a free/open source version \'LiveCode Community Edition 6.0\' was published after a successful crowdfunding campaign at Kickstarter. The code base was re-licensed and made available as free and open source software with a version in April 2013. LiveCode runs on iOS, Android, OS X, Windows 95 through Windows 10, Raspberry Pi and several variations of Unix, including Linux, Solaris, and BSD. It can be used for mobile, desktop and server/CGI applications. The iOS (iPhone and iPad) version was released in December 2010. The first version to deploy to the Web was released in 2009. It is the most widely used HyperCard/HyperTalk clone,[citation needed] and the only one that runs on all major operating systems. A developer release of v.8 was announced in New York on March 12, 2015. This major enhancement to the product includes a new, separate development language, known as "LiveCode Builder", which is capable of creating new object classes called "widgets". In earlier versions, the set of object classes was fixed, and could be enhanced only via the use of ordinary procedural languages such as C. The new language, which runs in its own IDE, is a departure from the transitional x-talk paradigm in that it permits typing of variables. But the two environments are fully integrated, and apart from the ability to create new objects, development in LiveCode proceeds in the normal way, within the established IDE. A second crowdfunding campaign to Bring HTML5 to LiveCode reached funding goals of nearly US$400,000 on July 31, 2014. LiveCode developer release 8.0 DP4 (August 31, 2015) was the first to include a standalone deployment option to HTML5.',
    "Developer(s)": "LiveCode Ltd.",
    "Initial release": "July 11, 2001; 20 years ago",
    "Stable release": "9.6.4 / August 31, 2021; 4 months ago",
    "Preview release": "9.6.5RC2 / October 25, 2021; 2 months ago",
    Repository: "github.com/livecode/livecode ",
    "Operating system": "macOS, Windows, Linux, Unix, Android, iOS, HTML5",
    Type: "Programming",
    License: "Proprietary, GPL",
    Website: "livecode.com ",
    Paradigm: "Object-oriented",
    Family: "scripting language",
    Developer: "LiveCode, Ltd",
    "First appeared": "1993",
    Platform: "i386, AMD64, ARM",
    OS: "Windows, macOS, Linux, Unix, Raspberry Pi",
    id: "iv9V",
  },
  {
    name: "LiveScript",
    description:
      "LiveScript is an indirect descendant of CoffeeScript. The following hello world program is written in LiveScript, but is also compatible with Coffeescript: While calling a function can be done with empty parens, hello(), LiveScript treats the exclamation mark as a single-character shorthand for function calls with zero arguments: hello! LiveScript introduces a number of other incompatible idioms: At compile time, the LiveScript parser implicitly converts kebab case (dashed variables and function names) to camelcase.",
    Paradigm: "multi-paradigm, functional, object-oriented",
    "Designed by": "Jeremy Ashkenas, Satoshi Murakami, George Zahariev",
    Developer: "Jeremy Ashkenas, Satoshi Murakami, George Zahariev",
    "First appeared": "2011; 11 years ago",
    "Stable release": "LiveScript 1.6.1 / 14 July 2020; 18 months ago",
    "Typing discipline": "dynamic, weak",
    OS: "Cross-platform",
    License: "MIT",
    "Filename extensions": ".ls",
    Website: "livescript.net",
    other_details: {
      type: "programming",
      color: "#499886",
      aliases: ["live-script", "ls"],
      extensions: [".ls", "._ls"],
      filenames: ["Slakefile"],
      ace_mode: "livescript",
      codemirror_mode: "livescript",
      codemirror_mime_type: "text/x-livescript",
      language_id: 208,
    },
    id: "LnDp",
  },
  {
    name: "Lua",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Lua-Logo.svg/128px-Lua-Logo.svg.png",
    description:
      "Lua (/ˈluːə/ LOO-ə; from Portuguese: lua [ˈlu.(w)ɐ] meaning moon) is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications. Lua is cross-platform, since the interpreter of compiled bytecode is written in ANSI C, and Lua has a relatively simple C API to embed it into applications. Lua was originally designed in 1993 as a language for extending software applications to meet the increasing demand for customization at the time. It provided the basic facilities of most procedural programming languages, but more complicated or domain-specific features were not included; rather, it included mechanisms for extending the language, allowing programmers to implement such features. As Lua was intended to be a general embeddable extension language, the designers of Lua focused on improving its speed, portability, extensibility, and ease-of-use in development. Lua was created in 1992 by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes, members of the Computer Graphics Technology Group (Tecgraf) at the Pontifical Catholic University of Rio de Janeiro, in Brazil. From 1977 until 1992, Brazil had a policy of strong trade barriers (called a market reserve) for computer hardware and software. In that atmosphere, Tecgraf's clients could not afford, either politically or financially, to buy customized software from abroad. Those reasons led Tecgraf to implement the basic tools it needed from scratch.",
    Paradigm:
      "Multi-paradigm: scripting, imperative (procedural, prototype-based, object-oriented), functional",
    "Designed by":
      "Roberto Ierusalimschy Waldemar Celes Luiz Henrique de Figueiredo",
    "First appeared": "1993; 29 years ago",
    "Stable release": "2.0.5 / May 1, 2017; 4 years ago",
    "Typing discipline": "Dynamic, strong, duck",
    "Implementation language": "ANSI C",
    OS: "Cross-platform",
    License: "MIT License",
    "Filename extensions": ".lua",
    Website: "luajit.org",
    "Developer(s)": "Mike Pall",
    Repository: "repo.or.cz/w/luajit-2.0.git",
    "Written in": "C, Lua",
    "Operating system": "see list",
    Type: "Just in time compiler",
    other_details: {
      type: "programming",
      ace_mode: "lua",
      codemirror_mode: "lua",
      codemirror_mime_type: "text/x-lua",
      color: "#000080",
      extensions: [".lua", ".fcgi", ".nse", ".p8", ".pd_lua", ".rbxs", ".wlua"],
      interpreters: ["lua"],
      language_id: 213,
    },
    id: "1DSR",
  },
  {
    name: "Lucid",
    description:
      "pLucid was the first interpreter for Lucid. Lucid uses a demand-driven model for data computation. Each statement can be understood as an equation defining a network of processors and communication lines between them through which data flows. Each variable is an infinite stream of values and every function is a filter or a transformer. Iteration is simulated by 'current' values and 'fby' (read as 'followed by') operator allowing composition of streams. Lucid is based on an algebra of histories, a history being an infinite sequence of data items. Operationally, a history can be thought of as a record of the changing values of a variable, history operations such as first and next can be understood in ways suggested by their names. Lucid was originally conceived as a disciplined, mathematically pure, single-assignment language, in which verification would be simplified. However, the dataflow interpretation has been an important influence on the direction in which Lucid has evolved. In Lucid (and other dataflow languages) an expression that contains a variable that has not yet been bound waits until the variable has been bound, before proceeding. An expression like x + y will wait until both x and y are bound before returning with the output of the expression. An important consequence of this is that explicit logic for updating related values is avoided, which results in substantial code reduction, compared to mainstream languages.",
    Paradigm: "Dataflow",
    "Designed by": "Edward A. Ashcroft William W. Wadge",
    "First appeared": "1976",
    "Typing discipline": "Typeless",
    id: "vWLW",
  },
  {
    name: "Maple",
    description:
      "A Lustre program is a series of node definitions, written as: Where foo is the name of the node, a is the name of the single input of this node and b is the name of the single output. In this example the node foo returns the negation of its input a, which is the expected result. Additional internal variables can be declared as follows: Note: The equations order doesn't matter, the order of lines U = X and Y; and Z = not U; doesn't change the result.",
    id: "Eb1W",
  },
  {
    name: "LYaPAS",
    description:
      "LYaPAS was initially designed especially for non-numeric programming for the Soviet designed and built line of mainframe computers named Ural-1. LYaPAS uses octal numbers. A further refinement of LYaPAS is LYaPAS-M. The development started in the end of 1962, while Zakrevsky was working at the Siberian Physical-Technical Institute (part of Tomsk State University). The first translators were implemented in 1963. The first widely available book about the language was published in Russian (Логический язык для представления алгоритмов синтеза релейных устройств, 1966), which was soon translated and published in English (LYaPAS: a programming language for logic and coding algorithms, 1969). The book contained a collection of articles with full LYaPAS descriptions, some algorithms in the language and descriptions of programming environments for the Ural-1 and M-20 computers which operated at a speed of 100 and 20,000 operations per second, respectively.",
    Paradigms: "Array, functional, structured, modular",
    Family: "APL[citation needed]",
    "Designed by": "Arkady D.Zakrevskij",
    "First appeared": "1964; 58 years ago",
    "Typing discipline": "Dynamic",
    Platform: "Ural-1 mainframe computer",
    id: "88p4",
  },
  {
    name: "MARK-IV (now VISION:BUILDER)",
    description:
      'In 1986 at the University of Rochester Lynx was ported to the Chrysalis operating system running on a BBN Butterfly multiprocessor. M. L. Scott, "The Lynx Distributed Programming Language: Motivation, Design, and Experience," Computer Languages 16:3/4 (1991), pp. 209-233. http://citeseer.ist.psu.edu/scott91lynx.html   This programming-language-related article is a stub. You can help Wikipedia by expanding it.',
    id: "Tgp9",
  },
  {
    name: "Microsoft Power Pivot",
    description:
      'Power Pivot primarily uses DAX (Data Analysis Expressions) as its expression language, although the model can be queried via Multidimensional Expressions (MDX) in a row set expression. DAX expressions allow a user to create measures based on the data model, which can summarize and aggregate millions of rows of table data in seconds. DAX expressions resolve to T-SQL queries in the Formula and Storage Engines that drive the data model, abstracting the more verbose and tedious work of writing formal queries to excel-like formula expressions. Power Pivot uses the SSAS Vertipaq compression engine to hold the data model in memory on the client computer. Practically, this means that Power Pivot is acting as an Analysis Services Server instance on the local workstation. As a result, larger data models may not be compatible with the 32-bit version of Excel. Prior to the release of Power Pivot, Microsoft relied heavily on SQL Server Analysis Services as the engine for its Business Intelligence suite. Power Pivot complements the SQL Server core BI components under the vision of one Business Intelligence Semantic Model (BISM), which aims to integrate on-disk multidimensional analytics previously known as Unified Dimensional Model (UDM), with a more flexible, in-memory "tabular" model. As a self-service BI product, Power Pivot is intended to allow users with no specialized BI or analytics training to develop data models and calculations, sharing them either directly or through SharePoint document libraries.',
    "Developer(s)": "Microsoft",
    "Stable release":
      "Microsoft SQL Server 2012 - Power Pivot for Microsoft Excel 2010 - Service Pack 2 / June 10, 2014",
    "Operating system": "Microsoft Windows",
    Type: "OLAP, Data Mining, Business Intelligence",
    License: "Microsoft EULA",
    id: "zNUT",
  },
  {
    name: "MATLAB",
    description:
      "It is designed purely for pedagogic use, so efficiency and ease of implementation have been far less important in its development than generality and range of application. It was created to play an important role in forming a formal algorithmic foundation for first-year college math students. Based on a multi-layered datatyping scheme, M2001 includes a collection of eight computational types and another of six structured types. Over these two, respectively, collections of mathematical classes and of abstract classes have been built, the latter encompassing the most commonly used abstract data types in computer science: The lower two layers of M2001's typing scheme were based on the earlier experimental called CAT programming language. A modular mathematical programming language By Ronald E. Prather ",
    other_details: {
      type: "programming",
      color: "#e16737",
      aliases: ["octave"],
      extensions: [".matlab", ".m"],
      ace_mode: "matlab",
      codemirror_mode: "octave",
      codemirror_mime_type: "text/x-octave",
      language_id: 225,
    },
    id: "ZrOa",
  },
  {
    name: "m4",
    description:
      "The language was designed by Brian Kernighan and Dennis Ritchie for the original versions of UNIX. It is an extension of an earlier macro processor, m3, written by Ritchie for an unknown AP-3 minicomputer. The macro preprocessor operates as a text-replacement tool. It is employed to re-use text templates, typically in computer programming applications, but also in text editing and text-processing applications. Most users require m4 as a dependency of GNU autoconf. Macro processors became popular when programmers commonly used assembly language. In those early days of programming, programmers noted that much of their programs consisted of repeated text, and they invented simple means for reusing this text. Programmers soon discovered the advantages not only of reusing entire blocks of text, but also of substituting different values for similar parameters. This defined the usage range of macro processors. In the 1960s, an early general-purpose macro processor, M6, was in use at AT&T Bell Laboratories, which was developed by Douglas McIlroy, Robert Morris and Andrew Hall.",
    Paradigm: "macro",
    "Designed by": "Brian Kernighan, Dennis Ritchie",
    "First appeared": "1977; 45 years ago",
    id: "-laG",
  },
  {
    name: "M#",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/c/ca/Msharp_logo.png",
    description:
      'M# (pronounced em sharp) is a code generation tool and a domain-specific language that can be used to create websites and web applications. It can translate entities and page definitions to ASP.NET Web Forms and MVC and C# code which in turn form the user interface and business logic layer of the application. Its main goals are to reduce time of development, increase code quality, and reduce human errors. M# generates codes that is mainly in the C# programming language. Because the "sharp" suffix has been used by a number of other .NET languages, M# followed the same convention. M# uses its own IDE, which is a web-based application for creating ASP.Net WebForms and Visual Studio for Creating ASP.Net MVC projects. Inside the IDE, a user can type, select from suggestions (Intelli-sense), or use the mouse to define the entities or user interface modules. An example would be a form module that has two buttons (Cancel and Save) and displays a Key and a Text field. The Key field is read-only and the Save button adds a content block to the database: ',
    Paradigm:
      "multi-paradigm: structured, object-oriented, event-driven, procedural, meta",
    "Designed by": "Geeks ltd.",
    Developer: "Geeks ltd.",
    "First appeared": "2012",
    "Typing discipline": "static, dynamic",
    License: "proprietary",
    Website: "http://www.msharp.co.uk/",
    id: "hfFO",
  },
  {
    name: "Maude system",
    description:
      "In computer programming, machine code is any low-level programming language, consisting of machine language instructions, which are used to control a computer's central processing unit (CPU). Each instruction causes the CPU to perform a very specific task, such as a load, a store, a jump, or an arithmetic logic unit (ALU) operation on one or more units of data in the CPU's registers or memory. Machine code is a strictly numerical language which is designed to run as fast as possible, and may be considered as the lowest-level representation of a compiled or assembled computer program or as a primitive and hardware-dependent programming language. While it is possible to write programs directly in machine code, managing individual bits and calculating numerical addresses and constants manually is tedious and error-prone. For this reason, programs are very rarely written directly in machine code in modern contexts, but may be done for low level debugging, program patching (especially when assembler source is not available) and assembly language disassembly. The majority of practical programs today are written in higher-level languages or assembly language. The source code is then translated to executable machine code by utilities such as compilers, assemblers, and linkers, with the important exception of interpreted programs,[nb 1] which are not translated into machine code. However, the interpreter itself, which may be seen as an executor or processor performing the instructions of the source code, typically consists of directly executable machine code (generated from assembly or high-level language source code). Machine code is by definition the lowest level of programming detail visible to the programmer, but internally many processors use microcode or optimise and transform machine code instructions into sequences of micro-ops. This is not generally considered to be a machine code.",
    id: "8_0y",
  },
  {
    name: "MAD",
    description:
      "The archives at the Bentley Historical Library of the University of Michigan contain reference materials on the development of MAD and MAD/I, including three linear feet of printouts with hand-written notations and original printed manuals. There are three MAD compilers: While MAD was motivated by ALGOL 58, it does not resemble ALGOL 58 in any significant way. Programs written in MAD included MAIL, RUNOFF, one of the first text processing systems, and several other utilities all under Compatible Time-Sharing System (CTSS). Work was done on a design for a MAD compiler for Multics, but it was never implemented.",
    Paradigm: "Imperative",
    Developer: "Galler, Arden, and Graham",
    "First appeared": "1959",
    OS: "UMES, MTS, CTSS, others",
    id: "ump0",
  },
  {
    name: "MAD",
    description:
      "The archives at the Bentley Historical Library of the University of Michigan contain reference materials on the development of MAD and MAD/I, including three linear feet of printouts with hand-written notations and original printed manuals. There are three MAD compilers: While MAD was motivated by ALGOL 58, it does not resemble ALGOL 58 in any significant way. Programs written in MAD included MAIL, RUNOFF, one of the first text processing systems, and several other utilities all under Compatible Time-Sharing System (CTSS). Work was done on a design for a MAD compiler for Multics, but it was never implemented.",
    Paradigm: "Imperative",
    Developer: "Galler, Arden, and Graham",
    "First appeared": "1959",
    OS: "UMES, MTS, CTSS, others",
    id: "PaLM",
  },
  {
    name: "MaxScript internal language 3D Studio Max",
    description:
      "Magik (Inspirational Magik) was originally introduced in 1990 and has been improved and updated over the years. Its current version is 5.2. In July 2012, Magik developers announced that they were in the process of porting Magik language on the Java virtual machine. The successful porting was confirmed by Oracle Corporation in November of the same year. Magik itself shares some similarities with Smalltalk in terms of its language features and its architecture: the Magik language is compiled into byte codes interpreted by the Magik virtual machine. The Magik virtual machine is available on several platforms including Microsoft Windows, various flavours of Unix and Linux. Magik is console based and code can be modified on the fly even when an application is running. The console can also be used to execute Magik code and to see the results.",
    id: "p37l",
  },
  {
    name: "Magma",
    image: "https://upload.wikimedia.org/wikipedia/commons/e/ee/Magma-logo.png",
    description:
      "Magma is produced and distributed by the Computational Algebra Group within the School of Mathematics and Statistics at the University of Sydney. In late 2006, the book Discovering Mathematics with Magma was published by Springer as volume 19 of the Algorithms and Computations in Mathematics series. The Magma system is used extensively within pure mathematics. The Computational Algebra Group maintain a list of publications that cite Magma, and as of 2010 there are about 2600 citations, mostly in pure mathematics, but also including papers from areas as diverse as economics and geophysics. The predecessor of the Magma system was named Cayley (1982–1993), after Arthur Cayley.",
    "Developer(s)":
      "Computational Algebra Group, School of Mathematics and Statistics, University of Sydney",
    "Stable release": "2.25-5 / 29 April 2020; 20 months ago",
    "Operating system": "Cross-platform",
    Type: "Computer algebra system",
    License: "Cost recovery (non-commercial proprietary)",
    Website: "magma.maths.usyd.edu.au",
    id: "-LZh",
  },
  {
    name: "MDL",
    description:
      'In the poem Völuspá, a dead völva recounts the history of the universe and foretells the future to the disguised god Odin. In doing so, the völva recounts the early days of the universe: Benjamin Thorpe translation: Henry Adams Bellows translation: In stanza 23 of the poem Vafþrúðnismál, the god Odin (disguised as "Gagnráðr") tasks the jötunn Vafþrúðnir with a question about the origins of the Sun and the Moon, whom he describes as journeying over mankind. Vafþrúðnir responds that Mundilfari is the father of both Sól and Máni, and that they must pass through the heavens every day to count the years for mankind:',
    id: "DSt6",
  },
  {
    name: "Maple",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/7/7c/Maple_2016_Core_Screenshots.jpg/300px-Maple_2016_Core_Screenshots.jpg",
    description:
      "Maple's capacity for symbolic computing include those of a general-purpose computer algebra system. For instance, it can manipulate mathematical expressions and find symbolic solutions to certain problems, such as those arising from ordinary and partial differential equations. Maple is developed commercially by the Canadian software company Maplesoft. The name 'Maple' is a reference to the software's Canadian heritage. Users can enter mathematics in traditional mathematical notation. Custom user interfaces can also be created. There is support for numeric computations, to arbitrary precision, as well as symbolic computation and visualization. Examples of symbolic computations are given below. Maple incorporates a dynamically typed imperative-style programming language (resembling Pascal), which permits variables of lexical scope. There are also interfaces to other languages (C, C#, Fortran, Java, MATLAB, and Visual Basic), as well as to Microsoft Excel.",
    "Developer(s)": "Waterloo Maple (Maplesoft)",
    "Initial release": "1982",
    "Stable release": "2021 (10 March 2021; 10 months ago) [±]",
    "Written in": "C, Java, Maple",
    Platform: "Windows (7, 8 and 10), macOS, Linux",
    "Available in":
      "English, Japanese, and limited support in additional languages",
    Type: "Computer algebra system, Numeric computation",
    License: "Proprietary commercial software",
    Website: "www.maplesoft.com/products/Maple/",
    id: "ylPT",
  },
  {
    name: "Mesa",
    description:
      'Originally available on Sperry\'s Univac 1108, implementations now also exist for Windows NT, Sun Solaris and Linux. The GUI on Windows is the most advanced of these. MAPPER (MAintain, Prepare, and Produce Executive Reports)—officially renamed BIS (Business Information Server) but still called MAPPER by many users—began as an internal product. It was developed in Sperry Univac\'s computer factory in Roseville, Minnesota to help the company manage their factory producing computer hardware. It was initially called CRT RPS (Report Processing System), to differentiate it from RPG. Its first external customer was Santa Fe Railway. Besides the Santa Fe, the Kansas City government was an early customer. MAPPER became a popular solution in the Government sector. User group communities formed like the New England MAPPER Users Group. CRT RPS was renamed MAPPER in 1975. Because of its unofficial status it was a low-budget development, and was built for minimum use of resources. It was written in Assember language. Initially it had only limited string manipulation; that has since been corrected. A Macro capability was also subsequently added. The development of the UNIVAC 1100, and pressure from customers led to a release for more general use in 1979. In the mid 1980s Sperry actively marketed MAPPER, including advertising featuring "MAPPER Man", the self-empowered executive end-user. In the Scandinavian countries, Sperry had a MAPPER song—"Do it the MAPPER way!" (1983)—written and performed by an ABBA-style group.',
    id: "HDWf",
  },
  {
    name: "MHEG-5 (Interactive TV programming language)",
    description:
      "MARK IV was developed for IBM Systems (360 and 370) and for the RCA Spectra 70. Its main benefit was allowing faster application development on the order of 6 to 10 times faster than doing a system using a 3GL, such as COBOL. MARK IV, being an early 4GL, allowed user development of systems related to business. In a 1971 ad by Informatics, there are several quotes from customers, such as: MARK IV went to Sterling Software in 1985 as part of that company's acquisition of Informatics General. As CA VISION:BUILDER, it became part of the product suite from Computer Associates once that company acquired Sterling Software in 2000. Following the acquisition of Computer Associates by Broadcom Inc in 2018, CA VISION:BUILDER was listed as a legacy product by the new owner.   This database software-related article is a stub. You can help Wikipedia by expanding it.",
    id: "0V4d",
  },
  {
    name: "Mary",
    description:
      "An unusual feature of its syntax was that expressions were constructed using the conventional infix operators, but all of them had the same precedence and evaluation went from left to right unless there were brackets. Assignment had the destination on the right and assignment was considered just another operator. Similar to C, several language features appear to have existed to allow producing reasonably well optimised code, despite a quite primitive code generator in the compiler. These included operators similar to the += et alter in C and explicit register declarations for variables. Notable features: A book describing Mary was printed in 1974 (Fourth and last edition in 1979): Mary Textbook by Reidar Conradi & Per Holager.",
    Paradigm: "imperative",
    Family: "ALGOL",
    Developer: "RUNIT",
    "First appeared": "1971; 51 years ago",
    "Typing discipline": "static, strong",
    OS: "Cross-platform: Kongsberg Våpenfabrikk SM-4, Norsk Data Nord-10/ND-100, Univac-1100 series, ND-100/Sintran-III, i386, SPARC",
    id: "_DH-",
  },
  {
    name: "MATLAB (programming language)",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Matlab_Logo.png/121px-Matlab_Logo.png",
    description:
      'MATLAB (an abbreviation of "MATrix LABoratory") is a proprietary multi-paradigm programming language and numeric computing environment developed by MathWorks. MATLAB allows matrix manipulations, plotting of functions and data, implementation of algorithms, creation of user interfaces, and interfacing with programs written in other languages. Although MATLAB is intended primarily for numeric computing, an optional toolbox uses the MuPAD symbolic engine allowing access to symbolic computing abilities. An additional package, Simulink, adds graphical multi-domain simulation and model-based design for dynamic and embedded systems. As of 2020, MATLAB has more than 4 million users worldwide. MATLAB users come from various backgrounds of engineering, science, and economics. MATLAB was invented by mathematician and computer programmer Cleve Moler. The idea for MATLAB was based on his 1960s PhD thesis. Moler became a math professor at the University of New Mexico and started developing MATLAB for his students as a hobby. He developed MATLAB\'s initial linear algebra programming in 1967 with his one-time thesis advisor, George Forsythe. This was followed by Fortran code for linear equations in 1971.',
    Paradigm:
      "multi-paradigm: functional, imperative, procedural, object-oriented, array",
    "Designed by": "Cleve Moler",
    Developer: "MathWorks",
    "First appeared": "late 1970s",
    "Stable release": "R2021b  / September 22, 2021; 3 months ago",
    "Typing discipline": "dynamic, weak",
    "Filename extensions":
      ".m, .p, .mex*, .mat, .fig, .mlx, .mlapp, .mltbx, .mlappinstall, .mlpkginstall",
    Website: "mathworks.com",
    "Developer(s)": "MathWorks",
    "Initial release": "1984; 38 years ago",
    "Written in": "C/C++, MATLAB",
    "Operating system": "Windows, macOS, and Linux",
    Platform: "IA-32, x86-64",
    Type: "Numerical computing",
    License: "Proprietary commercial software",
    id: "eRH5",
  },
  {
    name: "Microsoft Macro Assembler",
    description:
      'MASM is maintained by Microsoft, but since version 6.12 it has not been sold as a separate product. It is instead supplied with various Microsoft SDKs and C compilers. Recent versions of MASM are included with Microsoft Visual Studio. The earliest versions of MASM date back to 1981. They were sold either as the generic "Microsoft Macro Assembler" for all x86 machines or as the OEM version specifically for IBM PCs. By Version 4.0, the IBM release was dropped. Up to Version 3.0, MASM was also bundled with a smaller companion assembler, ASM.EXE. This was intended for PCs with only 64k of memory and lacked some features of the full MASM, such as the ability to use code macros. MS-DOS versions up to 4.x included Microsoft\'s LINK utility, which was designed to convert intermediate OBJ files generated by MASM and other compilers; however, as users who did not program had no use of the utility, it was moved to their compiler packages. Version 4.0 added support for 286 instructions and also shorthand mnemonics for segment descriptors (.code, .data, etc.). Version 5.0 supported 386 instructions, but it could still only generate real mode executables.',
    "Developer(s)": "Microsoft",
    "Initial release": "1981; 41 years ago",
    "Stable release": "14.16.27023.1 / March 7, 2017; 4 years ago",
    "Operating system": "Microsoft Windows and MS-DOS",
    Type: "Assembler",
    License: "Commercial proprietary software",
    Website:
      "docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference",
    id: "QAVn",
  },
  {
    name: "MATH-MATIC",
    description:
      "MATH-MATIC was written beginning around 1955 by a team led by Charles Katz under the direction of Grace Hopper. A preliminary manual was produced in 1957 and a final manual the following year. Syntactically, MATH-MATIC was similar to Univac's contemporaneous business-oriented language, FLOW-MATIC, differing in providing algebraic-style expressions and floating-point arithmetic, and arrays rather than record structures. Expressions in MATH-MATIC could contain numeric exponents, including decimals and fractions, by way of a custom typewriter. MATH-MATIC programs could include inline assembler sections of ARITH-MATIC code and UNIVAC machine code.",
    Paradigm: "imperative",
    "Designed by": "Remington Rand",
    "First appeared": "1957",
    Platform: "UNIVAC I, UNIVAC II",
    id: "1m2Q",
  },
  {
    name: "Milk (programming language)",
    description:
      'Maude is free software, and tutorials are available online. It was originally developed at SRI International, but is now developed by a diverse collaboration of researchers. Maude sets out to solve a different set of problems than ordinary imperative languages like C, Java or Perl. It is a formal reasoning tool, which can help us verify that things are "as they should", and show us why they are not if this is the case. In other words, Maude lets us define formally what we mean by some concept in a very abstract manner (not concerning ourselves with how the structure is internally represented and so on), but we can describe what is thought to be the equal concerning our theory (equations) and what state changes it can go through (rewrite rules). Maude modules (rewrite theories) consist of a term-language plus sets of equations and rewrite-rules. Terms in a rewrite theory are constructed using operators (functions taking 0 or more arguments of some sort, which return a term of a specific sort). Operators taking 0 arguments are considered constants, and one constructs their term-language by these simple constructs. Maude lets the user specify whether or not operators are infix, postfix or prefix (default), this is done using underscores as place fillers for the input terms. Reduction equations are assumed to be confluent and terminating. Rewrite rules do not have this restriction.',
    id: "hAws",
  },
  {
    name: "Maxima",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Maxima-new.svg/64px-Maxima-new.svg.png",
    description:
      'Maxima is based on a 1982 version of Macsyma, which was developed at MIT with funding from the United States Department of Energy and other government agencies. A version of Macsyma was maintained by Bill Schelter from 1982 until his death in 2001. In 1998, Schelter obtained permission from the Department of Energy to release his version under the GPL. That version, now called Maxima, is maintained by an independent group of users and developers. Maxima does not include any of the many modifications and enhancements made to the commercial version of Macsyma during 1982–1999. Though the core functionality remains similar, code depending on these enhancements may not work on Maxima, and bugs which were fixed in Macsyma may still be present in Maxima, and vice versa. Maxima participated in Google Summer of Code in 2019 under International Neuroinformatics Coordinating Facility. Like most computer algebra systems, Maxima supports a variety of ways of reorganizing symbolic algebraic expressions, such as polynomial factorization, polynomial greatest common divisor calculation, expansion, separation into real and imaginary parts, and transformation of trigonometric functions to exponential and vice versa. It has a variety of techniques for simplifying algebraic expressions involving trigonometric functions, roots, and exponential functions. It can calculate symbolic antiderivatives ("indefinite integrals"), definite integrals, and limits. It can derive closed-form series expansions as well as terms of Taylor-Maclaurin-Laurent series. It can perform matrix manipulations with symbolic entries. Maxima is a general-purpose system, and special-case calculations such as factorization of large numbers, manipulation of extremely large polynomials, etc. are sometimes better done in specialized systems. Maxima specializes in symbolic operations, but it also offers numerical capabilities such as arbitrary-precision integer, rational number, and floating-point numbers, limited only by space and time constraints.',
    "Developer(s)": "Macsyma group at Project MAC and volunteer contributors",
    "Initial release": "1982; 40 years ago",
    "Stable release": "5.45.0 / 24 May 2021; 7 months ago",
    Repository: "sourceforge.net/p/maxima/code/ci/master/tree/ ",
    "Written in": "Common Lisp",
    "Operating system": "Cross-platform",
    Type: "Mathematical software",
    License: "GPL",
    Website: "maxima.sourceforge.io",
    id: "FCYq",
  },
  {
    name: "Mirah",
    description:
      "In 1982, Macsyma was licensed to Symbolics and became a commercial product. In 1992, Symbolics Macsyma was spun off to Macsyma, Inc., which continued to develop Macsyma until 1999. That version is still available for Microsoft's Windows XP operating system. The 1982 version of MIT Macsyma remained available to academics and US government agencies, and it is distributed by the US Department of Energy (DOE). That version, DOE Macsyma, was maintained by Bill Schelter. Under the name of Maxima, it was released under the GPL in 1999, and remains under active maintenance. The project was initiated in July, 1968 by Carl Engelman, William A. Martin (front end, expression display, polynomial arithmetic) and Joel Moses (simplifier, indefinite integration: heuristic/Risch). Martin was in charge of the project until 1971, and Moses ran it for the next decade. Engelman and his staff left in 1969 to return to The MITRE Corporation. Some code came from earlier work, notably Knut Korsvold's simplifier. Later major contributors to the core mathematics engine were: Yannis Avgoustis (special functions), David Barton (solving algebraic systems of equations), Richard Bogen (special functions), Bill Dubuque (indefinite integration, limits, power series, number theory, special functions, functional equations, pattern matching, sign queries, Gröbner, TriangSys), Richard Fateman (rational functions, pattern matching, arbitrary precision floating-point), Michael Genesereth (comparison, knowledge database), Jeff Golden (simplifier, language, system), R. W. Gosper (definite summation, special functions, simplification, number theory), Carl Hoffman (general simplifier, macros, non-commutative simplifier, ports to Multics and LispM, system, visual equation editor), Charles Karney (plotting), John Kulp, Ed Lafferty (ODE solution, special functions), Stavros Macrakis (real/imaginary parts, compiler, system), Richard Pavelle (indicial tensor calculus, general relativity package, ordinary and partial differential equations), David A. Spear (Gröbner), Barry Trager (algebraic integration, factoring, Gröbner), Paul S. Wang (polynomial factorization and GCD, complex numbers, limits, definite integration, Fortran and LaTeX code generation), David Y. Y. Yun (polynomial GCDs), Gail Zacharias (Gröbner) and Rich Zippel (power series, polynomial factorization, number theory, combinatorics). Macsyma was written in Maclisp, and was, in some cases, a key motivator for improving that dialect of Lisp in the areas of numerical computing, efficient compilation and language design. Maclisp itself ran primarily on PDP-6 and PDP-10 computers, but also on the Multics OS and on the Lisp Machine architectures. Macsyma was one of the largest, if not the largest, Lisp programs of the time.",
    other_details: {
      type: "programming",
      color: "#c7a938",
      extensions: [".druby", ".duby", ".mirah"],
      tm_scope: "source.ruby",
      ace_mode: "ruby",
      codemirror_mode: "ruby",
      codemirror_mime_type: "text/x-ruby",
      language_id: 232,
    },
    id: "Q5DI",
  },
  {
    name: "Max",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/Logo_Max_8_software.jpg/180px-Logo_Max_8_software.jpg",
    description:
      "The Max program is modular, with most routines existing as shared libraries. An application programming interface (API) allows third-party development of new routines (named external objects). Thus, Max has a large user base of programmers unaffiliated with Cycling '74 who enhance the software with commercial and non-commercial extensions to the program. Because of this extensible design, which simultaneously represents both the program's structure and its graphical user interface (GUI), Max has been described as the lingua franca for developing interactive music performance software. 1980s: Miller Puckette began work on Max in 1985, at the Institut de Recherche et Coordination Acoustique/Musique (IRCAM) in Paris. Originally called The Patcher, this first version provided composers with a graphical interface for creating interactive computer music scores on the Macintosh. At this point in its development Max couldn't perform its own real-time sound synthesis in software, but instead sent control messages to external hardware synthesizers and samplers using MIDI or a similar protocol. Its earliest widely recognized use in composition was for Pluton, a 1988 piano and computer piece by Philippe Manoury; the software synchronized a computer to a piano and controlled a Sogitec 4X for audio processing. In 1989, IRCAM developed Max/FTS (\"Faster Than Sound\"), a version of Max ported to the IRCAM Signal Processing Workstation (ISPW) for the NeXT. Also known as \"Audio Max\", it would prove a forerunner to Max's MSP audio extensions, adding the ability to do real-time synthesis using an internal hardware digital signal processor (DSP) board. The same year, IRCAM licensed the software to Opcode Systems. 1990s: Opcode launched a commercial version named Max in 1990, developed and extended by David Zicarelli. However, by 1997, Opcode was considering cancelling it. Instead, Zicarelli acquired the publishing rights and founded a new company, Cycling '74, to continue commercial development. The timing was fortunate, as Opcode was acquired by Gibson Guitar in 1998 and ended operations in 1999.",
    "Developer(s)": "Cycling '74",
    "Stable release": "7.3.5 / March 8, 2018; 3 years ago",
    "Written in": "C, C++ (on JUCE platform)",
    "Operating system": "Microsoft Windows, macOS",
    Type: "Music and multimedia development",
    License: "Proprietary",
    Website: "cycling74.com/products/max/",
    Paradigm: "visual, flow-based, declarative, domain-specific",
    Developer: "Cycling '74",
    other_details: {
      type: "programming",
      color: "#c4a79c",
      aliases: ["max/msp", "maxmsp"],
      extensions: [".maxpat", ".maxhelp", ".maxproj", ".mxt", ".pat"],
      tm_scope: "source.json",
      ace_mode: "json",
      codemirror_mode: "javascript",
      codemirror_mime_type: "application/json",
      language_id: 227,
    },
    id: "WzG7",
  },
  {
    name: "Autodesk 3ds Max",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/d/d5/Logo_for_3ds_Max.png/250px-Logo_for_3ds_Max.png",
    description:
      'Autodesk 3ds Max, formerly 3D Studio and 3D Studio Max, is a professional 3D computer graphics program for making 3D animations, models, games and images. It is developed and produced by Autodesk Media and Entertainment. It has modeling capabilities and a flexible plugin architecture and must be used on the Microsoft Windows platform. It is frequently used by video game developers, many TV commercial studios, and architectural visualization studios. It is also used for movie effects and movie pre-visualization. For its modeling and animation tools, the latest version[which?] of 3ds Max also features shaders (such as ambient occlusion and subsurface scattering), dynamic simulation, particle systems, radiosity, normal map creation and rendering, global illumination, a customizable user interface, new icons, and its own scripting language. The original 3D Studio product was created for the DOS platform by the Yost Group, and published by Autodesk. The release of 3D Studio made Autodesk\'s previous 3D rendering package AutoShade obsolete. After 3D Studio DOS Release 4, the product was rewritten for the Windows NT platform, and renamed "3D Studio MAX". This version was also originally created by the Yost Group. It was released by Kinetix, which was at that time Autodesk\'s division of media and entertainment. Autodesk purchased the product at the second release update of the 3D Studio MAX version and internalized development entirely over the next two releases. Later, the product name was changed to "3ds max" (all lower case) to better comply with the naming conventions of Discreet, a Montreal-based software company which Autodesk had purchased. When it was re-released (release 7), the product was again branded with the Autodesk logo, and the short name was again changed to "3ds Max" (upper and lower case), while the formal product name became the current "Autodesk 3ds Max".',
    "Developer(s)": "Autodesk",
    "Initial release": "April 1996; 25 years ago (as 3D Studio MAX)",
    "Stable release": "2022 / March 24, 2021; 9 months ago",
    "Operating system": "Windows 7 or later",
    Platform: "x86-64",
    Predecessor: "3D Studio",
    "Available in":
      "English, German, French, Brazilian Portuguese, Japanese, Chinese, Korean",
    Type: "3D computer graphics",
    License: "Software as a service, Trialware",
    Website: "www.autodesk.com/products/3ds-max/overview",
    id: "CQmN",
  },
  {
    name: "ML",
    description:
      "MEL is syntactically similar to Perl and Tcl. It provides some memory management and dynamic array-allocation, and offers direct access to functions specific to Maya. The majority of standard Maya commands are default MEL scripts, saved in the Maya Program Files directory. MEL is fairly limited compared to mainstream scripting languages. Mel is primarily a language meant to journal the Maya session[citation needed], thus lacks many advanced features such as associative arrays. Python was added to Maya as an alternative to MEL in Maya 8.5. Still MEL offers some advantages to Python: MEL is often criticized for its lack of programming features, and object orientation. In practice, however, MEL is used as a metaprogramming language where MEL just instructs Maya's node architecture to solve the problem. Since nodes form the actual computational core of Maya using a more robust readily apparent programming method would be a very inefficient approach. In many ways MEL complements the Maya API, with somewhat clear boundaries between allocated tasks. This makes MEL harder to learn and fully understand. The tools designed using MEL scripts generally come under the following categories:",
    id: "3rJs",
  },
  {
    name: "MDL",
    description:
      "The initial development team consisted of Gerald Sussman and Carl Hewitt of the Artificial Intelligence Lab, and Chris Reeve, Bruce Daniels, and David Cressey of the Dynamic Modeling Group. Later, Stu Galley, also of the Dynamic Modeling Group, wrote the MDL documentation.[citation needed] MDL was initially called Muddle.: 2  This style of self-deprecating humor was not widely understood or appreciated outside of Project MAC and a few other early citadels of information technology. So the name was sanitized to MDL.[citation needed] MDL provides several enhancements to classic Lisp. It supports several built-in data types, including lists, strings and arrays, and user-defined data types. It offers multithreaded expression evaluation and coroutines. Variables can carry both a local value within a scope, and a global value, for passing data between scopes. Advanced built-in functions supported interactive debugging of MDL programs, incremental development, and reconstruction of source programs from object programs. Although MDL is obsolete, some of its features have been incorporated in later versions of Lisp. Gerald Sussman went on to develop the Scheme language, in collaboration with Guy Steele, who later wrote the specifications for Common Lisp and Java. Carl Hewitt had already published the idea for the language Planner before the MDL project began, but his subsequent thinking on Planner reflected lessons learned from building MDL. Planner concepts influenced languages such as Prolog and Smalltalk. Smalltalk and Simula, in turn, influenced Hewitt's future work on the actor model.",
    Paradigms: "Multi-paradigm: functional, procedural, reflective, meta",
    Family: "Lisp",
    "Designed by": "Gerald Sussman, Carl Hewitt, Chris Reeve, Bruce Daniels",
    Developer: "MIT Project MAC",
    "First appeared": "1971; 51 years ago",
    "Final release": "105 / 1980; 42 years ago",
    "Typing discipline": "Dynamic, strong",
    Scope: "Static, lexical",
    "Implementation language": "MDL",
    Platform: "PDP-10, VAX, Apollo/Domain",
    OS: "ITS, TENEX, TOPS-20, BSD, AEGIS",
    License: "Open-source",
    id: "1A8Z",
  },
  {
    name: "Mercury",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/2/21/Mercury_%28programming_language%29_logo.jpg/220px-Mercury_%28programming_language%29_logo.jpg",
    description:
      "Mercury is a purely declarative logic programming language. It is related to both Prolog and Haskell. It features a strong, static, polymorphic type system, and a strong mode and determinism system. The official implementation, the Melbourne Mercury Compiler, is available for most Unix and Unix-like platforms, including Linux, macOS, and for Windows. Mercury is based on the logic programming language Prolog. It has the same syntax and the same basic concepts such as the selective linear definite clause resolution (SLD) algorithm. It can be viewed as a pure subset of Prolog with strong types and modes. As such, it is often compared to its predecessor in features and run-time efficiency. The language is designed using software engineering principles. Unlike the original implementations of Prolog, it has a separate compilation phase, rather than being directly interpreted. This allows a much wider range of errors to be detected before running a program. It features a strict static type and mode system and a module system.",
    Paradigm: "Logic, functional, object-oriented",
    "Designed by": "Zoltan Somogyi",
    Developer: "University of Melbourne",
    "First appeared": "April 8, 1995; 26 years ago",
    "Stable release": "20.06.1 / November 3, 2020; 14 months ago",
    "Typing discipline": "Strong, static, polymorphic",
    "Implementation language": "Mercury",
    Platform: "IA-32, x86-64, ARM, Sparc64, Java, CLI, Erlang/OTP",
    OS: "Cross-platform: Unix, Linux, macOS, Solaris, FreeBSD, OpenBSD, Windows, Android",
    License: "GPL compiler, LGPL standard library",
    "Filename extensions": ".m",
    Website: "www.mercurylang.org",
    other_details: {
      type: "programming",
      color: "#ff2b2b",
      ace_mode: "prolog",
      interpreters: ["mmi"],
      extensions: [".m", ".moo"],
      tm_scope: "source.mercury",
      language_id: 229,
    },
    id: "Fmr_",
  },
  {
    name: "Mesa",
    description:
      'Mesa is a programming language developed in the late 1970s at the Xerox Palo Alto Research Center in Palo Alto, California, United States. The language name was a pun based upon the programming language catchphrases of the time, because Mesa is a "high level" programming language. Mesa is an ALGOL-like language with strong support for modular programming. Every library module has at least two source files: a definitions file specifying the library\'s interface plus one or more program files specifying the implementation of the procedures in the interface. To use a library, a program or higher-level library must "import" the definitions. The Mesa compiler type-checks all uses of imported entities; this combination of separate compilation with type-checking was unusual at the time.[citation needed] Mesa introduced several other innovations in language design and implementation, notably in the handling of software exceptions, thread synchronization, and incremental compilation. Mesa was developed on the Xerox Alto, one of the first personal computers with a graphical user interface, however, most of the Alto\'s system software was written in BCPL. Mesa was the system programming language of the later Xerox Star workstations, and for the GlobalView desktop environment. Xerox PARC later developed Cedar, which was a superset of Mesa.',
    "Designed by": "Computer Systems Laboratory (CSL)",
    Developer: "Xerox PARC",
    "First appeared": "1976; 46 years ago",
    "Stable release": "Mesa 6.0 (Version 41) / July 1981; 40 years ago",
    "Typing discipline": "Strong, static",
    id: "XuIm",
  },
  {
    name: "Modula-2",
    description:
      "MHEG-5 is a licence-free and public standard for interactive TV middleware that is used both to send and receive interactive TV signals. It allows a wide range of TV-centric interactive services to be deployed. It is used by Freeview and Freesat in the UK, Freeview in New Zealand, TVB in Hong Kong, Freeview in Australia, Saorview in Ireland and has been specified in South Africa. Recent[when?] work by the DTG in the UK has led to the development of the MHEG-5 Interaction Channel (MHEG-IC), which enables an extension of broadcast interactive services to be delivered via an IP connection. The principles behind the MHEG-IC are to provide a seamless viewer experience of broadcast delivered content augmented with content delivered over IP as an extension of the channel or network. Broadcasters have full editorial control of the user experience. The MHEG-IC gives access to streamed on-demand video content in addition to traditional text and graphics as well as the ability to support secure transactions. MHEG-5 is an object-based declarative programming language which can be used to describe a presentation of text, images and video. An MHEG-5 application consists of a number of Scenes which the user of the application can move between. Each Scene lists the items of text and graphics to be presented and can contain blocks of procedural code which are executed in response to one of a predefined set of events such as keys being pressed, timers firing or content being successfully loaded into memory. These blocks of code consist of elementary actions which can perform operations such as changing the text displayed by a text object, or starting a video clip playing. MHEG-5 specifies a hierarchy of classes that are available to the application author. Unlike in object oriented languages, it is not possible for new classes to be defined. The standard defines two representations of MHEG applications, one of which is textual and the other is represented in ASN.1. Applications are normally written in the textual notation and then encoded into ASN.1 for interpretation by the MHEG engine.",
    other_details: {
      type: "programming",
      extensions: [".mod"],
      tm_scope: "source.modula2",
      ace_mode: "text",
      language_id: 234,
    },
    id: "lxr8",
  },
  {
    name: "Mohol",
    description:
      "TRON (acronym for The Real-time Operating system Nucleus) is an open architecture real-time operating system kernel design. The project was started by Professor Dr. Ken Sakamura of the University of Tokyo in 1984. The project's goal is to create an ideal computer architecture and network, to provide for all of society's needs. The Industrial TRON (ITRON) derivative was one of the world's most used operating systems in 2003, being present in billions of electronic devices such as mobile phones, appliances and even cars. Although mainly used by Japanese companies, it garnered interest worldwide. However, a dearth of quality English documentation was said to hinder its broader adoption. The TRON project was integrated into T-Engine Forum in 2010. Today, it is supported by popular Secure Socket Layer (SSL) and Transport Layer Security (TLS) libraries such as wolfSSL. TRON does not specify the source code for the kernel, but instead is a \"set of interfaces and design guidelines\" for creating the kernel. This allows different companies to create their own versions of TRON, based on the specifications, which can be suited for different microprocessors.",
    id: "tcVU",
  },
  {
    name: "Microsoft Power Fx",
    description:
      "The programming language was first announced at Ignite 2021 and the specification was released in March 2021. It is based on spreadsheet-like formulas to make it accessible to a large number of people. Power Fx was also influenced by programming languages and tools like Pascal, Mathematica, and Miranda. As Microsoft describes the language, it heavily borrows from the spreadsheet paradigm. In a spreadsheet, cells can contain formulas referring to the contents of other cells, and if the user changes the content of a cell, the values of all dependent cells are automatically updated. In a similar fashion, the various properties of components in a Power Fx program are connected by formulas (whose syntax is very reminiscent of Excel) and their values are automatically updated if changes occur. For instance, a simple formula might connect the color property of some component to the value of a slider component, and if the user moves the slider, the color will automatically change. The Power Fx language was developed by a team at Microsoft led by Vijay Mital, Robin Abraham, Shon Katzenberger and Darryl Rubin. Power Fx is available as Open-source software. The source code was shared under MIT license by Microsoft on November 2. 2021. The documentation only was open source earlier. This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    Paradigm:
      "Low-code, general-purpose, imperative, strongly typed, declarative, functional",
    "Designed by":
      "Vijay Mital, Robin Abraham, Shon Katzenberger, Darryl Rubin",
    Developer: "Microsoft",
    "First appeared": "2021",
    "Typing discipline": "strong",
    License: "MIT License",
    Website: "docs.microsoft.com/en-us/power-platform/power-fx/overview",
    id: "JwAL",
  },
  {
    name: "Mortran",
    description:
      "As an example of the differences between MUMPS and MIIS, the value of a logical expression in MUMPS may be false = zero (0) or true = non-zero, canonically, one (1). In MIIS, the value false is the empty string and the value of true is a string consisting of the ASCII delete character (code 127 decimal). There is also a philosophical difference between the dialects. MIIS often takes the approach that code should march along, regardless of possible errors, where MUMPS will error out to prevent more serious problems. For example, when encountering an undefined variable, MUMPS generates an error where MIIS treats it as nil. In the 1980s Brigham and Women's Hospital in Massachusetts used MIIS to program their Data General Mainframe. In 1986, SCAMC reported that Vancouver General Hospital also had an Integrated Cardiology Patient Management System written in MIIS. The MIIS language has been used in programming library systems as well as health industry systems. The OCLC's library system is one example. It has also been used to create financial systems for insurance brokers, as seen in Ireland and the UK in the late 1970s.",
    id: "4bHV",
  },
  {
    name: "MPD",
    description:
      "MIMIC is a further development from MIDAS (Modified Integration Digital Analog Simulator), which represented analog computer design. Written completely in FORTRAN but one routine in COMPASS, and ran on Control Data supercomputers, MIMIC is capable of solving much larger simulation models. With MIMIC, ordinary differential equations describing mathematical models in several scientific disciplines as in engineering, physics, chemistry, biology, economics and as well as in social sciences can easily be solved by numerical integration and the results of the analysis are listed or drawn in diagrams. It also enables the analysis of nonlinear dynamic conditions. The MIMIC software package, written as FORTRAN overlay programs, executes input statements of the mathematical model in six consecutive passes. Simulation programs written in MIMIC are compiled rather than interpreted. The core of the simulation package is a variable step numerical integrator of fourth-order Runge-Kutta method. Many useful functions related to electrical circuit elements exist besides some mathematical functions found in most scientific programming languages. There is no need to sort the statements in order of dependencies of the variables, since MIMIC does it internally. Parts of the software organized in overlays are:",
    id: "16pi",
  },
  {
    name: "Mirah",
    description:
      'To foster more participation in the JRuby project from Ruby community members, Nutter began to explore the possibility of presenting Ruby syntax, but with a static type model and direct-to-native compiling. In this context, "native" meant mainly the Java virtual machine (JVM), but Mirah has been designed around the possibility of having alternative backends for other object-oriented runtimes like the Common Language Runtime (CLR) of the .NET Framework. The language needed to look and feel like Ruby, and to introduce no new library dependencies into JRuby (which precludes most other JVM languages) and to suffer no performance penalty (which precludes writing in Ruby). Early versions of Mirah (then Duby) focused mostly on mathematical performance, where dynamic programming languages often pay the highest cost. Since then it has evolved into a full JVM language, with several users and real-world applications using it for core components. Mirah is mostly a pluggable compiler toolchain. The main elements of the chain are: Of these phases, only the last two need specific knowledge of the eventual target platform. This makes Mirah suitable for many backends, and also makes it possible to write language plug-ins for Mirah\'s transformation phase that will apply to all supported backends equally.',
    Paradigms: "Object-oriented, imperative",
    "Designed by": "Charles Oliver Nutter",
    "Stable release": "0.2.1 / September 26, 2016; 5 years ago",
    "Typing discipline": "static, with dynamic features, strong, inferred",
    Platform: "Java virtual machine",
    OS: "Cross-platform",
    License: "Apache License 2.0",
    Website: "www.mirah.org",
    other_details: {
      type: "programming",
      color: "#c7a938",
      extensions: [".druby", ".duby", ".mirah"],
      tm_scope: "source.ruby",
      ace_mode: "ruby",
      codemirror_mode: "ruby",
      codemirror_mime_type: "text/x-ruby",
      language_id: 232,
    },
    id: "r3Cr",
  },
  {
    name: "Miranda",
    image:
      "https://upload.wikimedia.org/wikipedia/en/3/34/Miranda_logo_%28programming_language%29.jpg",
    description:
      "Miranda was first released in 1985 as a fast interpreter in C for Unix-flavour operating systems, with subsequent releases in 1987 and 1989. It had a strong influence on the later Haskell programming language. In 2020 a version of Miranda was released as open source under a BSD licence. The codebase has been updated to conform to modern C standards (C11/C18) and to generate 64-bit binaries. This has been tested on operating systems including Debian, Ubuntu, WSL/Ubuntu, and MacOS (Catalina). Miranda is a lazy, purely functional programming language. That is, it lacks side effects and imperative programming features. A Miranda program (called a script) is a set of equations that define various mathematical functions and algebraic data types. The word set is important here: the order of the equations is, in general, irrelevant, and there is no need to define an entity prior to its use. Since the parsing algorithm makes intelligent use of layout (indentation), there is rarely a need for bracketing statements and no statement terminators are required. This feature, inspired by ISWIM, is also used in occam and Haskell and was later popularized by Python.",
    Paradigm: "lazy, functional, declarative",
    "Designed by": "David Turner",
    Developer: "Research Software Ltd",
    "First appeared": "1985",
    "Typing discipline": "strong, static",
    Website: "miranda.org.uk",
    id: "XWin",
  },
  {
    name: "MIVA Script",
    description:
      'The language was first developed under the name HTMLScript by Joe Austin and others in 1995, and a company, HTMLScript Corporation, was formed the following year. The origins of Miva Script began in 1993 when David Haldy and Joseph Austin built the first version of HTMLScript. The first version was written in the programming language Perl, which was called Logic Enhanced HTML (LEHTML). Joseph Austin wrote a wrapper for it in the programming language C that let it start off as a root process and then downgrade itself immediately to the ownership and permissions of the owner of the script file. This wrapper made it suitable for use with his hosting service which was called Volant Turnpike at the time. Joseph Austin eventually sold Volant Turnpike to Dave Haldy. Perl allowed self-executing code, so LEHTML did not have its own expression analyzer and just parsed the expression into Perl syntax and then passed it into Perl. Volant Turnpike users liked using LEHTML, so Joseph Austin and Ron Ahern wrote an expression analyzer and re-implemented the LEHTML syntax in the C language. Joseph Austin called the end result HTMLScript and registered the name with the United States Patent and Trademark Office (USPTO). Joseph Austin, Troy McCasland and Derek Finley were the founders of the company called HTMLScript Corporation. HTMLScript did not have the concept of a "WHILE" or "FOR" loop because of the low server processing power at the time. It would be enough to bring the whole server down if even one program ran away. So, Joseph Austin did not implement a loop to make it impossible for an HTMLScript server process to run away. Also, he implemented the macro in the first version of HTMLScript so it would allow self-executing code. The macro was powerful, but it eventually had some security issues. In 1997, Jon Burchmore extensively rewrote the language to make it more syntactically consistent, although the new engine supported both old HTMLScript and new (named mivascript) syntaxes. Jon Burchmore rewrote HTMLScript with syntax that Joe developed with the help of SoftQuad, using the emerging XML standard. Jon Burchmore wrote the replacement for KoolKat which then became Miva Merchant. The new end-product supported both the old HTMLScript syntax and new (named Miva Script) syntaxes.',
    Paradigm: "imperative",
    Developer: "Miva Merchant",
    "First appeared": "1996",
    "Stable release": "5.35",
    "Typing discipline": "Dynamic, loose",
    OS: "Cross-platform",
    License: "Empresa",
    "Filename extensions": ".mv, .mvc, .mvt",
    Website: "www.mivascript.com",
    id: "Hj7m",
  },
  {
    name: "ML",
    description:
      "Features of ML include a call-by-value evaluation strategy, first-class functions, automatic memory management through garbage collection, parametric polymorphism, static typing, type inference, algebraic data types, pattern matching, and exception handling. ML uses static scoping rules.[citation needed] ML can be referred to as an impure functional language, because although it encourages functional programming, it does allow side-effects (like languages such as Lisp, but unlike a purely functional language such as Haskell). Like most programming languages, ML uses eager evaluation, meaning that all subexpressions are always evaluated, though lazy evaluation can be achieved through the use of closures. Thus one can create and use infinite streams as in Haskell, but their expression is indirect. ML's strengths are mostly applied in language design and manipulation (compilers, analyzers, theorem provers), but it is a general-purpose language also used in bioinformatics and financial systems. ML was developed by Robin Milner and others in the early 1970s at the University of Edinburgh, and its syntax is inspired by ISWIM. Historically, ML was conceived to develop proof tactics in the LCF theorem prover (whose language, pplambda, a combination of the first-order predicate calculus and the simply-typed polymorphic lambda calculus, had ML as its metalanguage).",
    Paradigm: "Multi-paradigm: functional, imperative",
    "Designed by": "Robin Milner and others at the University of Edinburgh",
    "First appeared": "1973; 49 years ago",
    "Typing discipline": "Inferred, static, strong",
    id: "6Xlt",
  },
  {
    name: "Mystic Programming Language (MPL)NASM",
    description:
      'Model 204 relies on its own type of bitmap index, originally devised by Bill Mann, and combines the use of hash table, B-tree, and partitioned record list technologies to optimize speed and efficiency of database access. It has been described as "one of the three major inverted-list [database systems] ... the other two being" ADABAS and ADR\'s Datacom/DB. Although M204 is a pre-SQL (and pre-relational) database product, it is possible to manually map the files of an M204 database to approximate SQL equivalents and provide some limited SQL functionality using Model 204 SQL Server. Model 204 is commonly used in government and military applications.',
    id: "q1mA",
  },
  {
    name: "Modelica",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/0/0e/Modelica_Language.png/300px-Modelica_Language.png",
    description:
      "While Modelica resembles object-oriented programming languages, such as C++ or Java, it differs in two important respects. First, Modelica is a modeling language rather than a conventional programming language. Modelica classes are not compiled in the usual sense, but they are translated into objects which are then exercised by a simulation engine. The simulation engine is not specified by the language, although certain required capabilities are outlined. Second, although classes may contain algorithmic components similar to statements or blocks in programming languages, their primary content is a set of equations. In contrast to a typical assignment statement, such as where the left-hand side of the statement is assigned a value calculated from the expression on the right-hand side, an equation may have expressions on both its right- and left-hand sides, for example, Equations do not describe assignment but equality. In Modelica terms, equations have no pre-defined causality. The simulation engine may (and usually must) manipulate the equations symbolically to determine their order of execution and which components in the equation are inputs and which are outputs.",
    Paradigm: "Declarative language",
    Developer: "Modelica Association Project (MAP)",
    "First appeared": "1997",
    "Stable release": "3.5 / February 18, 2021",
    OS: "Cross-platform",
    License: "CC-BY-SA",
    "Filename extensions": ".mo",
    Website: "www.modelica.org",
    other_details: {
      type: "programming",
      extensions: [".mo"],
      tm_scope: "source.modelica",
      ace_mode: "text",
      codemirror_mode: "modelica",
      codemirror_mime_type: "text/x-modelica",
      language_id: 233,
    },
    id: "t7NR",
  },
  {
    name: "Modula",
    description:
      "The Modula programming language is a descendant of the Pascal language. It was developed in Switzerland, at ETH Zurich, in the mid-1970s by Niklaus Wirth, the same person who designed Pascal. The main innovation of Modula over Pascal is a module system, used for grouping sets of related declarations into program units; hence the name Modula. The language is defined in a report by Wirth called Modula. A language for modular multiprogramming published 1976. Modula was first implemented by Wirth on a PDP-11. Very soon, other implementations followed, most importantly, the compilers developed for University of York Modula, and one at Philips Laboratories named PL Modula, which generated code for the LSI-11 microprocessor. The development of Modula was discontinued soon after its publication. Wirth then concentrated his efforts on Modula's successor, Modula-2. This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    Paradigms: "Imperative, structured, modular",
    Family: "Wirth Modula",
    "Designed by": "Niklaus Wirth",
    Developer: "Niklaus Wirth",
    "First appeared": "1975; 47 years ago",
    "Typing discipline": "Static, strong, safe",
    Scope: "Lexical",
    Platform: "PDP-11, LSI-11",
    id: "eOBJ",
  },
  {
    name: "Modula-2",
    description:
      "Modula-2 is a structured, procedural programming language developed between 1977 and 1985 by Niklaus Wirth at ETH Zurich. It was created as the language for the operating system and application software of the Lilith personal workstation. It was later used for programming outside the context of the Lilith. Wirth viewed Modula-2 as a successor to his earlier programming languages Pascal and Modula. The main concepts are: The language design was influenced by the Mesa language and the Xerox Alto, both from Xerox PARC, that Wirth saw during his 1976 sabbatical year there. The computer magazine Byte devoted the August 1984 issue to the language and its surrounding environment. Modula-2 was followed by Modula-3, and later by the Oberon series of languages.",
    Paradigms:
      "imperative, structured, modular, data and procedure hiding, concurrent",
    Family: "Wirth Modula",
    "Designed by": "Niklaus Wirth",
    "First appeared": "1978; 44 years ago",
    "Typing discipline": "Static, strong, safe",
    Scope: "Lexical (static)",
    Platform: "Lilith (AMD 2901)",
    OS: "Cross-platform",
    "Filename extensions": ".mod, .m2, .def, .MOD, .DEF, .mi, .md",
    Website: "www.modula2.org",
    other_details: {
      type: "programming",
      extensions: [".mod"],
      tm_scope: "source.modula2",
      ace_mode: "text",
      language_id: 234,
    },
    id: "PQiD",
  },
  {
    name: "Modula-3",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Modula-3.svg/120px-Modula-3.svg.png",
    description:
      "Modula-3's main features are simplicity and safety while preserving the power of a systems-programming language. Modula-3 aimed to continue the Pascal tradition of type safety, while introducing new constructs for practical real-world programming. In particular Modula-3 added support for generic programming (similar to templates), multithreading, exception handling, garbage collection, object-oriented programming, partial revelation[further explanation needed], and explicit marking of unsafe code. The design goal of Modula-3 was a language that implements the most important features of modern imperative programming languages in quite basic forms. Thus allegedly dangerous and complicating features such as multiple inheritance and operator overloading were omitted. The Modula-3 project started in November 1986 when Maurice Wilkes wrote to Niklaus Wirth with some ideas for a new version of Modula. Wilkes had been working at DEC just prior to this point, and had returned to England and joined Olivetti's Research Strategy Board. Wirth had already moved on to Oberon, but had no problems with Wilkes's team continuing development under the Modula name. The language definition was completed in August 1988, and an updated version in January 1989. Compilers from DEC and Olivetti soon followed, and 3rd party implementations after that. Its design was heavily influenced by work on the Modula-2+ language in use at SRC and at the Acorn Computers Research Center (ARC, later ORC when Olivetti acquired Acorn) at the time, which was the language in which the operating system for the DEC Firefly multiprocessor VAX workstation was written and in which the Acorn Compiler for Acorn C and Modula Execution Library (CAMEL) at ARC for the ARX operating system project of ARM based Acorn Archimedes range of computers was written. As the revised Modula-3 Report states, the language was influenced by other languages such as Mesa, Cedar, Object Pascal, Oberon and Euclid. During the 1990s, Modula-3 gained considerable currency as a teaching language, but it was never widely adopted for industrial use. Contributing to this may have been the demise of DEC, a key Modula-3 supporter (especially when it ceased to maintain it effectively before DEC was sold to Compaq in 1998). In any case, in spite of Modula-3's simplicity and power, it appears that there was little demand for a procedural compiled language with restricted implementation of object-oriented programming. For a time, a commercial compiler named CM3 maintained by one of the chief implementors prior at DEC SRC who was hired before DEC being sold to Compaq, an integrated development environment (IDE) named Reactor and an extensible Java virtual machine (licensed in binary code and source code formats and buildable with Reactor) were offered by Critical Mass, Inc., but that company ceased active operations in 2000 and gave some of the source code of its products to elego Software Solutions GmbH. Modula-3 is now taught in universities mostly in comparative programming language courses, and its textbooks are out of print. Essentially the only corporate supporter of Modula-3 is elego, which inherited the sources from Critical Mass and has since made several releases of the CM3 system in source and binary code. The Reactor IDE has been open source released after several years it had not, with the new name CM3-IDE. In March 2002, elego also took over the repository of another active Modula-3 distribution, PM3, until then maintained at the École Polytechnique de Montréal but which later continued by the work on HM3 improved over the years later until it was obsoleted.",
    Paradigms: "imperative, structured, procedural, modular, concurrent",
    Family: "Wirth Modula",
    "Designed by":
      "Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan; Bill Kalsow, Greg Nelson",
    Developers: "DEC Olivetti elego Software Solutions GmbH",
    "First appeared": "1988; 34 years ago",
    "Stable release": "5.8.6 / July 14, 2010; 11 years ago",
    "Preview release": "5.8.6 / July 14, 2010; 11 years ago",
    "Typing discipline":
      "strong, static, safe or if unsafe explicitly safe isolated",
    Scope: "Lexical",
    Platform: "IA-32, x86-64, PowerPC, SPARC",
    OS: "Cross-platform: FreeBSD, Linux, Darwin, SunOS",
    Website: "www.modula3.org",
    other_details: {
      type: "programming",
      extensions: [".i3", ".ig", ".m3", ".mg"],
      color: "#223388",
      ace_mode: "text",
      tm_scope: "source.modula-3",
      language_id: 564743864,
    },
    id: "CuWr",
  },
  {
    name: "Net.Data",
    description:
      "General-purpose programming languages tend to focus on generic features to allow programs written in the language to use the same code on different platforms. Examples of such languages include ALGOL and Pascal. This generic quality typically comes at the cost of denying direct access to the machine's internal workings, and this often has negative effects on performance. System languages, in contrast, are designed not for compatibility, but for performance and ease of access to the underlying hardware while still providing high-level programming concepts like structured programming. Examples include SPL and ESPOL, both of which are similar to ALGOL in syntax but tuned to their respective platforms. Others are cross-platform but designed to work close to the hardware, like BLISS, JOVIAL and BCPL. Some languages straddle the system and application domains, bridging the gap between these uses. The canonical example is C, which is used widely for both system and application programming. Some modern languages also do this such as Rust and Swift. In contrast with application languages, system programming languages typically offer more-direct access to the physical hardware of the machine: an archetypical system programming language in this sense was BCPL. System programming languages often lack built-in input/output (I/O) facilities because a system-software project usually develops its own I/O mechanisms or builds on basic monitor I/O or screen management facilities. The distinction between languages used for system programming and application programming became blurred over time with the widespread popularity of PL/I, C and Pascal.",
    id: "dkUc",
  },
  {
    name: "NetLogo",
    description:
      "The term MOO is used in two distinct, but related, senses. One is to refer to those programs descended from the original MOO server, and the other is to refer to any MUD that uses object-oriented techniques to organize its database of objects, particularly if it does so in a similar fashion to the original MOO or its derivatives. Most of this article refers to the original MOO and its direct descendants, but see Non-Descendant MOOs for a list of MOO-like systems. The original MOO server was authored by Stephen White, based on his experience from creating the programmable TinyMUCK system. There was additional later development and maintenance from LambdaMOO founder, and former Xerox PARC employee, Pavel Curtis. One of the most distinguishing features of a MOO is that its users can perform object-oriented programming within the server, ultimately expanding and changing how the server behaves to everyone. Examples of such changes include authoring new rooms and objects, creating new generic objects for others to use, and changing the way the MOO interface operates. The programming language used for extension is the MOO programming language, and many MOOs feature convenient libraries of verbs that can be used by programmers in their coding known as Utilities. The MOO programming language is a domain-specific language.[citation needed] MOOs are network accessible, multi-user, programmable, interactive systems well-suited to the construction of text-based adventure games, conferencing systems, and other collaborative software. Their most common use, however, is as multi-participant, low-bandwidth virtual realities. They have been used in academic environments for distance education, collaboration (such as Diversity University), group decision systems, and teaching object-oriented concepts; but others are primarily social in nature, or used for role-playing video games, or simply to take advantage of the programming possibilities. They have also been used in scientific studies of virtual presence.",
    other_details: {
      type: "programming",
      color: "#ff6375",
      extensions: [".nlogo"],
      tm_scope: "source.lisp",
      ace_mode: "lisp",
      codemirror_mode: "commonlisp",
      codemirror_mime_type: "text/x-common-lisp",
      language_id: 246,
    },
    id: "SOtl",
  },
  {
    name: "NetRexx",
    description:
      "Example: Note that Mortran, like many preprocessors, does not make a complete analysis of the Fortran source and, like many preprocessors, may not always make its assumptions/requirements explicit. Consider, for example, Mortran multiple assignment. From the Mortran User Guide: produces the following FORTRAN statements: In this example, the produced Fortran implements the multiple assignment correctly only if X is not aliased to I or to A(I,K), assuming the multiple assignment semantics are left to right.",
    id: "AxV2",
  },
  {
    name: "NewLISP",
    description:
      "Mouse was originally intended as a small, efficient language for microcomputers with limited memory. It is an interpreted, stack-based language and uses Reverse Polish notation. To make an interpreter as easy as possible to implement, Mouse is designed so that a program is processed as a stream of characters, interpreted one character at a time. The elements of the Mouse language consist of a set of (mostly) one-character symbols, each of which performs a specific function (see table below). Since variable names are limited to one character, there are only 26 possible variables in Mouse (named A-Z). Integers and characters are the only available data types. Despite these limits, Mouse includes a number of relatively advanced features, including: The design of the Mouse language makes it ideal for teaching the design of a simple interpreter. Much of the book describing Mouse is devoted to describing the implementation of two interpreters, one in Z80 assembly language, the other in Pascal.",
    id: "Hz0i",
  },
  {
    name: "NEWP",
    description:
      "MPD is implemented as a variant of the SR programming language. It has a different parser, but it uses the same intermediate form and run-time system as SR. Consequently, MPD provides the same variety of concurrent programming mechanisms as does SR. MPD programs can execute on single processors, shared-memory multiprocessors, or clusters of (homogeneous) processors. The implementation transparently supports a variety of different kinds of processors and Unix systems.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    id: "lBir",
  },
  {
    name: "mIRC Scripting Language",
    description:
      'The mIRC scripting language (often unofficially abbreviated to "mSL") is the scripting language embedded in mIRC, an IRC client for Windows. Scripts are stored as either plain text files, usually with a .mrc file extension, or as INI files. They, however, can be stored with any extension. Multiple script files can be loaded at one time, although in some cases, one script will conflict with another and cause one or both of them to no longer work properly. mIRC scripting language uses its own nomenclature to refer to language constructs. (However, whilst this can be a little confusing to newcomers, they do not impact on the functionality of mSL.) The above is intended for singular access to the file. Because each time you issue $read or /write you open and close the file for access. Multiple accesses, during a loop for instance, is best handled through /fopen, /fwrite and /fclose. Since this opens the file only once. In some cases /filter and /savebuf is an even more efficient (non scripted loop) method.',
    Paradigm: "Event-driven programming, Procedural programming",
    "Designed by": "Khaled Mardam-Bey",
    Developer: "Khaled Mardam-Bey",
    "First appeared": "1995",
    "Typing discipline": "Dynamic typing",
    OS: "Microsoft Windows",
    License: "Proprietary software",
    "Filename extensions": ".mrc, .ini",
    Website: "http://mirc.com",
    id: "Jr0-",
  },
  {
    name: "MUMPS",
    description:
      'MUMPS technology has since expanded as the predominant database for health information systems and electronic health records in the United States. MUMPS-based information systems run over 40% of the hospitals in the U.S., run across all of the U.S. federal hospitals and clinics, and provide health information services for over 54% of patients across the U.S. A unique feature of the MUMPS technology is its integrated database language, allowing direct, high-speed read-write access to permanent disk storage. This provides tight integration of unlimited applications within a single database, and provides extremely high performance and reliability as an online transaction processing system. MUMPS is a language intended for and designed to build database applications. Secondary language features were included to help programmers make applications using minimal computing resources. The original implementations were interpreted, though modern implementations may be fully or partially compiled. Individual "programs" run in memory "partitions". Early MUMPS memory partitions were limited to 2048 bytes so aggressive abbreviation greatly aided multi-programming on severely resource limited hardware, because more than one MUMPS job could fit into the very small memories extant in hardware at the time. The ability to provide multi-user systems was another language design feature. The word "Multi-Programming" in the acronym points to this. Even the earliest machines running MUMPS supported multiple jobs running at the same time. With the change from mini-computers to micro-computers a few years later, even a "single user PC" with a single 8-bit CPU and 16K or 64K of memory could support multiple users, who could connect to it from (non-graphical) video display terminals. Since memory was tight originally, the language design for MUMPS valued very terse code. Thus, every MUMPS command or function name could be abbreviated from one to three letters in length, e.g. Quit (exit program) as Q, $P = $Piece function, R = Read command, $TR = $Translate function. Spaces and end-of-line markers are significant in MUMPS because line scope promoted the same terse language design. Thus, a single line of program code could express, with few characters, an idea for which other programming languages could require 5 to 10 times as many characters. Abbreviation was a common feature of languages designed in this period (e.g., FOCAL-69, early BASICs such as Tiny BASIC, etc.). An unfortunate side effect of this, coupled with the early need to write minimalist code, was that MUMPS programmers routinely did not comment code and used extensive abbreviations. This meant that even an expert MUMPS programmer could not just skim through a page of code to see its function but would have to analyze it line by line.',
    Paradigm: "Imperative, procedural",
    "Designed by": "Neil Pappalardo",
    "First appeared": "1966; 56 years ago",
    "Stable release": "ANSI X11.1-1995 / December 8, 1995",
    "Typing discipline": "Typeless",
    OS: "Cross-platform",
    id: "nBWQ",
  },
  {
    name: "MuPAD",
    image: "https://upload.wikimedia.org/wikipedia/en/f/f2/MuPADCube.png",
    description:
      'Until autumn 2005, the version "MuPAD Light" was offered for free for research and education, but as a result of the closure of the home institute of the MuPAD research group, only the version "MuPAD Pro" became available for purchase. The MuPAD kernel is bundled with Scientific Notebook and Scientific Workplace. Former versions of MuPAD Pro were bundled with SciLab. In MathCAD\'s version 14 release Mupad was adopted as the CAS engine. In September 2008, SciFace was purchased by MathWorks and the MuPAD code was included in the Symbolic Math Toolbox add-on for MATLAB. On 28 September 2008, MuPAD was withdrawn from the market as a software product in its own right. However, it is still available in the Symbolic Math Toolbox in MATLAB and can also be used as a stand-alone program by the command mupad entered into the MATLAB terminal. The MuPAD notebook feature has been removed in MATLAB R2020a. However, MATLAB\'s Symbolic Math Toolbox still uses the MuPAD language as part of its underlying computational engine. MATLAB Live Editor is the recommended environment for performing, documenting, and sharing symbolic math computations.',
    "Developer(s)": "The Mathworks Inc.",
    "Stable release": "7.2.0 (R2017a)",
    "Operating system": "Windows, Mac OS X, Linux",
    Type: "Computer algebra system",
    License: "Proprietary",
    Website: "mathworks.com/discovery/mupad.html",
    id: "nu6k",
  },
  {
    name: "Ethereum",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Ethereum-icon-purple.svg/220px-Ethereum-icon-purple.svg.png",
    description:
      "Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether (ETH or Ξ) is the native cryptocurrency of the platform. Amongst cryptocurrencies, Ether is second only to Bitcoin in market capitalization. Ethereum was conceived in 2013 by programmer Vitalik Buterin. Additional founders of Ethereum included Gavin Wood, Charles Hoskinson, Anthony Di Iorio and Joseph Lubin. In 2014, development work commenced and was crowdfunded, and the network went live on 30 July 2015. The platform allows anyone to deploy permanent and immutable decentralized applications onto it, with which users can interact. Decentralized finance (DeFi) applications provide a broad array of financial services without the need for typical financial intermediaries like brokerages, exchanges, or banks, such as allowing cryptocurrency users to borrow against their holdings or lend them out for interest. Ethereum also allows for the creation and exchange of NFTs, which are non-interchangeable tokens connected to digital works of art or other real-world items and sold as unique digital property. Additionally, many other cryptocurrencies operate as ERC-20 tokens on top of the Ethereum blockchain and have utilized the platform for initial coin offerings. Ethereum has started implementing a series of upgrades called Ethereum 2.0, which includes a transition to proof of stake and aims to increase transaction throughput using sharding. Ethereum was initially described in a white paper by Vitalik Buterin, a programmer and co-founder of Bitcoin Magazine, in late 2013 with a goal of building decentralized applications. Buterin argued to the bitcoin core developers that Bitcoin and blockchain technology could benefit from other applications besides money and needed a more robust language for application development that could lead to attaching real-world assets, such as stocks and property, to the blockchain. In 2013, Buterin briefly worked with eToro CEO Yoni Assia on the Colored Coins project and drafted its white paper outlining additional use cases for blockchain technology. However, after failing to gain agreement on how the project should proceed, he proposed the development of a new platform with a more robust scripting language—a Turing-complete programming language—that would eventually become Ethereum.",
    "Original author(s)": "Vitalik Buterin Gavin Wood",
    "Developer(s)":
      "Ethereum Foundation, Hyperledger, Nethermind, OpenEthereum, EthereumJS",
    "Initial release": "30 July 2015; 6 years ago",
    "Stable release": "London / 5 August 2021; 5 months ago",
    "Development status": "Active",
    "Software used": "EVM 1 Bytecode",
    "Written in": "Go, Rust, C#, C++, Java, Python",
    "Operating system": "Cross-platform",
    Platform: "x86-64, ARM",
    Size: "991.56 GB (2021-09-30)",
    "Available in": "Multilingual, but primarily English",
    Type: "Distributed computing",
    License: "Open-source licenses",
    "Active hosts": "3,481 nodes (2021-09-30)",
    Website: "ethereum.org",
    id: "-Y5w",
  },
  {
    name: "Mystic BBS",
    description:
      "Some of the more notable capabilities of Mystic BBS include: A more complete list of capabilities can be found at http://www.mysticbbs.com/features.html Attracted to the flexibility and potential that the scripting language provides, a number groups, such as ACiDic BBS modding, Cyberia, Demonic, DoRE, Vanguard, wOE!mODDING and Wicked formed for the sole purpose of writing BBS mods for SysOps who run Mystic. Here's a small selection of BBS that currently use Mystic software (alphabetical by BBS name):",
    "Original author(s)": "James Coyle",
    "Stable release": "1.12 A47 / December 25, 2021",
    "Written in": "FreePascal",
    "Operating system": "MS-DOS, Windows, OS/2, OS X, Linux",
    Platform: "IA_32, x86-64, ARM",
    Type: "BBS",
    License: "Proprietary freeware",
    Website: "www.mysticbbs.com",
    id: "Z0LO",
  },
  {
    name: "Netwide Assembler",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Netwide_Assembler.svg/176px-Netwide_Assembler.svg.png",
    description:
      "The Netwide Assembler (NASM) is an assembler and disassembler for the Intel x86 architecture. It can be used to write 16-bit, 32-bit (IA-32) and 64-bit (x86-64) programs. NASM is considered to be one of the most popular assemblers for Linux. NASM was originally written by Simon Tatham with assistance from Julian Hall. As of 2016, it is maintained by a small team led by H. Peter Anvin. It is open-source software released under the terms of a simplified (2-clause) BSD license. NASM can output several binary formats, including COFF, OMF, a.out, Executable and Linkable Format (ELF), Mach-O and binary file (.bin, binary disk image, used to compile operating systems), though position-independent code is supported only for ELF object files. NASM also has its own binary format called RDOFF. The variety of output formats allows retargeting programs to virtually any x86 operating system (OS). Also, NASM can create flat binary files, usable to write boot loaders, read-only memory (ROM) images, and in various facets of OS development. NASM can run on non-x86 platforms as a cross assembler, such as PowerPC and SPARC, though it cannot generate programs usable by those machines.",
    "Original author(s)": "Simon Tatham, Julian Hall",
    "Developer(s)": "H. Peter Anvin, et al.",
    "Initial release": "October 1996; 25 years ago",
    "Stable release": "2.15.05 / 28 August 2020; 16 months ago",
    Repository: "github.com/netwide-assembler/nasm ",
    "Written in": "Assembly, C",
    "Operating system": "Unix-like, Windows, OS/2, MS-DOS",
    "Available in": "English",
    Type: "x86 assembler",
    License: "BSD 2-clause",
    Website: "www.nasm.us",
    id: "Sgo3",
  },
  {
    name: "NekoVM",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/NekoVM_logo.svg/63px-NekoVM_logo.svg.png",
    description:
      'Neko has a compiler and a virtual machine (VM) with garbage collection. The compiler converts a source .neko file into a bytecode .n file that can be executed with the VM. Since Neko is dynamically typed with no fixed classes, a developer only needs to find the proper runtime mapping (in contrast to type mapping) so that code executes correctly. As the Neko FAQ puts it: "...it is easier to write a new or existing language on the NekoVM than it is for the CLR / JVM, since you don’t have to deal with a highlevel type system. Also, this means that languages can interoperate more easily since they only need to share the same data structures and not always the same types." Neko requires compiling before executing, like other scripting languages such as Apache Groovy. Since Neko need not be interpreted at runtime, it executes faster. The Haxe programming language can compile to Neko code, among other targets. The Neko virtual machine is used to execute a Neko bytecode file, the VM also has the option to convert a bytecode file into an executable file (output changes depending on the target operating system). Neko includes Apache server modules mod_neko for Neko language and mod_tora for hosting the NekoVM application server tora. As such, it can process user input using GET and POST requests:',
    "Original author(s)": "Nicolas Cannasse",
    "Developer(s)": "Haxe Foundation Shiro Games Motion Twin",
    "Initial release": "2005; 17 years ago",
    "Stable release": "2.3.0 / October 24, 2019; 2 years ago",
    Repository: "github.com/HaxeFoundation/neko ",
    "Written in": "C",
    "Operating system": "Windows, macOS, Linux",
    Platform: "NekoVM",
    License: "MIT",
    Website: "nekovm.org/specs/syntax/",
    Paradigm: "Object-oriented, structured, prototype-based, scripting",
    "Designed by": "Nicolas Cannasse",
    Developer: "Haxe Foundation Shiro Games Motion Twin",
    "First appeared": "2005; 17 years ago",
    "Typing discipline": "Dynamic",
    "Implementation language": "OCaml",
    OS: "Windows, macOS, Linux",
    "Filename extensions": ".neko .n",
    id: "mmUT",
  },
  {
    name: "Nemerle",
    description:
      "Nemerle is named after the Archmage Nemmerle, a character in the fantasy novel A Wizard of Earthsea by Ursula K. Le Guin. Nemerle's most notable feature is the ability to mix styles of programming that are object-oriented and functional. Programs may be structured using object-oriented concepts such as classes and namespaces, while methods can (optionally) be written in a functional style. Other notable features include: The metaprogramming system allows for great compiler extensibility, embedding domain-specific languages, partial evaluation, and aspect-oriented programming, taking a high-level approach to lift as much of the burden as possible from programmers. The language combines all Common Language Infrastructure (CLI) standard features, including parametric polymorphism, lambdas, extension methods etc. Accessing the libraries included in the .NET or Mono platforms is as easy as in C#. Type matching with variable binding: ",
    Paradigm: "Multi-paradigm: functional, imperative, meta, object-oriented",
    "Designed by":
      "Kamil Skalski, Michał Moskal, Prof. Leszek Pacholski, Paweł Olszta at Wrocław University",
    Developer: "JetBrains",
    "First appeared": "2003; 19 years ago",
    "Stable release": "1.2.507.0 / 6 August 2016; 5 years ago",
    "Typing discipline": "Inferred, nominal, static, strong",
    Platform: "CLI",
    "Filename extensions": ".n",
    Website: "nemerle.org",
    other_details: {
      type: "programming",
      color: "#3d3c6e",
      extensions: [".n"],
      ace_mode: "text",
      language_id: 243,
    },
    id: "Z0NO",
  },
  {
    name: "NESL",
    description:
      "The most important new ideas behind NESL are The main design guideline for NESL was to make parallel programming easy and portable. Algorithms are typically significantly more concise in NESL than in most other parallel programming languages, and the code closely resembles high-level pseudocode. NESL supports nested data parallelism by using the flattening transform to convert nested data parallelism to flat data parallelism. This works by storing nested vectors as the nested data and a segment descriptor of vector lengths, separately. This flattening transform, however, can increase the asymptotic work and space complexity of the original program, leading to a much less efficient result. NESL heavily influenced Data Parallel Haskell.",
    Paradigm: "parallel, functional, array",
    Developer: "SCandAL project",
    "First appeared": "1993",
    "Stable release": "3.1 / November 1995",
    License: "permissive license similar to the ISC and X11 licenses",
    id: "cDd_",
  },
  {
    name: "NetLogo",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/4/4e/NetLogo_%28logo%29.png/280px-NetLogo_%28logo%29.png",
    description:
      'NetLogo was designed by Uri Wilensky, in the spirit of the programming language Logo, to be "low threshold and no ceiling". It teaches programming concepts using agents in the form of turtles, patches, links and the observer. NetLogo was designed with multiple audiences in mind, in particular: teaching children in the education community, and for domain experts without a programming background to model related phenomena. Many scientific articles have been published using NetLogo. The NetLogo environment enables exploration of emergent phenomena. It comes with an extensive models library including models in a variety of domains, such as economics, biology, physics, chemistry, psychology, system dynamics. NetLogo allows exploration by modifying switches, sliders, choosers, inputs, and other interface elements. Beyond exploring, NetLogo allows authoring new models and modifying extant models. NetLogo is open source and freely available from the NetLogo website. It is in use in a wide variety of educational contexts from elementary school to graduate school. Many teachers make use of NetLogo in their curricula. NetLogo was designed and authored by Uri Wilensky, director of Northwestern University\'s Center for Connected Learning and Computer-Based Modeling (CCL).',
    Paradigms:
      "multi-paradigm: educational, procedural, agent-based, simulation",
    Family: "Lisp",
    "Designed by": "Uri Wilensky",
    Developer:
      "Northwestern University Center for Connected Learning and Computer-Based Modeling",
    "First appeared": "1999; 23 years ago",
    "Stable release": "6.2.1 / October 19, 2021; 2 months ago",
    "Typing discipline": "Dynamic, strong",
    Scope: "Lexical",
    "Implementation language": "Scala, Java",
    Platform: "IA-32, x86-64",
    OS: "Cross-platform: JVM",
    License: "GPL",
    "Filename extensions": ".nlogo, .nlogo3d, .nls",
    Website: "ccl.northwestern.edu/netlogo",
    other_details: {
      type: "programming",
      color: "#ff6375",
      extensions: [".nlogo"],
      tm_scope: "source.lisp",
      ace_mode: "lisp",
      codemirror_mode: "commonlisp",
      codemirror_mime_type: "text/x-common-lisp",
      language_id: 246,
    },
    id: "OSW-",
  },
  {
    name: "NetRexx",
    image: "https://upload.wikimedia.org/wikipedia/commons/c/c4/NETREXX.gif",
    description:
      "Integration with the JVM platform is tight, and all existing Java class libraries can be used unchanged and without special setup; at the same time, a Java programmer can opt to just use the Rexx class from the runtime package for improved string handling in Java syntax source programs. NetRexx is free to download from the Rexx Language Association. IBM announced the transfer of NetRexx 3.00 source code to the Rexx Language Association (RexxLA) on June 8, 2011. In 1995 Mike Cowlishaw ported Java to OS/2 and soon after started with an experiment to run REXX on the JVM. With REXX generally considered the first of the general purpose scripting languages, NetRexx is the first alternative language for the JVM. The 0.50 release, from April 1996, contained the NetRexx runtime classes and a translator written in REXX but tokenized and turned into an OS/2 executable. The 1.00 release came available in January 1997 and contained a translator bootstrapped to NetRexx. Release 2.00 became available in August 2000 and was a major upgrade, in which interpreted execution was added.",
    Paradigm: "multiparadigm: object-oriented, procedural, structured",
    "Designed by": "Mike Cowlishaw",
    "First appeared": "1996",
    "Stable release": "4.01 / 20 March 2021; 9 months ago",
    "Typing discipline":
      "Static, strong, safe, partly dynamic, everything is a string (for the Rexx data type, which handles strings and numbers)",
    License: "ICU License",
    "Filename extensions": ".nrx",
    id: "_Bm7",
  },
  {
    name: "newLISP",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/e/e7/Nl_logo_libel_side_color_240X100.png/220px-Nl_logo_libel_side_color_240X100.png",
    description:
      "newLISP is a scripting language which is a dialect of the Lisp family of programming languages. It was designed and developed by Lutz Mueller. newLISP is free and open-source software released under the GNU General Public License, version 3 or later. newLISP design is influenced by the two main Lisp dialects, Common Lisp and Scheme, and by other languages like Pascal and C.[citation needed] newLISP originated in 1991 and was originally developed on a Sun-4 workstation. It later moved to Windows 3.0, where version 1.3 was released on CompuServe around 1993, then became available as a Windows graphical user interface (GUI) graphics-capable application and a DOS console application (both 16-bit). In 1995, with the release of Windows 95, newLISP moved to 32-bit. In April 1999, newLISP was ported to Linux; some of its core algorithms were rewritten, and all Windows-specific code removed. newLISP was released as an open-source software project licensed under the GPL, and development on Windows stopped after version 6.0.25. During the first half of 2001, newLISP was ported back to Windows on the Cygwin platform without graphics abilities. In the second half of 2001, a cross-platform Tcl/Tk frontend named newLISP-tk was released around version 6.3.0. In 2006, 64-bit precision was introduced for integer arithmetic and for some operations on files in version 9.0. Since the release of 6.5 in mid-2002, development has been very active, and many new features have been added.",
    Paradigm: "Multi-paradigm",
    Family: "Lisp",
    "Designed by": "Lutz Mueller",
    Developer: "Lutz Mueller",
    "First appeared": "1991; 31 years ago",
    "Stable release": "10.7.5 / May 12, 2019; 2 years ago",
    "Preview release": "10.7.4 / September 10, 2018; 3 years ago",
    Scope: "Dynamic",
    Platform: "IA-32, x86-64",
    OS: "Cross-platform: Unix, Unix-like, Windows",
    License: "GPLv3+",
    Website: "www.newlisp.org",
    id: "lW8g",
  },
  {
    name: "Newspeak",
    description:
      "Newspeak is a class based language. Classes may be nested, as in BETA. This is one of the key differences between Newspeak and Smalltalk. All names in Newspeak are late-bound, and are interpreted as message sends, as in Self. Newspeak is distinguished by its unusual approach to modularity. The language has no global namespace. Top level classes act as module declarations. Module declarations are first class values (i.e., they may be stored in variables, passed as parameters, returned from methods, etc.) and are stateless. The name \"Newspeak\" is inspired by the Newspeak language appearing in George Orwell's dystopian novel Nineteen Eighty-Four. The heading on the programming language's website says \"It's doubleplusgood\". The motivation for the name is that Orwell's Newspeak language grew smaller with every revision; Bracha views this as a desirable goal for a programming language. The language icon is supposed to be Big Brother's eye, as seen in page 3 of the documentation.",
    Paradigm: "object-oriented, functional",
    "Designed by": "Gilad Bracha",
    Developer:
      "Gilad Bracha, Peter von der Ahé, Vassili Bykov, Yaron Kashai, Ryan Macnak, William Maddox, Eliot Miranda",
    "First appeared": "2006",
    "Stable release": "Prototype / February 2013",
    "Typing discipline": "dynamic, optional",
    License: "Apache License",
    Website: "newspeaklanguage.org",
    id: "b4Np",
  },
  {
    name: "NewtonScript",
    description:
      "On August 3, 1993, Apple unveiled the Apple Newton MessagePad. The device had 640 KB RAM, 4 MB ROM, and an 20 MHz ARM 610 microprocessor. The main intention behind Newton project, was to develop a device capable of replacing a computer while being portable. With limited battery and memory, the developers were looking for programming language capable of meeting these challenges. The developers looked at C++ language but realized that it lacked flexibility. They started focusing on prototype based languages and were impressed with Smalltalk and Self. Concurrently Apple was developing another dynamic programming language called Dylan, which was a strong candidate for Newton platform. However, both Self and Dylan were dropped out of consideration, as they were both in nascent stage for proper integration.",
    Paradigm: "Prototype Object-oriented",
    "Designed by": "Walter Smith",
    Developer: "Apple Computer",
    "First appeared": "1993; 29 years ago",
    "Typing discipline": "Dynamic",
    id: "X6qa",
  },
  {
    name: "Nial",
    image: "https://upload.wikimedia.org/wikipedia/commons/8/88/NialLogo.jpg",
    description:
      'Nial combines a functional programming notation for arrays based on an array theory developed by Trenchard More with structured programming concepts for numeric, character, and symbolic data. It is most often used for prototyping and artificial intelligence.  In 1982, Jenkins formed a company (Nial Systems Ltd) to market the language and the Q\'Nial implementation of Nial. As of 2014, the company website supports an Open Source project for the Q\'Nial software with the binary and source available for download. Its license is derived from Artistic License 1.0, the only differences being the preamble, the definition of "Copyright Holder" (which is changed from "whoever is named in the copyright or copyrights for the package" to "NIAL Systems Limited"), and an instance of "whoever" (which is changed to "whomever"). Nial uses a generalized and expressive Array Theory in its Version 4, but sacrificed some of the generality of functional model, and modified the Array Theory in the Version 6. Only Version 6 is available now.',
    Paradigm: "array",
    "Designed by": "Mike Jenkins",
    Developer: "Nial Systems Ltd",
    "First appeared": "1981",
    "Stable release": "7.0 / 2017; 5 years ago",
    "Typing discipline": "dynamic",
    License: "GNU GPLv3",
    "Filename extensions": ".ndf, .nlg",
    Website: "www.nial-array-language.org",
    id: "BdMN",
  },
  {
    name: "Object REXX",
    description:
      'Packard is responsible for many X extensions and technical papers on X. He has been heavily involved in the development of X since the late 1980s as a member of the MIT X Consortium, XFree86 and the X.Org Foundation. In 2011, O\'Reilly awarded an open source award to Packard, as "the person behind most of the improvements made on the open source desktop in the last ten years at least." He is portrayed as one of the Faces of Open Source. Packard gained a BA in mathematics from Reed College, Oregon in 1986. He worked at Tektronix, Inc. in Wilsonville, Oregon designing X terminals and Unix workstations from 1983 until 1988. He then moved to Cambridge, Massachusetts to work at the Massachusetts Institute of Technology X Consortium from 1988 to 1992, developing the X Window System reference implementation and standards as the senior member of a small team. He was responsible for X releases at this time.',
    Born: "April 16, 1963 (age 58)",
    Education: "BA in mathematics",
    Occupation: "Programmer",
    Employer: "SiFive",
    "Known for": "Programming",
    "Board member of": "X.Org Foundation",
    Website: "keithp.com",
    id: "-pW9",
  },
  {
    name: "Object Pascal",
    description:
      'Packard is responsible for many X extensions and technical papers on X. He has been heavily involved in the development of X since the late 1980s as a member of the MIT X Consortium, XFree86 and the X.Org Foundation. In 2011, O\'Reilly awarded an open source award to Packard, as "the person behind most of the improvements made on the open source desktop in the last ten years at least." He is portrayed as one of the Faces of Open Source. Packard gained a BA in mathematics from Reed College, Oregon in 1986. He worked at Tektronix, Inc. in Wilsonville, Oregon designing X terminals and Unix workstations from 1983 until 1988. He then moved to Cambridge, Massachusetts to work at the Massachusetts Institute of Technology X Consortium from 1988 to 1992, developing the X Window System reference implementation and standards as the senior member of a small team. He was responsible for X releases at this time.',
    Born: "April 16, 1963 (age 58)",
    Education: "BA in mathematics",
    Occupation: "Programmer",
    Employer: "SiFive",
    "Known for": "Programming",
    "Board member of": "X.Org Foundation",
    Website: "keithp.com",
    id: "lv0F",
  },
  {
    name: "Nim",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Nim-logo.png/120px-Nim-logo.png",
    description:
      "Nim was created to be a language as fast as C, as expressive as Python, and as extensible as Lisp. Nim is statically typed. It supports compile-time metaprogramming features such as syntactic macros and term rewriting macros. Term rewriting macros enable library implementations of common data structures, such as bignums and matrices, to be implemented efficiently, as if they were built-in language facilities. Iterators are supported and can be used as first class entities, as can functions, allowing for the use of functional programming methods. Object-oriented programming is supported by inheritance and multiple dispatch. Functions can be generic, they can be overloaded, and generics are further enhanced by Nim's support for type classes. Operator overloading is also supported. Nim includes tunable automatic garbage collection based on deferred reference counting with cycle detection, which can also be turned off altogether. [Nim] ... presents a most original design that straddles Pascal and Python and compiles to C code or JavaScript. As of October 2021, Nim compiles to C, C++, JavaScript, and Objective-C.",
    Paradigms:
      "Multi-paradigm: compiled, concurrent, Procedural, Imperative, Functional, Object-oriented",
    "Designed by": "Andreas Rumpf",
    Developer: "Nim Lang Team ",
    "First appeared": "2008; 14 years ago",
    "Stable release": "1.6.2  / 17 December 2021; 28 days ago",
    "Typing discipline": "Static, strong, inferred, structural",
    Scope: "Lexical",
    Platform: "IA-32, x86-64, ARM, Aarch64, RISC-V, PowerPC ... ",
    OS: "Cross-platform",
    License: "MIT",
    "Filename extensions": ".nim, .nims, .nimble",
    Website: "nim-lang.org",
    other_details: {
      type: "programming",
      color: "#37775b",
      extensions: [".nim", ".nim.cfg", ".nimble", ".nimrod", ".nims"],
      filenames: ["nim.cfg"],
      ace_mode: "text",
      tm_scope: "source.nim",
      language_id: 249,
    },
    id: "6HC_",
  },
  {
    name: "Nix package manager",
    description:
      'Nix packages are defined through a lazy functional programming language specifically designed for package management. Dependencies are tracked directly in this language through an intermediate format called "derivations". A Nix environment keeps track of references automatically, which allows unused packages to be garbage collected when no other package depends on them. At the cost of greater storage requirements, all upgrades in Nix are guaranteed to be both atomic and capable of efficient roll-back. This also enables multiple users to safely install software on the same system without administrator privileges. Nix has full support for Linux and macOS and can safely be installed side by side with an existing package manager. NixOS is a Linux distribution using Nix for managing software in the system, including the Linux kernel. Nixpkgs is the package repository built upon the Nix package manager. According to Repology, as of July 2021 it contains more than 70,000 packages, and is the most up-to-date package repository.',
    "Stable release": "2.4 / November 1, 2021; 2 months ago",
    Repository: "github.com/NixOS/nix ",
    "Written in": "C++",
    Platform: "Linux, Unix-like",
    Type: "Package management",
    License: "LGPL",
    Website: "nixos.org/nix",
    id: "MxgJ",
  },
  {
    name: "Nord Programming Language",
    description:
      "Nord Programming Language (NPL), is a procedural programming language by the Norwegian minicomputer manufacturer Norsk Data. It shipped as a standard component of the operating system Sintran III. The language was also used to implement Sintran III: the core and file system of which are written in NPL, as was the NPL compiler, and some core applications early on, until the release of high-level programming language named PLANC. Then, the linker and other software were rewritten in PLANC. The NPL compiler was also special in that it did not emit object code as most compilers do. Instead it emitted an intermediate representation, in the form of assembly language code, which then had to be assembled using the Norsk Data Assembler. The registers of the CPU were available in NPL as predefined variables. Thus could be written:",
    Paradigm: "Procedural, imperative",
    Developer: "Norsk Data",
    "First appeared": "1974; 48 years ago",
    "Final release": "Final",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    Platform: "Norsk Data minicomputers",
    OS: "Sintran III",
    License: "Proprietary",
    id: "wMzQ",
  },
  {
    name: "occam",
    description:
      "A simple test program written in NQC for an RCX with a motor connected to output port A could look like this: Thus, motor A will go at full speed for two seconds before being turned off. NQC compilers and integrated development environments (IDEs) are available for many platforms including Microsoft Windows, Mac OS X, Linux, BeOS and DOS. One is the Bricx Command Center. Compiler sources:",
    id: "_ZFf",
  },
  {
    name: "Nullsoft Scriptable Install System",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/0/04/Nullsoft_Scriptable_Install_System_icon.png",
    description:
      "Nullsoft Scriptable Install System (NSIS) is a script-driven installer authoring tool for Microsoft Windows backed by Nullsoft, the creators of Winamp. NSIS is released under a combination of free software licenses, primarily the zlib license. It has become a widely used alternative to commercial proprietary products like InstallShield, with users including Amazon.com, Dropbox, Google, Ubisoft, FL Studio, BitTorrent, and McAfee. NSIS was created to distribute Winamp. It is based on a previous Nullsoft product, PiMP (plugin Mini Packager), and is also known as SuperPiMP. After version 2.0a0, the project was moved to SourceForge where developers outside Nullsoft started working on it on a regular basis. NSIS 2.0 was released approximately two years later. NSIS version 1 is in many ways similar to the classic Windows Installer, but it supports more compression formats. NSIS version 2 features a new streamlined graphical user interface and supports LZMA compression, multiple languages, and an easy-to-use plugin system. In January 2006 NSIS was SourceForge's project of the month.",
    "Original author(s)": "Nullsoft",
    "Developer(s)": "NSIS Team and NSIS Community",
    "Initial release": "31 July 2000; 21 years ago",
    "Stable release": "3.08 / 25 September 2021; 3 months ago",
    Repository: "sourceforge.net/p/nsis/code/HEAD/tree/ ",
    "Written in": "C, C++",
    "Operating system": "Windows, Mac OS X",
    Type: "Software development tools",
    License: "zlib License",
    Website: "nsis.sourceforge.io",
    id: "18K0",
  },
  {
    name: "Nu",
    description:
      "The language was first announced at C4, a conference for indie Mac developers held in August 2007. This Nu code defines a simple complex numbers class. The example is a basic definition of a complex number: it defines the instance variables, and a method to initialize the object. It shows the similarity between the code in Nu and the equivalent in Objective-C; it also shows the similarity with Ruby. This sample, from the nuke tool bundled with Nu, also shows the influence of Objective-C, Lisp, and Ruby in the design of the language.",
    Paradigm: "structured, imperative, functional, object-oriented",
    "Designed by": "Tim Burks",
    Developer: "Tim Burks",
    "First appeared": "2007; 15 years ago",
    "Stable release": "2.2.2 / April 17, 2017; 4 years ago",
    "Typing discipline": "dynamic",
    Platform: "x86",
    OS: "OS X",
    License: "Apache, v. 2.0",
    Website: "programming-nu.github.io",
    other_details: {
      type: "programming",
      color: "#c9df40",
      aliases: ["nush"],
      extensions: [".nu"],
      filenames: ["Nukefile"],
      tm_scope: "source.nu",
      ace_mode: "scheme",
      codemirror_mode: "scheme",
      codemirror_mime_type: "text/x-scheme",
      interpreters: ["nush"],
      language_id: 253,
    },
    id: "oR3Z",
  },
  {
    name: "NWscript",
    description:
      'NWScript is also used in the video games The Witcher, Star Wars: Knights of the Old Republic and Star Wars: Knights of the Old Republic II The Sith Lords, which use the Odyssey Engine. Neverwinter Nights 2, the sequel to the original NWN, features a modified version of this scripting language. While based on C, NWScript does not have many functions from the C family, excluding logical and binary / ternary operators and some mathematical functions. Function source code is not accessible to the end-user, but the correct syntax is defined in a script file called nwscript.nss. The users can create their own functions, and these can be included in other scripts through the #include directive, which works slightly differently than in C++. NWScript has no way to directly target the screen for output. Instead, for instance, in-game characters such as the player character can be made to speak the typical "Hello world" example message. This script puts a "Hello world" message in the player\'s message log. For it to work, it should be placed in the OnClientEnter event of the module\'s properties. The first line is the void main function which is the function that a NWScript will start at. In the third line, the text Hello world is sent to the player\'s in-game message log.',
    "Designed by": "BioWare",
    Developer: "BioWare",
    "First appeared": "June 18, 2002",
    "Stable release": "1.69.8109 (Neverwinter Nights) / July 9, 2008",
    OS: "Microsoft Windows, 3rd party tools for Mac OS X and Linux",
    License: "BioWare EULA",
    Website: "BioWare Developers Portal",
    id: "SSm9",
  },
  {
    name: "Lego Mindstorms NXT 2.0",
    description:
      "The main component in the kit is a brick-shaped computer called the NXT Intelligent Brick. It can take input from up to four sensors and control up to three motors, via a modified version of RJ12 cables, very much similar to but incompatible with RJ11 phone cords. The plastic pin to hold the cable in the socket is moved slightly to the right. The brick has a 100×64 pixel monochrome LCD and four buttons that can be used to navigate a user interface using hierarchical menus. It has a 32-bit ARM7TDMI-core Atmel AT91SAM7S256 microcontroller with 256 KB of FLASH memory and 64 KB of RAM, plus an 8-bit Atmel AVR ATmega48 microcontroller, and bluetooth support. It also has a speaker and can play sound files at sampling rates up to 8 kHz. Power is supplied by 6 AA (1.5 V each) batteries in the consumer version of the kit and by a Li-Ion rechargeable battery and charger in the educational version. The Intelligent Brick remains unchanged with NXT 2.0. A black version of the brick was made to celebrate the 10th anniversary of the Mindstorms System with no change to the internals. Lego has released the firmware for the NXT Intelligent Brick as open source, along with schematics for all hardware components. Several developer kits are available that contain documentation for the NXT:",
    "Other names": "Mindstorms NXT Mindstorms NXT 2.0",
    "Parent theme": "Technic",
    Availability: "2009–2013",
    id: "0Y3U",
  },
  {
    name: "Open Programming Language (OPL)",
    description:
      "The name Oak was used by Gosling after an oak tree that stood outside his office. In 1995, Sun Microsystems was attempting to develop a new technology for programming next generation smart appliances, which Sun expected to be a major new opportunity. The team originally considered using C++, but rejected the idea for several reasons (see Java history). Initially, Gosling attempted to modify and extend C++ but soon abandoned that in favor of creating a new platform called Green and an entirely new language, which he called Oak, after the tree that stood just outside his office.",
    id: "AKSL",
  },
  {
    name: "Oberon",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Oberon_programming_language_logo.svg/220px-Oberon_programming_language_logo.svg.png",
    description:
      "Oberon is a general-purpose programming language first published in 1987 by Niklaus Wirth and the latest member of the Wirthian family of ALGOL-like languages (Euler, ALGOL W, Pascal, Modula, and Modula-2). Oberon was the result of a concentrated effort to increase the power of Modula-2, the direct successor of Pascal, and simultaneously to reduce its complexity. Its principal new feature is the concept of type extension of record types. It permits constructing new data types on the basis of existing ones and to relate them, deviating from the dogma of strictly static typing of data. Type extension is Wirth's way of inheritance reflecting the viewpoint of the parent site. Oberon was developed as part of the implementation of an operating system, also named Oberon at ETH Zurich in Switzerland. The name is from the moon of the planet Uranus, named Oberon. Oberon is still maintained by Wirth and the latest Project Oberon compiler update is dated 6 March 2020. Oberon is designed with a motto attributed to Albert Einstein in mind: “Make things as simple as possible, but not simpler.” The principal guideline was to concentrate on features that are basic and essential and to omit ephemeral issues. Another factor was recognition of the growth of complexity in languages such as C++ and Ada. In contrast to these, Oberon emphasizes the use of the library concept to extend the language. Enumeration and subrange types, which were present in Modula-2, were omitted, and set types are limited to sets of integers. All imported items must be qualified by the name of the module where they are declared. Low-level facilities are highlighted by only allowing them to be used in a module which includes the identifier SYSTEM in its import list. Strict type checking, even across modules, and index checking at runtime, null pointer checking, and the safe type extension concept largely allow programming to rely on the language rules alone. The intent of this strategy was to produce a language that is easier to learn, simpler to implement, and very efficient. Oberon compilers have been viewed as compact and fast, while providing code quality comparable to commercial compilers.",
    Paradigms: "Imperative, structured, modular, object-oriented",
    Family: "Wirth Oberon",
    "Designed by": "Niklaus Wirth",
    Developer: "ETH Zurich",
    "First appeared": "1987; 35 years ago",
    "Stable release": "Oberon-07 / 6 March 2020; 22 months ago",
    "Typing discipline": "Strong, hybrid (static and dynamic)",
    Scope: "Lexical",
    Platform: "ARM, StrongARM; IA-32, x86-64; SPARC, Ceres (NS32032)",
    OS: "Windows, Linux, Solaris, classic Mac OS, Atari TOS, AmigaOS",
    Website: "www.projectoberon.com",
    id: "YUD3",
  },
  {
    name: "OpenEdge Advanced Business Language (ABL)",
    description:
      'It is a family of declarative "ultra high-level" languages. It features abstract types, generic modules, subsorts (subtypes with multiple inheritance), pattern-matching modulo equations, E-strategies (user control over laziness), module expressions (for combining modules), theories and views (for describing module interfaces) for the massively parallel RRM (rewrite rule machine). Members of the OBJ family of languages include CafeOBJ, Eqlog, FOOPS, Kumo, Maude, OBJ2, and OBJ3.  OBJ2 is a programming language with Clear-like parametrised modules and a functional system based on equations. OBJ3 is a version of OBJ based on order-sorted rewriting. OBJ3 is agent-oriented and runs on Kyoto Common Lisp AKCL.',
    id: "-hDh",
  },
  {
    name: "OpenVera",
    description:
      "It was seen as a competitor to other object-oriented extensions to Lisp at around the same time such as Flavors, in use by Symbolics, Common Objects developed by Hewlett-Packard, and CommonLoops, in use by Xerox. Object Lisp was also used in early versions of Macintosh Common Lisp. There, the user interface toolkit was written using Object Lisp.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    id: "J77i",
  },
  {
    name: "Logo",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/FarfalladiIvanaNiccolai.jpg/220px-FarfalladiIvanaNiccolai.jpg",
    description:
      'A general-purpose language, Logo is widely known for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on screen or with a small robot termed a turtle. The language was conceived to teach concepts of programming related to Lisp and only later to enable what Papert called "body-syntonic reasoning", where students could understand, predict, and reason about the turtle\'s motion by imagining what they would do if they were the turtle. There are substantial differences among the many dialects of Logo, and the situation is confused by the regular appearance of turtle graphics programs that are named Logo. Logo is a multi-paradigm adaptation and dialect of Lisp, a functional programming language. There is no standard Logo, but UCBLogo has the best facilities for handling lists, files, I/O, and recursion in scripts, and can be used to teach all computer science concepts, as UC Berkeley lecturer Brian Harvey did in his Computer Science Logo Style trilogy. Logo is usually an interpreted language, although compiled Logo dialects (such as Lhogho and Liogo) have been developed. Logo is not case-sensitive but retains the case used for formatting purposes. Logo was created in 1967 at Bolt, Beranek and Newman (BBN), a Cambridge, Massachusetts research firm, by Wally Feurzeig, Cynthia Solomon, and Seymour Papert. Its intellectual roots are in artificial intelligence, mathematical logic and developmental psychology. The first four years of Logo research, development and teaching work was done at BBN. The first implementation of Logo, called Ghost, was written in LISP on a PDP-1. The goal was to create a mathematical land where children could play with words and sentences. Modeled on LISP, the design goals of Logo included accessible power[clarification needed] and informative error messages. The use of virtual Turtles allowed for immediate visual feedback and debugging of graphic programming.',
    Paradigms:
      "Multi-paradigm: functional, educational, procedural, reflective",
    Family: "Lisp",
    "Designed by": "Wally Feurzeig, Seymour Papert, Cynthia Solomon",
    Developer: "Bolt, Beranek and Newman",
    "First appeared": "1967; 55 years ago",
    "Typing discipline": "dynamic",
    id: "VbBk",
  },
  {
    name: "Object Pascal",
    description:
      "The language was originally developed by Apple Computer as Clascal for the Lisa Workshop development system. As Lisa gave way to Macintosh, Apple collaborated with Niklaus Wirth, the author of Pascal, to develop an officially standardized version of Clascal. This was renamed Object Pascal. Through the mid-1980s, Object Pascal was the main programming language for early versions of the MacApp application framework. The language lost its place as the main development language on the Mac in 1991 with the release of the C++-based MacApp 3.0. Official support ended in 1996. Symantec also developed a compiler for Object Pascal for their Think Pascal product, which could compile programs much faster than Apple's own Macintosh Programmer's Workshop (MPW). Symantec then developed the Think Class Library (TCL), based on MacApp concepts, which could be called from both Object Pascal and THINK C. The Think suite largely displaced MPW as the main development platform on the Mac in the late 1980s. Symantec ported Object Pascal to the PC, and developed a similar object framework on that platform. In contrast to TCL, which eventually migrated to C++, the PC libraries remained mainly based on Pascal. Borland added support for object-oriented programming to Turbo Pascal 5.5, which would eventually become the basis for the Object Pascal dialect used in Delphi. Delphi remained mainstream for business applications on the PC into the early 2000s, and was partly displaced in the 2000s with the introduction of the .NET Framework.",
    Paradigms:
      "Imperative, structured, object-oriented, functional (Delphi dialect only), component-based, event-driven, generic",
    Family: "Wirth Pascal",
    "Designed by":
      "Larry Tesler (Apple) Niklaus Wirth (for Apple) Anders Hejlsberg (Borland)",
    Developers: "Apple Computer (initial) Borland International",
    "First appeared": "1986; 36 years ago",
    "Typing discipline":
      "Static and dynamic (dynamic typing through variants, array of const, and RTTI), strong, safe",
    Scope: "Lexical (static)",
    Platform: "ARM, x86, PowerPC, ppc64, SPARC, MIPS, CLI, Java, Cocoa",
    "Filename extensions": ".p, .pp, .pas",
    id: "cGMB",
  },
  {
    name: "Objective-C",
    description:
      "Objective-C is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language. Originally developed by Brad Cox and Tom Love in the early 1980s, it was selected by NeXT for its NeXTSTEP operating system. Objective-C was the standard programming language supported by Apple for developing macOS (which descended from NeXTSTEP) and iOS applications using their respective application programming interfaces (APIs), Cocoa and Cocoa Touch, until the introduction of Swift in 2014. Objective-C programs developed for non-Apple operating systems or that are not dependent on Apple's APIs may also be compiled for any platform supported by GNU GCC or LLVM/Clang. Objective-C source code 'messaging/implementation' program files usually have .m filename extensions, while Objective-C 'header/interface' files have .h extensions, the same as C header files. Objective-C++ files are denoted with a .mm file extension. Objective-C was created primarily by Brad Cox and Tom Love in the early 1980s at their company Productivity Products International (PPI).",
    Family: "C",
    "Designed by": "Tom Love and Brad Cox",
    "First appeared": "1984; 38 years ago",
    "Stable release": "2.0",
    "Typing discipline": "static, dynamic, weak",
    OS: "Cross-platform",
    "Filename extensions": ".h, .m, .mm, .M",
    Website: "developer.apple.com",
    other_details: {
      type: "programming",
      tm_scope: "source.objc",
      color: "#438eff",
      aliases: ["obj-c", "objc", "objectivec"],
      extensions: [".m", ".h"],
      ace_mode: "objectivec",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-objectivec",
      language_id: 257,
    },
    id: "BV0T",
  },
  {
    name: "Objective-J",
    description:
      "Programs written in Objective-J need to be preprocessed before being run by a web browser's JavaScript virtual machine. This step can occur in the web browser at runtime or by a compiler which translates Objective-J programs into pure JavaScript code. The Objective-J compiler is written in JavaScript; consequently, deploying Objective-J programs does not require a web browser plug-in. Objective-J can be compiled and run on Node.js. The first widely known use of Objective-J was in the Cappuccino-based web application 280 Slides, which was developed by 280 North itself. Even though Objective-J can be used (and has been designed) independently from the Cappuccino framework, Objective-J has primarily been invented to support web development in Cappuccino. Objective-J is a superset of JavaScript, which means that any valid JavaScript code is also valid Objective-J code. The following example shows the definition and implementation in Objective-J of a class named Address; this class extends the root object CPObject, which plays a role similar to the Objective-C's NSObject. This example differs from traditional Objective-C in that the root object reflects the underlying Cappuccino framework as opposed to Cocoa, Objective-J does not use pointers and, as such, type definitions do not contain asterisk characters. Instance variables are always defined in the @implementation.",
    Paradigm:
      "Multi-paradigm: reflective, object-oriented, functional, imperative, scripting",
    Developer: "Cappuccino Core Developers and community.",
    "First appeared": "2008",
    "Typing discipline": "dynamic, weak, duck",
    License: "LGPL",
    Website: "cappuccino-project.org",
    other_details: {
      type: "programming",
      color: "#ff0c5a",
      aliases: ["obj-j", "objectivej", "objj"],
      extensions: [".j", ".sj"],
      tm_scope: "source.js.objj",
      ace_mode: "text",
      language_id: 259,
    },
    id: "FQtl",
  },
  {
    name: "OCaml",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/OCaml_Logo.svg/220px-OCaml_Logo.svg.png",
    description:
      "The OCaml toolchain includes an interactive top-level interpreter, a bytecode compiler, an optimizing native code compiler, a reversible debugger, and a package manager (OPAM). OCaml was initially developed in the context of automated theorem proving, and has an outsize presence in static analysis and formal methods software. Beyond these areas, it has found serious use in systems programming, web development, and financial engineering, among other application domains. The acronym CAML originally stood for Categorical Abstract Machine Language, but OCaml omits this abstract machine. OCaml is a free and open-source software project managed and principally maintained by the French Institute for Research in Computer Science and Automation (INRIA). In the early 2000s, elements from OCaml were adopted by many languages, notably F# and Scala. ML-derived languages are best known for their static type systems and type-inferring compilers. OCaml unifies functional, imperative, and object-oriented programming under an ML-like type system. Thus, programmers need not be highly familiar with the pure functional language paradigm to use OCaml. By requiring the programmer to work within the constraints of its static type system, OCaml eliminates many of the type-related runtime problems associated with dynamically typed languages. Also, OCaml's type-inferring compiler greatly reduces the need for the manual type annotations that are required in most statically typed languages. For example, the data types of variables and the signatures of functions usually need not be declared explicitly, as they do in languages like Java and C#, because they can be inferred from the operators and other functions that are applied to the variables and other values in the code. Effective use of OCaml's type system can require some sophistication on the part of a programmer, but this discipline is rewarded with reliable, high-performance software.",
    Paradigm:
      "Multi-paradigm: functional, imperative, modular, object-oriented",
    Family: "ML",
    "Designed by":
      "Xavier Leroy, Jérôme Vouillon, Damien Doligez, Didier Rémy, Ascánder Suárez",
    Developer: "INRIA",
    "First appeared": "1996; 26 years ago",
    "Stable release": "4.13.1  / 30 September 2021; 3 months ago",
    "Typing discipline": "Inferred, static, strong, structural",
    "Implementation language": "OCaml, C",
    Platform: "IA-32, x86-64, Power, SPARC, ARM 32-64",
    OS: "Cross-platform: Unix, macOS, Windows",
    License: "LGPLv2.1",
    "Filename extensions": ".ml, .mli",
    Website: "ocaml.org",
    other_details: {
      type: "programming",
      ace_mode: "ocaml",
      codemirror_mode: "mllike",
      codemirror_mime_type: "text/x-ocaml",
      color: "#3be133",
      extensions: [".ml", ".eliom", ".eliomi", ".ml4", ".mli", ".mll", ".mly"],
      interpreters: ["ocaml", "ocamlrun", "ocamlscript"],
      tm_scope: "source.ocaml",
      language_id: 255,
    },
    id: "VCvJ",
  },
  {
    name: "occam",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/1983_1988_Trademark_occam_and_occam_2_INMOS_Limited.jpg/220px-1983_1988_Trademark_occam_and_occam_2_INMOS_Limited.jpg",
    description:
      "occam is an imperative procedural language (such as Pascal). It was developed by David May and others at Inmos (trademark INMOS), advised by Tony Hoare, as the native programming language for their transputer microprocessors, but implementations for other platforms are available. The most widely known version is occam 2; its programming manual was written by Steven Ericsson-Zenith and others at Inmos. In the following examples indentation and formatting are critical for parsing the code: expressions are terminated by the end of the line, lists of expressions need to be on the same level of indentation. This feature, named the off-side rule, is also found in other languages such as Haskell and Python. Communication between processes work through named channels. One process outputs data to a channel via ! while another one inputs data with ?. Input and output cannot proceed until the other end is ready to accept or offer data. (In the not proceeding case it is often said that the process blocks on the channel. However, the program will neither spin nor poll; thus terms like wait, hang or yield may also convey the behaviour; also in the context that it will not block other independent processes from running.) Examples (c is a variable): SEQ introduces a list of expressions that are evaluated sequentially. This is not implicit as it is in most other programming languages. Example:",
    Paradigm: "Imperative, procedural, concurrent",
    "Designed by": "David May",
    Developer: "Inmos",
    "First appeared": "1983; 39 years ago",
    "Stable release":
      "2.1 (official), 2.5 (unofficial), 3 (not fully implemented) / 1994; 28 years ago",
    id: "M8DZ",
  },
  {
    name: "GNU Octave",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Gnu-octave-logo.svg/100px-Gnu-octave-logo.svg.png",
    description:
      "The project was conceived around 1988. At first it was intended to be a companion to a chemical reactor design course. Real development was started by John W. Eaton in 1992. The first alpha release dates back to 4 January 1993 and on 17 February 1994 version 1.0 was released. Version 6.4.0 was released on Oct 30, 2021. The program is named after Octave Levenspiel, a former professor of the principal author. Levenspiel was known for his ability to perform quick back-of-the-envelope calculations. In addition to use on desktops for personal scientific computing, Octave is used in academia and industry. For example, Octave was used on a massive parallel computer at Pittsburgh Supercomputing Center to find vulnerabilities related to guessing social security numbers. Acceleration with OpenCL or CUDA is also possible with use of GPUs.",
    "Developer(s)": "John W. Eaton and many others",
    "Initial release":
      "4 January 1993; 29 years ago (first alpha release) 17 February, 1994; 27 years ago (version 1.0)",
    "Stable release": "6.4.0  / 30 October 2021",
    Repository: "hg.savannah.gnu.org/hgweb/octave ",
    "Written in":
      "C++ (main), Octave itself (scripts), C (wrapper code), Fortran (linear algebra wrapper code)",
    "Operating system": "Windows, macOS, Linux, BSD",
    "Available in": "18 languages",
    Type: "Scientific computing",
    License: "2007: GPL-3.0-or-later[a] 1992: GPL-2.0-or-later[b]",
    Website: "gnu.org/software/octave/",
    id: "ziQH",
  },
  {
    name: "ParaSail",
    description:
      "OmniMark is used to process data, and convert it from one format to another, using a streaming architecture that allows it to handle large volumes of content sequentially without having to keep it all in memory. It has a built-in XML parser, and support for XQuery via integration with Sedna native XML database. It also has features to process find rules which implement a similar concept to regular expressions, although the pattern expression syntax is more English-like than the regular expression syntax used in Perl and other languages like the Ruby programming language, both of which are more widely used than OmniMark. OmniMark can also be used for schema transformation tasks in the same way as XSLT, but supports switching between procedural and functional code without the need for any additional constructs to support the procedural elements. OmniMark was originally created in the 1980s by Exoterica, a Canadian software company, as a SGML processing program called XTRAN. XTRAN was later renamed OmniMark, and Exoterica became OmniMark Technologies. The current owners of OmniMark, Stilo International, have their main offices in the UK but also maintain an office in Canada. In 1999, OmniMark president and CEO John McFadden announced that OmniMark 5 would be available free of charge, to better compete with Perl. OmniMark is no longer distributed under such a model. OmniMark treats input as a flow that can be scanned once, rather than as a static collection of data that supports random access. Much of an OmniMark program is in the form of condition=>action rule where the condition recognizes a length of data to be acted upon and the action specifies what is to be done with the data. There are two kinds of condition:",
    id: "AGLq",
  },
  {
    name: "Opa",
    image: "https://upload.wikimedia.org/wikipedia/en/6/64/Opa_logo_cloud.png",
    description:
      "It can be used for both client-side and server-side scripting, where complete programs are written in Opa and subsequently compiled to Node.js on the server and JavaScript on the client, with the compiler automating all communication between the two. Opa implements strong, static typing, which can be helpful in protecting against security issues such as SQL injections and cross-site scripting attacks. The language was first officially presented at the OWASP conference in 2010, and the source code was released on GitHub in June 2011, under a GNU Affero General Public License. Later, the license changed to the MIT license for the framework part (library) and AGPL for the compiler so that applications written in Opa can be released under any license, proprietary or open source. Opa consists of a web server, a database and distributed execution engine. Code written in Opa is compiled to JavaScript using Node.js on the server side and to JavaScript using jQuery for cross-browser compatibility on the client side. The advantage of the approach compared to certain Rich Internet Application (RIA) platforms is that users are not required to install a plugin in their browser. Opa shares motivations with web frameworks, but takes a different approach. Its designers assert that this helps Opa to avoid many security issues, like SQL injections or cross-site scripting (XSS) attacks. The core language is functional and has a static type system with type inference. Opa also provides sessions which encapsulate an imperative state and communicate using message passing, similar to Erlang processes. Opa provides many structures or functions that are common in web development, as first-class objects, for instance HTML and parsers, based on Parsing Expression Grammars. Because of this adhesion between the language and web-related concepts, Opa is not intended for non-web applications (for instance desktop applications).",
    Paradigm: "multi-paradigm: functional, imperative",
    Developer: "MLstate",
    "First appeared": "2011",
    "Stable release": "1.1.1 (stable) / March 8, 2014; 7 years ago",
    "Typing discipline": "static, strong, inferred",
    OS: "Linux, OS X, Windows",
    License: "MIT License, AGPLv3",
    Website: "opalang.org",
    other_details: {
      type: "programming",
      extensions: [".opa"],
      ace_mode: "text",
      language_id: 261,
    },
    id: "iykl",
  },
  {
    name: "Open Programming Language (OPL)",
    description:
      "It can be found on the Nokia 9200, 9300 and 9500 Communicator series mobile telephone/personal digital assistant (PDA) and the Sony Ericsson P800, P900, P910 series. On classic Psion PDAs such as the Series 3, 5/5mx, Series 7, and netBook/netPad, as well as the MC218, OPL is part of the standard application suite. OPL is also included in Psion Teklogix industrial handhelds such as the Workabout mx. OPL is an interpreted language similar to BASIC. A fully Visual Basic-compatible language OVAL has been also developed. The language was originally called Organiser Programming Language, developed by Psion Ltd for the Psion Organiser. Designed by Colly Myers with the first iteration implemented by Richard Harrison and Martin Stamp. The first implementation (without graphics) was for the original Psion Organiser (now referred to as the Psion Organiser I, 1984), and it came bundled with the Science, Finance and Math data packs. It became truly accessible as built-in software in the Psion Organiser II (1986), and the language went on to be used in the Psion Series 3 and later. After Psion retired from the portable digital assistant market, the project was delayed until 2003, when the fledgling Symbian Developer Program released it as open source. The language is now developed on SourceForge in the opl-dev project.[clarification needed] The language is not available from Symbian OS v8 and later, mainly due to lack of interest and support from major Symbian licencees Nokia and Sony Ericsson.[citation needed] Hence, OPL will most likely never be made available for the newer generation of Symbian OS phones such as Sony Ericsson P990, M600,[citation needed] W950, P1i and Nokia E61i and E90. As of 2010, Nokia device developers are encouraged to use Python for S60 instead (See Python for S60).[citation needed] Here is the console version of a Hello world program:",
    Paradigm: "imperative, structured, embedded",
    "Designed by": "Psion Ltd",
    Developer: "opl-dev project",
    "First appeared": "1984",
    "Stable release": "1.56 / June 17, 2006 / June 17, 2006",
    OS: "Symbian OS, Psion Organiser",
    License: "GNU Lesser Public License",
    Website: "opl-dev.sourceforge.net",
    id: "aOhn",
  },
  {
    name: "OpenCL API",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/OpenCL_logo.svg/200px-OpenCL_logo.svg.png",
    description:
      "OpenCL C 3.0 revision V3.0.7 C++ for OpenCL 1.0 revision 2 OpenCL (Open Computing Language) is a framework for writing programs that execute across heterogeneous platforms consisting of central processing units (CPUs), graphics processing units (GPUs), digital signal processors (DSPs), field-programmable gate arrays (FPGAs) and other processors or hardware accelerators. OpenCL specifies programming languages (based on C99, C++14 and C++17) for programming these devices and application programming interfaces (APIs) to control the platform and execute programs on the compute devices. OpenCL provides a standard interface for parallel computing using task- and data-based parallelism. OpenCL is an open standard maintained by the non-profit technology consortium Khronos Group. Conformant implementations are available from Altera, AMD, ARM, Creative, IBM, Imagination, Intel, Nvidia, Qualcomm, Samsung, Vivante, Xilinx, and ZiiLABS.",
    "Original author(s)": "Apple Inc.",
    "Developer(s)": "Khronos Group",
    "Initial release": "August 28, 2009; 12 years ago",
    "Stable release":
      "OpenCL C++ 1.0 revision V2.2-11  OpenCL C 3.0 revision V3.0.7  C++ for OpenCL 1.0 revision 2  / March 31, 2021; 9 months ago",
    "Written in": "C with C++ bindings",
    "Operating system":
      "Android (vendor dependent), FreeBSD, Linux, macOS (via Pocl), Windows",
    Platform: "ARMv7, ARMv8, Cell, IA-32, Power, x86-64",
    Type: "Heterogeneous computing API",
    License: "OpenCL specification license",
    Website: "www.khronos.org/opencl",
    Paradigm:
      "Imperative (procedural), structured, (C++ only) object-oriented, generic programming",
    Family: "C",
    "Typing discipline": "Static, weak, manifest, nominal",
    "Implementation language": "Implementation specific",
    "Filename extensions": ".cl .clcpp",
    id: "Ao8m",
  },
  {
    name: "OpenEdge Advanced Business Language (ABL)",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/5/58/OpenEdge_logo.png/220px-OpenEdge_logo.png",
    description:
      "OpenEdge ABL helps developers to develop applications optionally using its own integrated relational database and programming tool. These applications are portable across computing systems and allow access to various popular data sources without having to learn the underlying data access methods. This means that the end-user of these products can be unaware of the underlying architecture. By combining a fourth generation language and relational database, OpenEdge ABL allows the use of the Rapid Application Development (RAD) model for developing software. A programmer and even end users can do rapid prototyping using the integrated and GUI tools of the development environment. OpenEdge can be used for: The original Progress 4GL was designed (in 1981) as an architecture independent language and integrated database system that could be used by non-experts to develop business applications by people who were not computer scientists but were knowledgeable in their business domain. At the time, business applications were often written in COBOL (for machines like corporate IBM mainframes) and sometimes in C (for departmental minicomputers running the UNIX operating system). When the IBM PC became popular, it developed a need for business software that could be used on those and other inexpensive computers. The Progress system was created to be used on both IBM PC machines running DOS and on a variety of computers that could run UNIX.",
    "Developer(s)": "Progress Software Corporation",
    "Stable release": "OpenEdge 12.3 / October 20, 2020; 14 months ago",
    "Operating system": "Cross-platform (see below)",
    Type: "RDBMS",
    License: "Proprietary",
    Website: "https://www.progress.com/openedge",
    id: "n3HF",
  },
  {
    name: "PeopleCode",
    description:
      'The OPS (said to be short for "Official Production System") family was developed in the late 1970s by Charles Forgy while at Carnegie Mellon University. Allen Newell\'s research group in artificial intelligence had been working on production systems for some time, but Forgy\'s implementation, based on his Rete algorithm, was especially efficient, sufficiently so that it was possible to scale up to larger problems involving hundreds or thousands of rules. OPS5 uses a forward chaining inference engine; programs execute by scanning "working memory elements" (which are vaguely object-like, with classes and attributes) looking for matches with the rules in "production memory". Rules have actions that may modify or remove the matched element, create new ones, perform side effects such as output, and so forth. Execution continues until no more matches can be found. In this sense, OPS5 is an execution engine for a Petri net extended with inhibitor arcs. The OPS5 forward chaining process makes it extremely parallelizeable during the matching phase, and several automatic parallelizing compilers were created.',
    id: "mWRx",
  },
  {
    name: "OptimJ",
    description:
      "OptimJ models are directly compatible with Java source code, existing Java libraries such as database access, Excel connection or graphical interfaces. OptimJ is compatible with development tools such as Eclipse, CVS, JUnit or JavaDoc. OptimJ is available free with the following solvers: lp_solve, glpk, LP or MPS file formats and also supports the following commercial solvers: MOSEK, IBM ILOG CPLEX Optimization Studio. OptimJ combines concepts from object-oriented imperative languages with concepts from algebraic modeling languages for optimization problems. Here we will review the optimization concepts added to Java, starting with a concrete example. The goal of a map coloring problem is to color a map so that regions sharing a common border have different colors. It can be expressed in OptimJ as follows. Readers familiar with Java will notice a strong similarity with this language. Indeed, OptimJ is a conservative extension of Java: every valid Java program is also a valid OptimJ program and has the same behavior.",
    Paradigm: "object-oriented",
    "Designed by": "Ateji",
    "First appeared": "2006",
    Website: "www.Ateji.com",
    id: "rRnP",
  },
  {
    name: "ORCA/Modula-2",
    description:
      "It was developed by Peter Easdown during 1993–94 and published by The Byte Works. Whilst originally developed separately, when it was finally published, it was fully integrated with the development platform/environment called the Apple Programmers Workshop or ORCA/M. The compiler was originally developed using a version of TopSpeed Modula-2 on an Intel 80286 based PC. The output of the compiler at this point was 65816 assembler source for assembly by ORCA/M on the Apple IIGS. Once the compiler was stable enough, the IBM PC was decommissioned, and all development was done on the Apple IIGS. At publication, the compiler was shipped with comprehensive support for the Apple IIGS's operating system (GS/OS) and toolkit. Unfortunately, due to the demise of the Apple IIGS, ORCA/Modula-2 never had much impact in the market.",
    "Original author(s)": "Peter Easdown",
    "Developer(s)": "The Byte Works",
    "Initial release": "about 1994; 28 years ago",
    "Written in": "Modula-2",
    Platform: "Apple IIGS",
    Type: "compiler",
    id: "TJJ1",
  },
  {
    name: "Oriel",
    image:
      "https://upload.wikimedia.org/wikipedia/en/9/97/The_Oriel_for_Windows_Logo.png",
    description:
      "The suggested extension for an Oriel script file was ORL. Oriel was distributed with two executables: ORIEL.EXE, and MKRUNTIM.EXE. The former was the Oriel interpreter, which when invoked would prompt the user to choose a script file for execution. The latter gave the user the ability to create custom executables by bundling a script within a copy of the interpreter. In this way, an Oriel program could be distributed and run in the same way as any other Windows EXE. The language was named after the oriel style of bay window. A window of that style is depicted in the icon distributed with the runtime. The following program displays a modal dialog box containing a hello, world message. An Oriel program will always possess a main window over which a dialog box of this type would appear. The following code gives that window a title, maximizes it, and instructs it to remain open until the user closes it. This code also demonstrates retrieval of window information and use of string variables. A function call of SetWindow(MAXIMIZE) could replace the second and third lines.",
    Paradigm: "Imperative, Procedural",
    "Designed by": "The LeBlond Group, Inc.",
    "First appeared": "1991",
    OS: "Microsoft Windows",
    id: "dhDi",
  },
  {
    name: "Oxygene",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/9/9e/Chrome-128.png/220px-Chrome-128.png",
    description:
      'Compared to the now deprecated Delphi.NET, Oxygene does not emphasize total backward compatibility, but is designed to be a "reinvention" of the language, be a good citizen on the managed development platforms, and leverage all the features and technologies provided by the .NET and Java runtimes. Oxygene is a commercial product and offers full integration into Microsoft\'s Visual Studio IDE on Windows, as well as its own IDE called Fire for use on macOS. The command-line compiler is available for free. Oxygene is one of six languages supported by the underlying Elements Compiler toolchain, next to C#, Swift, Java, Go and Mercury (based on Visual Basic.NET). From 2008 to 2012, RemObjects Software licensed its compiler and IDE technology to Embarcadero to be used in their Embarcadero Prism product. Starting in the Fall of 2011, Oxygene became available in two separate editions, with the second edition adding support for the Java and Android runtimes. Starting with the release of XE4, Embarcadero Prism is no longer part of the RAD Studio SKU. Numerous support and upgrade paths for Prism customers exist to migrate to Oxygene. As of 2016, there is only one edition of Oxygene, which allows development on Windows or macOS, and which can create executables for Windows, Linux, WebAssembly .NET, iOS, Android, Java and macOS. The Oxygene language has its origins in Object Pascal in general and Delphi in particular, but was designed to reflect the guidelines of .NET programming and to create fully CLR-compliant assemblies. Therefore, some minor language features known from Object Pascal / Delphi have been dropped or revised, while a slew of new and more modern features, such as Generics or Sequences and Queries have been added to the language.',
    Developer: "RemObjects Software",
    "First appeared": "2005; 17 years ago",
    Platform:
      "Common Language Infrastructure, Java, Cocoa, CPU-Native, Windows 32/64 bit, Linux 32/64 bit, WebAssembly",
    License: "Trialware",
    Website: "elementscompiler.com/elements/oxygene/",
    other_details: {
      type: "programming",
      color: "#cdd0e3",
      extensions: [".oxygene"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 269,
    },
    id: "S9jE",
  },
  {
    name: "Oz",
    description:
      "Oz is a multiparadigm programming language, developed in the Programming Systems Lab at Université catholique de Louvain, for programming language education. It has a canonical textbook: Concepts, Techniques, and Models of Computer Programming. Oz was first designed by Gert Smolka and his students in 1991. In 1996, development of Oz continued in cooperation with the research group of Seif Haridi and Peter Van Roy at the Swedish Institute of Computer Science. Since 1999, Oz has been continually developed by an international group, the Mozart Consortium, which originally consisted of Saarland University, the Swedish Institute of Computer Science, and the Université catholique de Louvain. In 2005, the responsibility for managing Mozart development was transferred to a core group, the Mozart Board, with the express purpose of opening Mozart development to a larger community. The Mozart Programming System is the primary implementation of Oz. It is released with an open source license by the Mozart Consortium. Mozart has been ported to Unix, FreeBSD, Linux, Windows, and macOS. Oz contains most of the concepts of the major programming paradigms, including logic, functional (both lazy evaluation and eager evaluation), imperative, object-oriented, constraint, distributed, and concurrent programming. Oz has both a simple formal semantics (see chapter 13 of the book mentioned below) and an efficient implementation.[citation needed] Oz is a concurrency-oriented language, as the term was introduced by Joe Armstrong, the main designer of the Erlang language. A concurrency-oriented language makes concurrency easy to use and efficient. Oz supports a canonical graphical user interface (GUI) language QTk.",
    Paradigm:
      "multi-paradigm: logic, functional, imperative, object-oriented, constraint, distributed, concurrent",
    "Designed by": "Gert Smolka, his students",
    Developer: "Mozart Consortium",
    "First appeared": "1991; 31 years ago",
    "Stable release":
      "Oz 1.4.0 (final), Mozart 2.0.1 / 5 September 2018; 3 years ago",
    "Typing discipline": "dynamic",
    License: "MIT X11",
    Website: "mozart.github.io",
    other_details: {
      type: "programming",
      color: "#fab738",
      extensions: [".oz"],
      tm_scope: "source.oz",
      ace_mode: "text",
      codemirror_mode: "oz",
      codemirror_mime_type: "text/x-oz",
      language_id: 270,
    },
    id: "0zpW",
  },
  {
    name: "P4",
    description:
      'P4 was originally described in a 2014 SIGCOMM CCR paper titled “Programming Protocol-Independent Packet Processors”—the alliterative name shortens to "P4". The first P4 workshop took place in June 2015 at Stanford University. An updated specification of P4, called P4-16, was released between 2016 and 2017, replacing P4-14, the original specification of P4. As the language is specifically targeted at packet forwarding applications, the list of requirements or design choices is somewhat unusual to those use cases. The language is designed to meet several goals: P4 programs are designed to be implementation-independent: they can be compiled against many different types of execution machines such as general-purpose CPUs, FPGAs, system(s)-on-chip, network processors, and ASICs. These different types of machines are known as P4 targets, and each target must be provided along with a compiler that maps the P4 source code into a target switch model. The compiler may be embedded in the target device, an externally running software, or even a cloud service. As many of the initial targets for P4 programs were used for simple packet switching it is very common to hear the term "P4 switch" used, even though "P4 target" is more formally correct. P4 is designed to be protocol-independent: the language has no native support for even common protocols such as IP, Ethernet, TCP, VxLAN, or MPLS. Instead, the P4 programmer describes the header formats and field names of the required protocols in the program, which are in turn interpreted and processed by the compiled program and target device.',
    Paradigm: "compiled, domain-specific, imperative",
    Developer: "The P4 Language Consortium",
    "First appeared": "2013; 9 years ago",
    "Stable release": "version 1.2 / 23 October 2019; 2 years ago",
    License: "Apache-style",
    "Filename extensions": ".p4",
    Website: "p4.org",
    other_details: {
      type: "programming",
      color: "#7055b5",
      extensions: [".p4"],
      tm_scope: "source.p4",
      ace_mode: "text",
      language_id: 348895984,
    },
    id: "f01F",
  },
  {
    name: "P′′",
    description:
      "{\\textstyle {\\mathcal {P}}^{\\prime \\prime }}  (hereinafter written P′′) is formally defined as a set of words on the four-instruction alphabet  {\\textstyle \\{R,\\lambda ,(,)\\}} , as follows: Böhm gives the following program to compute the predecessor (x-1) of an integer x > 0: which translates directly to the equivalent Brainfuck program: The program expects an integer to be represented in bijective base-k notation, with  {\\textstyle c_{1},c_{2}\\ldots ,c_{k}}  encoding the digits  {\\textstyle 1,2,\\ldots ,k}  respectively, and to have  {\\textstyle \\Box }  before and after the digit-string. (E.g., in bijective base-2, the number eight would be encoded as  {\\textstyle \\Box c_{1}c_{1}c_{2}\\Box } , because 8 in bijective base-2 is 112.) At the beginning and end of the computation, the tape-head is on the  {\\textstyle \\Box }  preceding the digit-string.",
    Paradigm: "Imperative, structured",
    "Designed by": "Corrado Böhm",
    "First appeared": "1964",
    "Typing discipline": "untyped",
    id: "SD75",
  },
  {
    name: "ParaSail",
    image:
      "https://upload.wikimedia.org/wikipedia/en/c/c1/Logo_for_ParaSail_Programming_Language.jpg",
    description:
      "Parallel Specification and Implementation Language (ParaSail) is an object-oriented parallel programming language. Its design and ongoing implementation is described in a blog and on its official website. ParaSail uses a pointer-free programming model, where objects can grow and shrink, and value semantics are used for assignment. It has no global garbage collected heap. Instead, region-based memory management is used throughout. Types can be recursive, so long as the recursive components are declared optional. There are no global variables, no parameter aliasing, and all subexpressions of an expression can be evaluated in parallel. Assertions, preconditions, postconditions, class invariants, etc., are part of the standard syntax, using a Hoare-like notation. Any possible race conditions are detected at compile time. Initial design of ParaSail began in September 2009, by S. Tucker Taft. Both an interpreter using the ParaSail virtual machine, and an LLVM-based ParaSail compiler are available. Work stealing is used for scheduling ParaSail's light-weight threads. The latest version can be downloaded from the ParaSail website.",
    Paradigm: "compiled, concurrent, imperative, structured, object-oriented",
    "Designed by": "S. Tucker Taft",
    Developer: "AdaCore",
    "First appeared": "2009; 13 years ago",
    "Stable release": "8.4 / 2 November 2019; 2 years ago",
    "Typing discipline": "strong, static",
    Platform: "x86",
    OS: "Linux, macOS, Windows",
    License: "GPL v3",
    "Filename extensions": ".psi, .psl",
    Website: "parasail-lang.org",
    id: "jlgr",
  },
  {
    name: "PARI/GP",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/PARI-GP_logo.svg/116px-PARI-GP_logo.svg.png",
    description:
      "The PARI/GP system is a package that is capable of doing formal computations on recursive types at high speed; it is primarily aimed at number theorists. Its three main strengths are its speed, the possibility of directly using data types that are familiar to mathematicians, and its extensive algebraic number theory module. The PARI/GP system consists of the following standard components: Also available is gp2c, the GP-to-C compiler, which compiles GP scripts into the C language and transparently loads the resulting functions into gp. The advantage of this is that gp2c-compiled scripts will typically run three to four times faster. gp2c understands almost all of GP. PARI/GP performs arbitrary precision calculations (e.g., the significand can be millions of digits long—and billions of digits on 64-bit machines). It can compute factorizations, perform elliptic curve computations and perform algebraic number theory calculations. It also allows computations with matrices, polynomials, power series, algebraic numbers and implements many special functions.",
    "Developer(s)":
      "Henri Cohen, Karim Belabas, et al., at the Université Bordeaux 1",
    "Stable release": "2.13.3 / 11 October 2021; 3 months ago",
    Repository: "pari.math.u-bordeaux.fr/git/pari.git ",
    "Written in": "C",
    "Operating system": "Cross-platform",
    Type: "Computer algebra system",
    License: "GNU General Public License",
    Website: "pari.math.u-bordeaux.fr",
    id: "xgAU",
  },
  {
    name: "Pascal",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/LagrangePAS.png/300px-LagrangePAS.png",
    description:
      "Based on Wirth's book Algorithms + Data Structures = Programs, Pascal was developed on the pattern of the ALGOL 60 language. Wirth was involved in the process to improve the language as part of the ALGOL X efforts and proposed a version named ALGOL W. This was not accepted, and the ALGOL X process bogged down. In 1968, Wirth decided to abandon the ALGOL X process and further improve ALGOL W, releasing this as Pascal in 1970. On top of ALGOL's scalars and arrays, Pascal enables defining complex datatypes and building dynamic and recursive data structures such as lists, trees and graphs. Pascal has strong typing on all objects, which means that one type of data cannot be converted to or interpreted as another without explicit conversions. Unlike C (and most languages in the C-family), Pascal allows nested procedure definitions to any level of depth, and also allows most kinds of definitions and declarations inside subroutines (procedures and functions). A program is thus syntactically similar to a single procedure or function. This is similar to the block structure of ALGOL 60, but restricted from arbitrary block statements to just procedures and functions. Pascal became very successful in the 1970s, notably on the burgeoning minicomputer market. Compilers were also available for many microcomputers as the field emerged in the late 1970s. It was widely used as a teaching language in university-level programming courses in the 1980s, and also used in production settings for writing commercial software during the same period. It was displaced by the C programming language during the late 1980s and early 1990s as UNIX-based systems became popular, and especially with the release of C++. A derivative named Object Pascal designed for object-oriented programming was developed in 1985. This was used by Apple Computer and Borland in the late 1980s and later developed into Delphi on the Microsoft Windows platform. Extensions to the Pascal concepts led to the languages Modula-2 and Oberon.",
    Paradigm: "Imperativestructured",
    Family: "Wirth Pascal",
    "Designed by": "Niklaus Wirth",
    "First appeared": "1970; 52 years ago",
    "Typing discipline": "Staticstrongsafe",
    Scope: "Lexical",
    "Filename extensions": ".pp, .pas, .inc",
    other_details: {
      type: "programming",
      color: "#E3F171",
      extensions: [".pas", ".dfm", ".dpr", ".inc", ".lpr", ".pascal", ".pp"],
      interpreters: ["instantfpc"],
      ace_mode: "pascal",
      codemirror_mode: "pascal",
      codemirror_mime_type: "text/x-pascal",
      language_id: 281,
    },
    id: "IGGh",
  },
  {
    name: "Pascal Script",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/Pascal_Script_3_Lazarus_IDE.png/300px-Pascal_Script_3_Lazarus_IDE.png",
    description:
      "Pascal Script supports the majority of Object Pascal constructs, making it partly compatible to Delphi, Free Pascal and GNU Pascal. Initially developed by Carlo Kok as CajScript and renamed to Innerfuse Pascal Script with version 2.23, the software was taken over by RemObjects, renamed again to RemObjects Pascal Script and offered as open source software for the Delphi IDE. Beginning with version 2.07 CajScript has been ported to Free Pascal. Since 2017 Pascal Script is included as a standard component in the Lazarus IDE. Pascal Script can be used by installer scripts for Inno Setup, an open source setup engine. Using Pascal Script may provide additional flexibility during installation and uninstallation, e. g. by adding new wizard pages, calling DLLs and providing custom behaviour and install conditions. Pascal Script is also used for server-side scripting in Pascal Server Pages and maXbox, a scripter studio with an inbuild Delphi engine.",
    Paradigm: "Procedural, object-oriented, scripting",
    Developer:
      "Carlo Kok, Innerfuse, RemObjects, Lazarus and Free Pascal teams",
    "First appeared": "2000; 22 years ago",
    "Stable release": "3.0",
    "Typing discipline": "Strong",
    OS: "Linux, macOS, Windows",
    License: "Custom open-source license",
    "Filename extensions": ".pas",
    id: "C-i-",
  },
  {
    name: "PCASTL",
    description:
      'The "Hello world program" is quite simple: or will do the same. The syntax of PCASTL is derived from programming languages C and R. The source of R version 2.5.1 has been studied to write the grammar and the lexer used in the PCASTL interpreter.',
    Paradigm: "imperative, reflective",
    "Designed by": "Philippe Choquette",
    Developer: "Philippe Choquette",
    "First appeared": "2008; 14 years ago",
    "Stable release": "3.5 / March 31, 2018; 3 years ago",
    OS: "Cross-platform",
    License: "GNU Lesser General Public License",
    Website: "www.pcosmos.ca/pcastl/",
    id: "NF0m",
  },
  {
    name: "PL/I – ISO 6160",
    description:
      "A fully abstract model for PCF was first given by Milner (1977). However, since Milner's model was essentially based on the syntax of PCF it was considered less than satisfactory (Ong, 1995). The first two fully abstract models not employing syntax were formulated during the 1990s. These models are based on game semantics (Hyland and Ong, 2000; Abramsky, Jagadeesan, and Malacaria, 2000) and Kripke logical relations (O'Hearn and Riecke, 1995). For a time it was felt that neither of these models was completely satisfactory, since they were not effectively presentable. However, Ralph Loader demonstrated that no effectively presentable fully abstract model could exist, since the question of program equivalence in the finitary fragment of PCF is not decidable. The types of PCF are inductively defined as A context is a list of pairs x : σ, where x is a variable name and σ is a type, such that no variable name is duplicated. One then defines typing judgments of terms-in-context in the usual way for the following syntactical constructs: A relatively straightforward semantics for the language is the Scott model. In this model,",
    id: "xhBv",
  },
  {
    name: "PL/M",
    description:
      "PEARL supports both fixed-point and floating-point numeric values, character and character string data as well as bit values. It also provides facilities for structures and multi-dimensional arrays. Both typed and untyped pointers are also supported, along with typecasting. PEARL is a higher programming language, which allows a comfortable, secure and almost processor independent programming of multitasking and realtime problems and has been standardized since 1977 at various stages of its development, the last time 1998 as PEARL-90 (DIN 66253-2 1998, Berlin, Beuth-Verlag, 1998). Besides the simple possibility to map process technical problems, an important principle at the development of PEARL was the easy learning by the programmer. All basic data types and language structures of other procedural programming languages exist in PEARL. In addition PEARL offers comfortable language elements for the handling of multitasking- and realtime tasks.",
    id: "yFNm",
  },
  {
    name: "PeopleCode",
    description:
      "PeopleCode supports the following types of functions: In addition, PeopleCode supports methods. The main differences between a built-in function and a method are: The values for the bind variables can be omitted and supplied later. For Insert, Update, or Delete commands these values would be supplied using Execute method. (If all the necessary input values are supplied, the SQL is executed immediately.) PeopleCode Functions, retrieved 2008-12-14",
    Paradigm: "multi-paradigm: object-oriented, imperative",
    Developer: "Oracle Corporation",
    id: "AVoW",
  },
  {
    name: "Perl",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/5/56/Perl_language_logo.svg/120px-Perl_language_logo.svg.png",
    description:
      'Perl is a family of two high-level, general-purpose, interpreted, dynamic programming languages. "Perl" refers to Perl 5, but from 2000 to 2019 it also referred to its redesigned "sister language", Perl 6, before the latter\'s name was officially changed to Raku in October 2019. Though Perl is not officially an acronym, there are various backronyms in use, including "Practical Extraction and Reporting Language". Perl was developed by Larry Wall in 1987 as a general-purpose Unix scripting language to make report processing easier. Since then, it has undergone many changes and revisions. Raku, which began as a redesign of Perl 5 in 2000, eventually evolved into a separate language. Both languages continue to be developed independently by different development teams and liberally borrow ideas from each other. The Perl languages borrow features from other programming languages including C, shell script (sh), AWK, and sed; They provide text processing facilities without the arbitrary data-length limits of many contemporary Unix command line tools. Perl 5 gained widespread popularity in the late 1990s as a CGI scripting language, in part due to its powerful regular expression and string parsing abilities. In addition to CGI, Perl 5 is used for system administration, network programming, finance, bioinformatics, and other applications, such as for GUIs. It has been nicknamed "the Swiss Army chainsaw of scripting languages" because of its flexibility and power, and also its ugliness. In 1998, it was also referred to as the "duct tape that holds the Internet together," in reference to both its ubiquitous use as a glue language and its perceived inelegance.',
    Paradigm:
      "Multi-paradigm: functional, imperative, object-oriented (class-based), reflective",
    "Designed by": "Larry Wall",
    Developer: "Larry Wall",
    "First appeared": "February 1, 1988; 33 years ago",
    "Stable release":
      "5.34.0 / 20 May 2021; 7 months ago 5.32.1 / 23 January 2021; 11 months ago",
    "Preview release": "5.35.5 / October 21, 2021; 2 months ago",
    "Typing discipline": "Dynamic",
    "Implementation language": "C",
    OS: "Cross-platform",
    License: "Artistic License 1.0 or GNU General Public License",
    "Filename extensions": ".plx, .pl, .pm, .xs, .t, .pod, .cgi",
    Website: "www.perl.org",
    other_details: {
      type: "programming",
      tm_scope: "source.perl",
      ace_mode: "perl",
      codemirror_mode: "perl",
      codemirror_mime_type: "text/x-perl",
      color: "#0298c3",
      extensions: [
        ".pl",
        ".al",
        ".cgi",
        ".fcgi",
        ".perl",
        ".ph",
        ".plx",
        ".pm",
        ".psgi",
        ".t",
      ],
      filenames: ["Makefile.PL", "Rexfile", "ack", "cpanfile"],
      interpreters: ["cperl", "perl"],
      aliases: ["cperl"],
      language_id: 282,
    },
    id: "57zW",
  },
  {
    name: "Perl Data Language (PDL)",
    description:
      "PDL is a vectorized array programming language: the expression syntax is a variation on standard mathematical vector notation, so that the user can combine and operate on large arrays with simple expressions. In this respect, PDL follows in the footsteps of the APL programming language, and it has been compared to commercial languages such as MATLAB and Interactive Data Language, and to other free languages such as NumPy and Octave. Unlike MATLAB and IDL, PDL allows great flexibility in indexing and vectorization: for example, if a subroutine normally operates on a 2-D matrix array, passing it a 3-D data cube will generally cause the same operation to happen to each 2-D layer of the cube. PDL borrows from Perl at least three basic types of program structure: imperative programming, functional programming, and pipeline programming forms may be combined. Subroutines may be loaded either via a built-in autoload mechanism or via the usual Perl module mechanism. PDL-like functionality is being included in the development of Raku. True to the glue language roots of Perl, PDL borrows from several different modules for graphics and plotting support. NetPBM provides image file I/O (though FITS is supported natively). Gnuplot, PLplot, PGPLOT, and Prima modules are supported for 2-D graphics and plotting applications, and Gnuplot and OpenGL are supported for 3-D plotting and rendering. PDL provides facilities to read and write many open data formats, including JPEG, PNG, GIF, PPM, MPEG, FITS, NetCDF, GRIB, raw binary files, and delimited ASCII tables. PDL programmers can use the CPAN Perl I/O libraries to read and write data in hundreds of standard and niche file formats.",
    Paradigm: "Array",
    Developer:
      "Karl Glazebrook, Jarle Brinchmann, Tuomas Lukka, and Christian Soeller",
    "First appeared": "1996",
    "Stable release": "2.057 / 13 August 2021; 4 months ago",
    OS: "Cross-platform",
    License: "GNU General Public License, Artistic License",
    Website: "pdl.perl.org",
    id: "O3sE",
  },
  {
    name: "Pharo",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Pharo_Logo_v3.0.svg/194px-Pharo_Logo_v3.0.svg.png",
    description:
      "Pharo is an open source, cross-platform implementation of the classic Smalltalk-80 programming language and runtime. It's based on the OpenSmalltalk virtual machine called Cog (VM), : 16  which evaluates a dynamic, reflective, and object-oriented programming language with a syntax closely resembling Smalltalk-80. Pharo is shipped with a source code compiled into a system image that contains all software necessary to run Pharo system.: 16  Like the original Smalltalk-80, Pharo provides several live programming features such as immediate object manipulation, live updates, and just-in-time compilation. The image includes an IDE-like software to modify its components. Pharo was forked from Squeak v3.9 in March of 2008.: 10  Pharo is a pure object-oriented dynamically typed and reflective language. The stated goal of Pharo is to revisit Smalltalk design and enhance it.",
    Paradigm: "Object-oriented",
    Developer: "Pharo community",
    "First appeared": "2008; 14 years ago",
    "Stable release": "9.0 / July 15, 2021; 6 months ago",
    "Typing discipline": "Dynamic",
    "Implementation language": "Smalltalk",
    OS: "Windows, Linux, macOS, others",
    License: "MIT license, partly Apache License 2.0",
    Website: "pharo.org",
    id: "kgMF",
  },
  {
    name: "PHP",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/27/PHP-logo.svg/220px-PHP-logo.svg.png",
    description:
      "since version 7.0: PHP is a general-purpose scripting language geared towards web development. It was originally created by Danish-Canadian programmer Rasmus Lerdorf in 1994. The PHP reference implementation is now produced by The PHP Group. PHP originally stood for Personal Home Page, but it now stands for the recursive initialism PHP: Hypertext Preprocessor. PHP code is usually processed on a web server by a PHP interpreter implemented as a module, a daemon or as a Common Gateway Interface (CGI) executable. On a web server, the result of the interpreted and executed PHP code – which may be any type of data, such as generated HTML or binary image data – would form the whole or part of an HTTP response. Various web template systems, web content management systems, and web frameworks exist which can be employed to orchestrate or facilitate the generation of that response. Additionally, PHP can be used for many programming tasks outside the web context, such as standalone graphical applications and robotic drone control. PHP code can also be directly executed from the command line. The standard PHP interpreter, powered by the Zend Engine, is free software released under the PHP License. PHP has been widely ported and can be deployed on most web servers on a variety of operating systems and platforms.",
    Paradigm:
      "Multi-paradigm: imperative, functional, object-oriented, procedural, reflective",
    "Designed by": "Rasmus Lerdorf",
    Developer: "The PHP Development Team, Zend Technologies",
    "First appeared": "June 8, 1995; 26 years ago",
    "Stable release": "8.1.1  / 17 December 2021; 29 days ago",
    "Preview release": "8.1.0 Beta 1  / 22 July 2021; 5 months ago",
    "Typing discipline": "Dynamic, weak  since version 7.0:  Gradual",
    "Implementation language": "C (primarily; some components C++)",
    OS: "Unix-like, Windows, macOS, IBM i, OpenVMS",
    License: "PHP License (most of Zend engine under Zend Engine License)",
    "Filename extensions": ".php,.phar,.phtml,.pht,.phps",
    Website: "www.php.net ",
    other_details: {
      type: "programming",
      tm_scope: "text.html.php",
      ace_mode: "php",
      codemirror_mode: "php",
      codemirror_mime_type: "application/x-httpd-php",
      color: "#4F5D95",
      extensions: [
        ".php",
        ".aw",
        ".ctp",
        ".fcgi",
        ".inc",
        ".php3",
        ".php4",
        ".php5",
        ".phps",
        ".phpt",
      ],
      filenames: [".php", ".php_cs", ".php_cs.dist", "Phakefile"],
      interpreters: ["php"],
      aliases: ["inc"],
      language_id: 272,
    },
    id: "fQSJ",
  },
  {
    name: "Pico",
    description:
      "Pico can be seen as an effort to generate a palatable and enjoyable language for people who do not want to study hard for the elegance and power of a language. They have done it by adapting Scheme's semantics. While designing Pico, the Software Languages Lab was inspired by the Abelson and Sussman's book \"Structure and Interpretation of Computer Programs\". Furthermore, they were influenced by the teaching of programming at high school or academic level. Pico should be interpreted as 'small', the idea was to create a small language for educational purposes. Comments are surrounded by backquotes (\"`\").",
    Paradigm: "Reflective, procedural",
    Developer: "Vrije Universiteit Brussel",
    "First appeared": "1997; 25 years ago",
    Website: "pico.vub.ac.be",
    id: "xUlQ",
  },
  {
    name: "PicoLisp",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/PicoLisp_Logo.svg/220px-PicoLisp_Logo.svg.png",
    description:
      "Functions can accept arbitrary types and numbers of arguments. Macros are needed only in rare cases and are implemented using the quote function. PicoLisp does not include Lisp's lambda function. This is because the quote function is changed to return all its arguments unevaluated, not only the car of the first. A special feature is the intrinsic create, read, update, and delete (CRUD) functioning. Persistent symbols are first-class citizens (objects), they are loaded from database files automatically when accessed, and written back when modified. Applications are written using a class hierarchy of entities and relations. Other features include: Prolog engine, database engine and database queries, distributed databases, inlining of C language functions and native C function calls, child process management, interprocess communication, browser graphical user interface (GUI), and internationalization and localization. In the 1980s, PicoLisp began development on the Macintosh, and was used in commercial application[which?] development since then.[citation needed] The design of PicoLisp is most similar to the first version of MacLisp, Interlisp and mainly Portable Standard Lisp. It was ported to DOS and SCO Unix. Since 1993, it was used mainly on Linux. In the mid-1990s, database functions were added.",
    Paradigms:
      "Functional, procedural, object-oriented, declarative, reflective, meta",
    Family: "Lisp",
    "Designed by": "Alexander Burger",
    "First appeared": "1988; 34 years ago",
    "Stable release": "21.12 / 27 December 2021; 20 days ago",
    "Typing discipline": "duck, dynamic, strong",
    "Implementation language": "LLVM, PicoLisp",
    Platform: "IA-32, x86-64, Arm64",
    OS: "POSIX",
    License: "MIT",
    "Filename extensions": ".l",
    Website: "picolisp.com",
    other_details: {
      type: "programming",
      extensions: [".l"],
      interpreters: ["picolisp", "pil"],
      tm_scope: "source.lisp",
      ace_mode: "lisp",
      language_id: 285,
    },
    id: "f5Od",
  },
  {
    name: "PLEXIL",
    description:
      "A MUD (/mʌd/; originally multi-user dungeon, with later variants multi-user dimension and multi-user domain) is a multiplayer real-time virtual world, usually text-based or storyboarded. MUDs combine elements of role-playing games, hack and slash, player versus player, interactive fiction, and online chat. Players can read or view descriptions of rooms, objects, other players, non-player characters, and actions performed in the virtual world. Players typically interact with each other and the world by typing commands that resemble a natural language. Traditional MUDs implement a role-playing video game set in a fantasy world populated by fictional races and monsters, with players choosing classes in order to gain specific skills or powers. The objective of this sort of game is to slay monsters, explore a fantasy world, complete quests, go on adventures, create a story by roleplaying, and advance the created character. Many MUDs were fashioned around the dice-rolling rules of the Dungeons & Dragons series of games. Such fantasy settings for MUDs are common, while many others have science fiction settings or are based on popular books, movies, animations, periods of history, worlds populated by anthropomorphic animals, and so on. Not all MUDs are games; some are designed for educational purposes, while others are purely chat environments, and the flexible nature of many MUD servers leads to their occasional use in areas ranging from computer science research to geoinformatics to medical informatics to analytical chemistry. MUDs have attracted the interest of academic scholars from many fields, including communications, sociology, law, and economics. At one time, there was interest from the United States military in using them for teleconferencing. Most MUDs are run as hobbies and are free to play; some may accept donations or allow players to purchase virtual items, while others charge a monthly subscription fee. MUDs can be accessed via standard telnet clients, or specialized MUD clients, which are designed to improve the user experience. Numerous games are listed at various web portals, such as The Mud Connector.",
    id: "ZylS",
  },
  {
    name: "Plus",
    description:
      'PILOT is an imperative language similar in structure to BASIC and FORTRAN in its basic layout and structure. Its keywords are single characters, T for "type" to print text, or A for "accept", to input values from the user. PILOT was developed by John Amsden Starkweather, a psychology professor at the University of California, San Francisco medical center. In 1962, he developed a simple language for automating learning tests called Computest. Starting in 1968, he developed a follow-on project called PILOT, for various computers of the time such as the SDS 940. A line of PILOT code contains (from left to right) the following syntax elements: A label can also be alone in a line, not followed by other code. The syntax for a label is an asterisk followed by an identifier (alphanumeric string with alphabetic initial character).',
    id: "fXSi",
  },
  {
    name: "Pipelines",
    image: "https://upload.wikimedia.org/wikipedia/en/0/0c/Pipjarg1.jpeg",
    description:
      "CMS Pipelines provides a CMS command, PIPE. The argument string to the PIPE command is the pipeline specification. PIPE selects programs to run and chains them together in a pipeline to pump data through. Because CMS programs and utilities don't provide a device independent stdin and stdout interface, CMS Pipelines has a built-in library of programs that can be called in a pipeline specification. These built-in programs interface to the operating system, and perform many utility functions. Data on CMS is structured in logical records rather than a stream of bytes. For textual data a line of text corresponds to a logical record. In CMS Pipelines the data is passed between the stages as logical records. CMS Pipelines users issue pipeline commands from the terminal or in EXEC procedures. Users can write programs in REXX that can be used in addition to the built-in programs.",
    Paradigm: "Dataflow programming",
    "Designed by": "John P. Hartmann (IBM)",
    Developer: "IBM",
    "First appeared": "1986",
    "Stable release": "1.1.12/0012 / 2020-06-03",
    Platform: "IBM z Systems",
    OS: "z/VM 7.1",
    Website: "http://vm.marist.edu/~pipeline",
    id: "-6v_",
  },
  {
    name: "PostScript",
    description:
      "PL-11 was originally developed as part of the Omega project, a particle physics facility operational at CERN (Geneva, Switzerland) during the 1970s. The first version was written for the CII 10070, a clone of the XDS Sigma 7 built in France. Towards the end of the 1970s it was ported to the IBM 370/168, then part of CERN's computer centre. A report describing the language is available from CERN.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    other_details: {
      type: "markup",
      color: "#da291c",
      extensions: [".ps", ".eps", ".pfa"],
      tm_scope: "source.postscript",
      aliases: ["postscr"],
      ace_mode: "text",
      language_id: 291,
    },
    id: "kF6R",
  },
  {
    name: "PortablE",
    description:
      "The following is the syntax rules of the model language defined in EBNF: It is rather easy for students to write a recursive descent parser for such a simple syntax. Therefore, the PL/0 compiler is still widely used in courses on compiler construction throughout the world. Due to the lack of features in the original specification, students usually spend most of their time with extending the language and their compiler. They usually start with introducing REPEAT .. UNTIL and continue with more advanced features like parameter passing to procedures or data structures like arrays, strings or floating point numbers. The main article on compilers honours PL/0 for introducing several influential concepts (stepwise refinement, recursive descent parsing, EBNF, P-code, T-diagrams) to the field by educating students to use these concepts. Over the last 3 decades, most university courses on compiler construction that used PL/0 have followed Wirth strictly in employing these techniques (see references below). Some years ago university courses deviated from the course set by Wirth with the replacement of the classical recursive descent parsing technique by a (nonetheless classical) Unix-like approach of employing lex and yacc. Only recently an implementation (PL/0 Language Tools) along this way has also combined modern concepts like object-orientation and design patterns with a modern scripting language (Python), allowing students to consume the source text of the implementation in a contemporary programming style. In December 1976, Wirth wrote a small booklet about compiler construction, containing the full source code of the PL/0 compiler. The syntax rules above were taken from this first edition of Wirth's book Compilerbau. In later editions of this book (under the influence of his ongoing research) Wirth changed the syntax of PL/0. He changed the spelling of keywords like const and procedure to uppercase. This change made PL/0 resemble Modula-2 more closely. At the same time, Wirth's friend and collaborator C. A. R. Hoare was working on his influential communicating sequential processes concept, which used the exclamation mark ! and the question mark ? to denote communication primitives. Wirth added both symbols to the PL/0 language, but he did not mention their semantics in the book.",
    id: "nnt1",
  },
  {
    name: "Programming Language for Business",
    description:
      "A version of DATABUS became an ANSI standard, and the name PL/B came about when Datapoint chose not to release its trademark on the DATABUS name. Much like Java and .NET, PL/B programs are compiled into an intermediate byte-code, which is then interpreted by a runtime library. Because of this, many PL/B programs can run on DOS, Unix, Linux, and Windows operating systems. The PL/B development environments are influenced by Java and Visual Basic, and offer many of the same features found in those languages. PL/B (Databus) is actively used all over the world, and has several forums on the Internet dedicated to supporting software developers. Since its inception, PL/B has been enhanced and adapted to keep it modernized and able to access various data sources. It has a database capability built-in with ISAM and Associative Hashed Indexes, as well as ODBC, SQL, Oracle, sequential, random access, and XML files. All the constructs of modern programming languages have been incrementally added to the language. PL/B also has the ability to access external routines through COM, DLL's and .NET assemblies. Full access to the .NET framework is built into many versions.",
    Paradigm: "Procedural, imperative",
    "First appeared": "1972",
    "Typing discipline": "Strong, static",
    "Filename extensions": ".rl, .ps, .cb",
    id: "6F-K",
  },
  {
    name: "PL/I",
    description:
      "PL/I's main domains are data processing, numerical computation, scientific computing, and system programming. It supports recursion, structured programming, linked data structure handling, fixed-point, floating-point, complex, character string handling, and bit string handling. The language syntax is English-like and suited for describing complex data formats with a wide set of functions available to verify and manipulate them. In the 1950s and early 1960s, business and scientific users programmed for different computer hardware using different programming languages. Business users were moving from Autocoders via COMTRAN to COBOL, while scientific users programmed in Fortran, ALGOL, GEORGE, and others. The IBM System/360 (announced in 1964 and delivered in 1966) was designed as a common machine architecture for both groups of users, superseding all existing IBM architectures. Similarly, IBM wanted a single programming language for all users. It hoped that Fortran could be extended to include the features needed by commercial programmers. In October 1963 a committee was formed composed originally of three IBMers from New York and three members of SHARE, the IBM scientific users group, to propose these extensions to Fortran. Given the constraints of Fortran, they were unable to do this and embarked on the design of a new programming language based loosely on ALGOL labeled NPL. This acronym conflicted with that of the UK's National Physical Laboratory and was replaced briefly by MPPL (MultiPurpose Programming Language) and, in 1965, with PL/I (with a Roman numeral \"I\"). The first definition appeared in April 1964. IBM took NPL as a starting point and completed the design to a level that the first compiler could be written: the NPL definition was incomplete in scope and in detail. Control of the PL/I language was vested initially in the New York Programming Center and later at the IBM UK Laboratory at Hursley. The SHARE and GUIDE user groups were involved in extending the language and had a role in IBM's process for controlling the language through their PL/I Projects. The experience of defining such a large language showed the need for a formal definition of PL/I. A project was set up in 1967 in IBM Laboratory Vienna to make an unambiguous and complete specification. This led in turn to one of the first large scale Formal Methods for development, VDM. Fred Brooks is credited with ensuring PL/I had the CHARACTER data type.",
    Paradigm: "Procedural, imperative, structured",
    "Designed by": "IBM and the SHARE Language Development Committee",
    Developer: "IBM",
    "First appeared": "1964; 58 years ago",
    "Stable release": "IBM Enterprise PL/I for z/OS 5.3 / September 2019",
    Website: "www.ibm.com/products/pli-compiler-zos",
    id: "lVNr",
  },
  {
    name: "PL/M",
    description:
      "The PL/M programming language (an acronym of Programming Language for Microcomputers) is a high-level language conceived and developed by Gary Kildall in 1973 for Hank Smith at Intel for its microprocessors. The language incorporated ideas from PL/I, ALGOL[citation needed] and XPL, and had an integrated macro processor. As a graduate of the University of Washington Kildall had used their Burroughs B5500 computer, and as such was aware of the potential of high-level languages such as ESPOL for systems programming. Unlike other contemporary languages such as Pascal, C or BASIC, PL/M had no standard input or output routines. It included features targeted at the low-level hardware specific to the target microprocessors, and as such, it could support direct access to any location in memory, I/O ports and the processor interrupt flags in a very efficient manner. PL/M was the first higher level programming language for microprocessor-based computers and was the original implementation language for those parts of the CP/M operating system which were not written in assembler. Many Intel and Zilog Z80-based embedded systems were programmed in PL/M during the 1970s and 1980s. For instance, the firmware of the Service Processor component of CISC IBM AS/400 was written in PL/M. The original PL/M compiler targeted the Intel 8008. An updated version (PL/M-80) generated code for the 8080 processor, which would also run on the newer Intel 8085 as well as on the Zilog Z80 family (as it is backward-compatible with the 8080). Later followed compilers for the Intel 8048 and Intel 8051-microcontroller family (PL/M-51) as well as for the 8086 (8088) (PL/M-86), 80186 (80188) and subsequent 8086-based processors, including the advanced 80286 and the 32-bit 80386. There were also PL/M compilers developed for later microcontrollers, such as the Intel 8061 and 8096 / MCS-96 architecture family (PL/M-96).",
    Developer: "Gary Kildall at Microcomputer Applications Associates",
    "First appeared": "1973",
    id: "Vtar",
  },
  {
    name: "Processing",
    description:
      "Early projects using PL/S were the batch utility, IEHMOVE, and the Time Sharing Option of MVT, TSO. By the 1970s, IBM was rewriting its flagship operating system in PL/S. Although users frequently asked IBM to release PL/S for their use, IBM refused saying that the product was proprietary. Their concern was that open PL/S would give competitors, Amdahl, Itel (National Advanced Systems), Storage Technology Corporation, Trilogy Systems, Magnuson Computer Systems, Fujitsu, Hitachi, and other PCM vendors a competitive advantage. However, even though they refused to make available a compiler, they shipped the PL/S source code to large parts of the OS to customers, many of whom thus became familiar with reading it. Closed PL/S meant that only IBM could easily modify and enhance the operating system. PL/S was succeeded by PL/S II, PL/S III and PL/AS (Programming Language/Advanced Systems), and then PL/X (Programming Language/Cross Systems). PL/DS (Programming Language/Distributed Systems) was a closely related language used to develop the DPPX operating system, and PL/DS II was a port of the S/370 architecture for the DPPX/370 port.",
    other_details: {
      type: "programming",
      color: "#0096D8",
      extensions: [".pde"],
      ace_mode: "text",
      language_id: 294,
    },
    id: "rBKj",
  },
  {
    name: "Processing.js",
    description:
      "PL/SQL includes procedural language elements such as conditions and loops. It allows declaration of constants and variables, procedures and functions, types and variables of those types, and triggers. It can handle exceptions (run-time errors). Arrays are supported involving the use of PL/SQL collections. Implementations from version 8 of Oracle Database onwards have included features associated with object-orientation. One can create PL/SQL units such as procedures, functions, packages, types, and triggers, which are stored in the database for reuse by applications that use any of the Oracle Database programmatic interfaces. Historically, the first public version of PL/SQL definition was in 1995, and the Oracle's inception year ~1992. It implements the ISO SQL/PSM standard. The main feature of SQL (non-procedural) is also a drawback of SQL: one cannot use control statements (decision-making or iterative control) if only SQL is to be used. PL/SQL is basically a procedural language, which provides the functionality of decision making, iteration and many more features like other procedural programming languages. A PL/SQL program unit is one of the following: PL/SQL anonymous block, procedure, function, package specification, package body, trigger, type specification, type body, library. Program units are the PL/SQL source code that is compiled, developed and ultimately executed on the database. The basic unit of a PL/SQL source program is the block, which groups together related declarations and statements. A PL/SQL block is defined by the keywords DECLARE, BEGIN, EXCEPTION, and END. These keywords divide the block into a declarative part, an executable part, and an exception-handling part. The declaration section is optional and may be used to define and initialize constants and variables. If a variable is not initialized then it defaults to NULL value. The optional exception-handling part is used to handle run time errors. Only the executable part is required. A block can have a label.",
    id: "BUcQ",
  },
  {
    name: "PL360",
    description:
      'PL/360 is a one pass compiler with a syntax similar to ALGOL that provides facilities for specifying exact machine code (language) instructions and registers similar[a] to assembly language, but also provides features commonly found in high-level programming languages, such as complex arithmetic expressions and control structures. Wirth used PL360 to create ALGOL W. Data types are:: 8  Registers can contain integer, real, or long real. Individual System/360 instructions can be generated inline using the PL360 "function statement" that defined an instruction by format and operation code. Function arguments were assigned sequentially to fields in the instruction. Examples are:',
    Paradigms: "Procedural, imperative, structured",
    Family: "Wirth ALGOL",
    "Designed by":
      "Niklaus Wirth, Joseph W. Wells Jr., Edwin Satterthwaite Jr.",
    Developer: "Stanford University",
    "First appeared": "1966; 56 years ago",
    "Typing discipline": "Static, strong",
    Scope: "Lexical (static)",
    "Implementation language": "ALGOL, then PL360",
    Platform: "Burroughs B5000, IBM System/360",
    id: "APpN",
  },
  {
    name: "PLANC",
    description:
      "PLANC (Programming LAnguage for Nd Computers, pronounced as plank) is a high-level programming language. Compilers were developed by Norsk Data for several architectures, including the Motorola 68000, 88000, Intel x86, and the Norsk Data Nord-10 minicomputers and ND-500 superminicomputer. The language was designed to be cross-platform software. It was mainly used internally at Norsk Data for writing high level systems software such as the upper parts of operating systems and compilers. PLANC programs are structured into modules and routines.",
    Paradigm: "Procedural, imperative, structured",
    Family: "Pascal",
    Developer: "Norsk Data",
    "Final release": "Final",
    "Typing discipline": "Static, strong",
    Scope: "Lexical",
    Platform:
      "Norsk Data Nord-10 minicomputers, ND-500 superminicomputer; Motorola 68000, 88000; Intel x86",
    OS: "Sintran III",
    License: "Proprietary",
    id: "yKQ0",
  },
  {
    name: "Plankalkül",
    description:
      "Kalkül is the German term for a formal system—as in Hilbert-Kalkül, the original name for the Hilbert-style deduction system—so Plankalkül refers to a formal system for planning. In the domain of creating computing machines, Zuse was self-taught, and developed them without knowledge about other mechanical computing machines that existed already -- although later on (building the Z3) being inspired by Hilbert's and Ackermann's book on elementary mathematical logic (cf. Principles of Mathematical Logic). To describe logical circuits, Zuse invented his own diagram and notation system, which he called \"combinatorics of conditionals\" (German: Bedingungskombinatorik). After finishing the Z1 in 1938, Zuse discovered that the calculus he had independently devised already existed and was known as propositional calculus. What Zuse had in mind, however, needed to be much more powerful (propositional calculus is not Turing-complete and is not able to describe even simple arithmetic calculations). In May 1939 he described his plans for the development of what would become Plankalkül. He wrote the following in his notebook: Almost half a year of gradual introduction into formal logic. I rediscovered there lots of my previous thoughts. (combinatorics of conditionals = propositional calculus; study of intervals = lattice theory). Now I plan creation of \"Calculus of plans\". There are series of concepts needed to clarify for this. Seit etwa einem halben Jahr allmähliches Einführen in die formale Logik. Viele meiner früheren Gedanken habe ich dort wieder gefunden. (Bedingungskombinatorik = Aussagenlogik; Lehre von den Intervallen = Gebietenkalkül). Ich plane jetzt die Aufsetzung des 'Plankalküls'. Hierzu sind eine Reihe von Begriffen zu klären.",
    Paradigm: "Procedural",
    "Designed by": "Konrad Zuse",
    "First appeared": "1948; 74 years ago – concept first published",
    id: "bdSE",
  },
  {
    name: "Planner",
    description:
      "The two major paradigms for constructing semantic software systems were procedural and logical. The procedural paradigm was epitomized by Lisp [McCarthy et al. 1962] which featured recursive procedures that operated on list structures. The logical paradigm was epitomized by uniform proof procedure resolution-based derivation (proof) finders [Robinson 1965]. According to the logical paradigm it was “cheating” to incorporate procedural knowledge [Green 1969]. Planner was invented for the purposes of the procedural embedding of knowledge [Hewitt 1971] and was a rejection of the resolution uniform proof procedure paradigm [Robinson 1965], which Planner was a kind of hybrid between the procedural and logical paradigms because it combined programmability with logical reasoning. Planner featured a procedural interpretation of logical sentences where an implication of the form (P implies Q) can be procedurally interpreted in the following ways using pattern-directed invocation:",
    Paradigm: "Multi-paradigm: logic, procedural",
    "Designed by": "Carl Hewitt",
    "First appeared": "1969; 53 years ago",
    id: "xlBb",
  },
  {
    name: "Plex",
    description:
      'The language has two variants: Plex-C used for the AXE Central Processor (CP) and Plex-M used for Extension Module Regional Processors (EMRP). Ericsson started a project in the mid-1980s to create a successor language which resulted in Erlang. According to co-creator Joe Armstrong, "Erlang was heavily influenced by PLEX and the AXE design." Erlang did not replace PLEX, but was used alongside it. A system is divided into separately compiled and loaded units of code called "blocks." A block waits for one or more signals sent from elsewhere in the system which triggers code execution. Several precompilers or code generators exist, to produce source code in Plex-C from higher level languages or graphical models. These can generate Plex-C from:',
    Paradigm: "procedural, imperative, concurrent",
    Developer: "Göran Hemdahl",
    "First appeared": "1970s",
    OS: "Ericsson APZ",
    License: "Proprietary",
    id: "ljYq",
  },
  {
    name: "PLEXIL",
    description:
      "PLEXIL is a programming language for representing plans for automation. In 2006 Vandi Verma was one of several co-writers of PLEXIL, which is now used in automation technologies such as the NASA K10 rover, Mars Curiosity rover's percussion drill, Deep Space Habitat and Habitat Demonstration Unit, Edison Demonstration of Smallsat Networks, LADEE, Autonomy Operating System (AOS) and procedure automation for the International Space Station. The PLEXIL Executive is an execution engine that implements PLEXIL and can be interfaced (using a provided software framework) with external systems to be controlled and/or queried. PLEXIL has been used to demonstrate automation technologies targeted at future NASA space missions. The binaries and documentation are widely available as BSD licensed open source from SourceForge.net.",
    Paradigm: "Multi-paradigm",
    "Designed by": "NASA",
    "First appeared": "2005",
    "Typing discipline": "Static, unsafe, nominative",
    OS: "Linux, Mac OS",
    License: "Open source",
    Website: "http://plexil.sourceforge.net/",
    id: "aRY7",
  },
  {
    name: "Plus",
    description:
      "There is another programming language named PLUS, developed at Sperry Univac in Roseville, Minnesota, but the Univac PLUS is not the subject of this article. Plus was developed at the University of British Columbia (UBC) Computing Centre by Alan Ballard and Paul Whaley for use with and for the development of the Michigan Terminal System (MTS), but the code generated by the compiler is not operating system dependent and so is not limited to use with or the development of MTS. The UBC Plus compiler is written largely in Plus, runs under the Michigan Terminal System (MTS) on IBM S/370 or compatible hardware or under IBM's OS/VS1, and generates code for the IBM S/370, the DEC PDP-11, or the Motorola 68000 architectures. Plus is based to a large extent on the SUE System Language developed at the University of Toronto, c. 1971. The SUE language was derived, particularly in its data structure facilities from Pascal.",
    Paradigm: "imperative, structured",
    Developer: "Alan Ballard and Paul Whaley at UBC",
    "First appeared": "1976",
    "Typing discipline": "static, strong, safe",
    OS: "Michigan Terminal System (MTS), OS/VS1",
    id: "KrAQ",
  },
  {
    name: "ProvideX",
    description:
      "POP-11 is an evolution of the language POP-2, developed in Edinburgh University, and features an open stack model (like Forth, among others). It is mainly procedural, but supports declarative language constructs, including a pattern matcher, and is mostly used for research and teaching in artificial intelligence, although it has features sufficient for many other classes of problems. It is often used to introduce symbolic programming techniques to programmers of more conventional languages like Pascal, who find POP syntax more familiar than that of Lisp. One of POP-11's features is that it supports first-class functions. POP-11 is the core language of the Poplog system. The availability of the compiler and compiler subroutines at run-time (a requirement for incremental compilation) gives it the ability to support a far wider range of extensions (including run-time extensions, such as adding new data-types) than would be possible using only a macro facility. This made it possible for (optional) incremental compilers to be added for Prolog, Common Lisp and Standard ML, which could be added as required to support either mixed language development or development in the second language without using any POP-11 constructs. This made it possible for Poplog to be used by teachers, researchers, and developers who were interested in only one of the languages. The most successful product developed in POP-11 was the Clementine Data-mining system, developed by ISL. After SPSS bought ISL they decided to port Clementine to C++ and Java, and eventually succeeded with great effort (and perhaps some loss of the flexibility provided by the use of an AI language). POP-11 was for a time available only as part of an expensive commercial package (Poplog), but since about 1999 it has been freely available as part of the Open Source version of Poplog, including various additional packages and teaching libraries. An online version of ELIZA using POP-11 is available at Birmingham. At the University of Sussex, David Young used POP-11 in combination with C and Fortran to develop a suite of teaching and interactive development tools for image processing and vision, and has made them available in the Popvision extension to Poplog.",
    id: "8-uM",
  },
  {
    name: "Pro*C",
    description:
      "POP-2's syntax was Algol-like, except that assignments were the other way round: instead of writing one wrote The reason for this was that the language had explicit notion of an operand stack; thus, the previous assignment could be written as two separate statements: which evaluated the value 3 and left it on the stack, and",
    id: "YKN6",
  },
  {
    name: "PostScript",
    description:
      'The concepts of the PostScript language were seeded in 1976 by John Gaffney at Evans & Sutherland, a computer graphics company. At that time Gaffney and John Warnock were developing an interpreter for a large three-dimensional graphics database of New York Harbor. Concurrently, researchers at Xerox PARC had developed the first laser printer and had recognized the need for a standard means of defining page images. In 1975-76 Bob Sproull and William Newman developed the Press format, which was eventually used in the Xerox Star system to drive laser printers. But Press, a data format rather than a language, lacked flexibility, and PARC mounted the Interpress effort to create a successor. In 1978 John Gaffney and Martin Newell then at Xerox PARC wrote J & M or JaM (for "John and Martin") which was used for VLSI design and the investigation of type and graphics printing. This work later evolved and expanded into the Interpress language. Warnock left with Chuck Geschke and founded Adobe Systems in December 1982. They, together with Doug Brotz, Ed Taft and Bill Paxton created a simpler language, similar to Interpress, called PostScript, which went on the market in 1984. At about this time they were visited by Steve Jobs, who urged them to adapt PostScript to be used as the language for driving laser printers.',
    Paradigm: "Multi-paradigm: stack-based, procedural",
    "Designed by":
      "John Warnock, Chuck Geschke, Doug Brotz, Ed Taft, Bill Paxton",
    Developer: "Adobe Systems",
    "First appeared": "1982; 40 years ago",
    "Stable release": "PostScript 3 / 1997; 25 years ago",
    "Typing discipline": "Dynamic, weak",
    "Filename extension": ".ps",
    "Internet media type": "application/postscript",
    "Uniform Type Identifier (UTI)": "com.adobe.postscript",
    "Magic number": "%!",
    "Developed by": "Adobe Systems",
    "Type of format": "printing file format",
    "Extended to": "Encapsulated PostScript",
    other_details: {
      type: "markup",
      color: "#da291c",
      extensions: [".ps", ".eps", ".pfa"],
      tm_scope: "source.postscript",
      aliases: ["postscr"],
      ace_mode: "text",
      language_id: 291,
    },
    id: "0wMA",
  },
  {
    name: "Pure Data",
    description:
      'Amiga E is a combination of many features from a number of languages, but follows the original C programming language most closely in terms of basic concepts. Amiga E\'s main benefits are fast compilation (allowing it to be used in place of a scripting language), very readable source code, flexible type system, powerful module system, exception handling (not C++ variant) and Object oriented programming. A "hello world" program in Amiga E looks like: Amiga E was used to create the core of the popular Amiga graphics software Photogenics. 1993: The first public release of Amiga E.',
    other_details: {
      type: "data",
      extensions: [".pd"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 300,
    },
    id: "kmc3",
  },
  {
    name: "POV-Ray",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/62/Povray_logo_sphere.png/220px-Povray_logo_sphere.png",
    description:
      'Sometime in the 1980s, David Kirk Buck downloaded the source code for a Unix ray tracer to his Amiga. He experimented with it for a while and eventually decided to write his own ray tracer named DKBTrace after his initials. He posted it to the "You Can Call Me Ray" bulletin board system (BBS) in Chicago, thinking others might be interested in it. In 1987, Aaron A. Collins downloaded DKBTrace and began working on an x86 port of it. He and David Buck collaborated to add several more features. When the program proved to be more popular than anticipated, they could not keep up with demand for more features. Thus, in July 1991, David turned over the project to a team of programmers working in the "GraphDev" forum on CompuServe. At the same time, David felt that it was inappropriate to use his initials on a program he no longer maintained. The name "STAR-Light" (Software Taskforce on Animation and Rendering) was initially used, but eventually the name became "PV-Ray", and then ultimately "POV-Ray" (Persistence of Vision Ray Tracer), a name inspired by Dalí\'s painting, The Persistence of Memory. Features of the application, and a summary of its history, are discussed in a February 2008 interview with David Kirk Buck and Chris Cason on episode 24 of FLOSS Weekly. POV-Ray has matured substantially since it was created. Recent versions of the software include the following features:',
    "Original author(s)":
      "David Kirk Buck, Aaron A. Collins, Alexander Enzmann",
    "Developer(s)": "The POV-Team",
    "Initial release": "July 29, 1991; 30 years ago",
    "Stable release": "3.7.0 (November 9, 2013; 8 years ago) [±]",
    "Preview release": "v3.8.0-beta.2 (August 9, 2021; 5 months ago) [±]",
    Repository: "github.com/POV-Ray/povray ",
    "Written in": "C++",
    "Operating system": "Cross-platform",
    Type: "Ray tracer",
    License: "AGPL-3.0-or-later",
    Website: "www.povray.org",
    id: "fipP",
  },
  {
    name: "UNICOM PowerHouse",
    description:
      "PowerHouse was introduced in 1982 and bundled together in a single product Quiz and Quick/QDesign, both of which had been previously available separately, with a new batch processor QTP. In 1983, Quasar changed its name to Cognos Corporation and began porting their application development tools to other platforms, notably Digital Equipment Corporation's VMS, Data General's AOS/VS II, and IBM's OS/400, along with the UNIX platforms from these vendors. Cognos also began extending their product line with add-ons to PowerHouse (for example, Architect) and end-user applications written in PowerHouse (for example, MultiView).[citation needed] Subsequent development of the product added support for platform-specific relational databases, such as HP's Allbase/SQL, DEC's Rdb, and Microsoft's SQL Server, as well as cross-platform relational databases such as Oracle, Sybase, and IBM's DB2. The PowerHouse language represented a considerable achievement.[according to whom?] Compared with languages like COBOL, Pascal and PL/1, PowerHouse substantially cut the amount of labour required to produce useful applications on its chosen platforms. It achieved this through the use of a central data-dictionary, a compiled file that extended the attributes of data fields natively available in the DBMS with frequently used programming idioms such as: In order to support the data dictionary, PowerHouse was tightly coupled to the underlying database management system and/or file system on each of the target platforms. In the case of the HP3000 this was the IMAGE shallow-network DBMS and KSAM indexed file system, and the entire PowerHouse language reflected its origins. Once described in the data dictionary, there was no further need to describe the attributes through any of the applications unless there was a need to change them on the fly, for example, to change the size of an item to make it fit within the constraints of a defined item.",
    "Developer(s)": "UNICOM Systems, a division of UNICOM Global",
    License: "Proprietary software",
    Website: "teamblue.unicomsi.com/products/powerhouse-4gl/",
    id: "SGu4",
  },
  {
    name: "Appeon PowerBuilder",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/a/ad/PowerBuilder_2017_Logo.png/75px-PowerBuilder_2017_Logo.png",
    description:
      "Over the years, PowerBuilder has been updated with new standards. In 2010, a major upgrade of PowerBuilder was released to provide support for the Microsoft .NET Framework. In 2014, support was added for OData, dockable windows, and 64-bit native applications. In 2019 support was added for rapidly creating RESTful Web APIs and non-visual .NET assemblies using the C# language and the .NET Core framework. And PowerScript client app development was revamped with new UI technologies and cloud architecture. Appeon has been releasing new features every 6-12 month cycles, which per the product roadmap focus on four key focus areas: sustaining core features, modernizing application UI, improving developer productivity, and incorporating more Cloud technology. PowerBuilder has a native data-handling object called a DataWindow, which can be used to create, edit, and display data from a database. This object gives the programmer a number of tools for specifying and controlling user interface appearance and behavior, and also provides simplified access to database content and JSON or XML from Web services. To some extent, the DataWindow frees the programmer from considering the differences between Database Management Systems from different vendors. DataWindow can display data using multiple presentation styles and can connect to various data sources. PowerBuilder is used primarily for building business CRUD applications.",
    "Developer(s)": "SAP/Appeon",
    "Initial release": "July 1992",
    "Stable release": "PowerBuilder 2019 R3 / January 22, 2021",
    "Preview release": "None",
    "Written in": "C++ and C#",
    "Operating system": "Microsoft Windows",
    "Available in":
      "English, Japanese for the IDE (numerous languages supported for deployed applications)",
    Type: "IDE",
    License: "Commercial",
    Website: "www.appeon.com ",
    id: "nK-z",
  },
  {
    name: "PowerShell",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/PowerShell_Core_6.0_icon.png/121px-PowerShell_Core_6.0_icon.png",
    description:
      "In PowerShell, administrative tasks are generally performed by cmdlets (pronounced command-lets), which are specialized .NET classes implementing a particular operation. These work by accessing data in different data stores, like the file system or registry, which are made available to PowerShell via providers. Third-party developers can add cmdlets and providers to PowerShell. Cmdlets may be used by scripts, which may in turn be packaged into modules. PowerShell provides access to COM and WMI, enabling administrators to perform administrative tasks on both local and remote Windows systems as well as WS-Management and CIM enabling management of remote Linux systems and network devices. PowerShell also provides a hosting API with which the PowerShell runtime can be embedded inside other applications. These applications can then use PowerShell functionality to implement certain operations, including those exposed via the graphical interface. This capability has been used by Microsoft Exchange Server 2007 to expose its management functionality as PowerShell cmdlets and providers and implement the graphical management tools as PowerShell hosts which invoke the necessary cmdlets. Other Microsoft applications including Microsoft SQL Server 2008 also expose their management interface via PowerShell cmdlets. PowerShell includes its own extensive, console-based help (similar to man pages in Unix shells) accessible via the Get-Help cmdlet. Updated local help contents can be retrieved from the Internet via the Update-Help cmdlet. Alternatively, help from the web can be acquired on a case-by-case basis via the -online switch to Get-Help. Every version of Microsoft Windows for personal computers has included a command line interpreter (CLI) for managing the operating system. Its predecessor, MS-DOS, relied exclusively on a CLI. These are COMMAND.COM in MS-DOS and Windows 9x, and cmd.exe in the Windows NT family of operating systems. Both support a few basic internal commands. For other purposes, a separate console application must be written. They also include a basic scripting language (batch files), which can be used to automate various tasks. However, they cannot be used to automate all facets of graphical user interface (GUI) functionality, in part because command-line equivalents of operations are limited, and the scripting language is elementary. In Windows Server 2003, the situation was improved, but scripting support was still unsatisfactory.",
    Paradigm:
      "Imperative, pipeline, object-oriented, functional and reflective",
    "Designed by": "Jeffrey Snover, Bruce Payette, James Truher (et al.)",
    Developer: "Microsoft",
    "First appeared": "November 14, 2006; 15 years ago",
    "Stable release": "7.2.1 / December 15, 2021; 32 days ago",
    "Preview release": "v7.2.0-rc.1 / October 23, 2021; 2 months ago",
    "Typing discipline": "Strong, safe, implicit and dynamic",
    "Implementation language": "C#",
    Platform: ".NET Framework, .NET",
    OS: "Windows 7 and later Windows Server 2008 R2 and later macOS 10.12 and later Ubuntu 14.04, 16.04, 18.04, and 20.04 Debian 8.7+, 9, and 10 CentOS 7 and 8 Red Hat Enterprise Linux 7 and 8 openSUSE 42.2, 42.3, 15.0, 15.1, 15.2 Fedora 28, 29, 30",
    License: "MIT License (but the Windows component remains proprietary)",
    "Filename extensions":
      ".ps1 (Script) .ps1xml (XML Document) .psc1 (Console File) .psd1 (Data File) .psm1 (Script Module) .pssc (Session Configuration File) .psrc (Role Capability File) .cdxml (Cmdlet Definition XML Document)",
    Website: "microsoft.com/powershell",
    other_details: {
      type: "programming",
      color: "#012456",
      ace_mode: "powershell",
      codemirror_mode: "powershell",
      codemirror_mime_type: "application/x-powershell",
      aliases: ["posh", "pwsh"],
      extensions: [".ps1", ".psd1", ".psm1"],
      interpreters: ["pwsh"],
      language_id: 293,
    },
    id: "aAy9",
  },
  {
    name: "Processing",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Processing_2021_logo.svg/180px-Processing_2021_logo.svg.png",
    description:
      "Processing uses the Java language, with additional simplifications such as additional classes and aliased mathematical functions and operations. It also provides a graphical user interface for simplifying the compilation and execution stage. The Processing language and IDE have been the precursor to other projects including Arduino, Wiring and Processing.js. The project was initiated in 2001 by Casey Reas and Ben Fry, both formerly of the Aesthetics and Computation Group at the MIT Media Lab. In 2012, they started the Processing Foundation along with Daniel Shiffman, who joined as a third project lead. Johanna Hedva joined the Foundation in 2014 as Director of Advocacy. Originally, Processing had the URL of proce55ing.net, because the processing domain was taken. Eventually Reas and Fry acquired the domain processing.org. Although the name had a combination of letters and numbers, it was still pronounced processing. They do not prefer the environment being referred to as Proce55ing. Despite the domain name change, Processing still uses the term p5 sometimes as a shortened name (p5 specifically is used, not p55), for example p5.js is a reference to that.",
    Paradigm: "Object-oriented",
    "Designed by": "Casey Reas, Ben Fry",
    "First appeared": "2001; 21 years ago",
    "Stable release": "3.5.4 / January 17, 2020; 23 months ago",
    License: "GPL, LGPL",
    "Filename extensions": ".pde",
    Website: "processing.org",
    Repository: "github.com/processing/processing ",
    "Written in": "Java, GLSL, JavaScript",
    "Operating system": "Cross-platform",
    Type: "Integrated development environment",
    other_details: {
      type: "programming",
      color: "#0096D8",
      extensions: [".pde"],
      ace_mode: "text",
      language_id: 294,
    },
    id: "UytE",
  },
  {
    name: "Processing.js",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/Processing_Logo_Clipped.svg/180px-Processing_Logo_Clipped.svg.png",
    description:
      "Processing.js was originally created to allow existing Processing developers and existing code to work unmodified on web. Processing.js used JavaScript to render 2D and 3D content on the HTML canvas element, and was supported by browsers that have implemented this element (the latest versions of Mozilla Firefox, Opera, Internet Explorer, Safari and Google Chrome). The development of Processing.js was started by John Resig and then picked up by the CDOT group at Seneca College after its initial release in 2008. A team of students and professors finished the porting work to get Processing.js to parity with the Processing v1.0 API, fixing more than 900 bugs, shipping 12 releases, and creating a vibrant community in the process. The project was run through a partnership between the Mozilla Foundation and Seneca College, led by David Humphrey, Al MacDonald, and Corban Brook. Processing.js development was moved to GitHub in February of 2010, receiving contributions from 58 individuals, and was kept at parity with Processing up to its API version 2.1 release. The project was discontinued in December of 2018, two years after active development on it had stopped. Lauren McCarthy created p5.js, a native JavaScript alternative and successor to Processing.js that has the official support of the Processing Foundation. McCarthy also teaches an introductory course to p5.js on Kadenze.",
    "Original author(s)": "John Resig",
    "Developer(s)": "Seneca CDOT",
    "Initial release": "2008; 14 years ago",
    "Final release": "1.6.6 / March 5, 2017; 4 years ago",
    Repository: "github.com/processing-js/processing-js ",
    "Written in": "JavaScript",
    Successor: "p5.js",
    Size: "61 KB (gzipped) / 209 KB (production) / 754 KB (development)",
    Type: "Web application framework",
    License: "MIT",
    Website: "processingjs.org",
    id: "kO1D",
  },
  {
    name: "Prograph",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/6/6e/Prograph_cpx_logo.PNG/150px-Prograph_cpx_logo.PNG",
    description:
      'Research on Prograph started at Acadia University in 1982 as a general investigation into dataflow languages, stimulated by a seminar on functional languages conducted by Michael Levin. Diagrams were used to clarify the discussion, leading to the insight: "since the diagrams are clearer than the code, why not make the diagrams themselves executable!" Thus Prograph - Programming in Graphics - was born as a visual dataflow language. This work was led by Dr. Tomasz Pietrzykowski, with Stan Matwin and Thomas Muldner co-authoring early papers. From 1983 to 1985, research prototypes were built on a Three Rivers PERQ graphics workstation (in Pascal, with the data visualized as fireballs moving down datalinks), and a VAX with a Tektronix terminal, and an experimental compiler was programmed in an IBM PC. This work was continued at Technical University of Nova Scotia by Pietrzykowski and Dr. Philip Cox, including a version done in Prolog. In 1985, work began on a commercialisable prototype on the Macintosh, the only widely available, low-priced computer with high-level graphics support available at the time. In early 1986, this prototype was taken over by The Gunakara Sun Systems (later renamed to TGS Systems) for commercialisation, TGS formerly being a consulting firm formed by Pietrzykowski at Acadia University. Working with Pietrzykowski and Cox, Terry Kilshaw hired and managed the original development team, with Jim Laskey as the lead developer. In 1987 Mark Szpakowski suggested the merger of object-orientation with visual dataflow, creating an "objectflow" system. After almost four years of development, the first commercial release, v1.2, was introduced at the OOPSLA conference in New Orleans in October 1989. This product won the 1989 MacUser Editor\'s Choice Award for Best Development Tool. Version 2.0, released in July 1990, added a compiler to the system. TGS changed its name to Prograph International (PI) in 1990. Although sales were slow, development of a new version, Prograph CPX (Cross-Platform eXtensions) was undertaken in 1992, that was intended to build fully cross-platform applications. This version was released in 1993, and was immediately followed by development of a client-server application framework. Despite increasing sales, the company was unable to sustain operating costs, and following a failed financing attempt in late 1994, went into receivership in early 1995. As the receivership proceeded, the management and employees of PI formed a new company, Pictorius, which acquired the assets of PI. Shortly afterwards, development of a Windows version of Prograph CPX was begun. Although it was never formally released, versions of Windows Prograph were regularly made available to Prograph CPX customers, some of whom ported existing applications written in Macintosh Prograph, with varying degrees of success.',
    Paradigm: "multi-paradigm: object-oriented, visual, dataflow",
    "Designed by": "Acadia University",
    Developer: "Various",
    "First appeared": "1983",
    OS: "Cross-platform: Classic MacOS, Microsoft Windows, macOS",
    License: "Proprietary",
    id: "9cPN",
  },
  {
    name: "Project Verona",
    description:
      "The project is being supported by C# project manager Mads Torgensen and Microsoft Research Cambridge research software engineer Juliana Franco. Project Verona is also being aided by academics at Imperial College London. Unlike in Rust where the ownership model based on a single object, it is based on groups of objects in Verona. According to Microsoft, the goal of the project is to create a safer platform for memory management. Project Verona is open source released under MIT License and is under active development on GitHub. This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    Paradigm: "Safe infrastructure programming",
    Family: "Rust-like",
    "Designed by": "Microsoft Research, Imperial College London",
    "First appeared": "2019; 3 years ago",
    Platform: "Cross-platform",
    OS: "Linux, Windows, Darwin",
    License: "MIT License",
    "Filename extensions": ".verona",
    Website: "www.microsoft.com/en-us/research/project/project-verona (GitHub)",
    id: "GuGs",
  },
  {
    name: "Prolog",
    description:
      "Prolog has its roots in first-order logic, a formal logic, and unlike many other programming languages, Prolog is intended primarily as a declarative programming language: the program logic is expressed in terms of relations, represented as facts and rules. A computation is initiated by running a query over these relations. The language was developed and implemented in Marseille, France, in 1972 by Alain Colmerauer with Philippe Roussel, based on Robert Kowalski's procedural interpretation of Horn clauses. Prolog was one of the first logic programming languages and remains the most popular such language today, with several free and commercial implementations available. The language has been used for theorem proving, expert systems, term rewriting, type systems, and automated planning, as well as its original intended field of use, natural language processing. Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications. Prolog is well-suited for specific tasks that benefit from rule-based logical queries such as searching databases, voice control systems, and filling templates.",
    Paradigm: "Logic",
    "Designed by": "Alain Colmerauer, Robert Kowalski",
    "First appeared": "1972; 50 years ago",
    "Stable release":
      "Part 1: General core-Edition 1 (June 1995; 26 years ago) Part 2: Modules-Edition 1 (June 2000; 21 years ago)",
    "Typing discipline": 'Untyped (its single data type is "term")',
    "Filename extensions": ".pl, .pro, .P",
    Website:
      "Part 1: www.iso.org/standard/21413.html Part 2: www.iso.org/standard/20775.html",
    other_details: {
      type: "programming",
      color: "#74283c",
      extensions: [".pl", ".pro", ".prolog", ".yap"],
      interpreters: ["swipl", "yap"],
      tm_scope: "source.prolog",
      ace_mode: "prolog",
      language_id: 295,
    },
    id: "5Q1X",
  },
  {
    name: "PROMAL",
    image: "https://upload.wikimedia.org/wikipedia/en/2/2d/PROMAL_logo.png",
    description:
      'The language uses a single-pass compiler to generate byte code that is interpreted when the program is run. Since the memory is very limited on these early home computers, the compiler can compile to/from disk and memory. The software package for C64 includes a full-screen editor and command shell. See also [Computer Language, Mar 1986, pp. 128–134]. Ahoy! called PROMAL for the Commodore 64 "one of the best" structured languages. It concluded "As an introduction to structured programming languages and as an alternative to BASIC, PROMAL is well worth the time needed to learn it and the $49.95 to purchase it". From the PROMAL program disk:',
    Paradigm: "Imperative (procedural), structured",
    Developer: "Systems Management Associates",
    "First appeared": "1984-08-16",
    "Stable release": "2.1e / 1986-10-14",
    "Filename extensions": ".s",
    id: "il4V",
  },
  {
    name: "Raku",
    description:
      "PROMELA is a process modeling language whose intended use is to verify the logic of parallel systems. Given a program in PROMELA, Spin can verify the model for correctness by performing random or iterative simulations of the modeled system's execution, or it can generate a C program that performs a fast exhaustive verification of the system state space. During simulations and verifications SPIN checks for the absence of deadlocks, unspecified receptions, and unexecutable code. The verifier can also be used to prove the correctness of system invariants and it can find non-progress execution cycles. Finally, it supports the verification of linear time temporal constraints; either with Promela never-claims or by directly formulating the constraints in temporal logic. Each model can be verified with Spin under different types of assumptions about the environment. Once the correctness of a model has been established with Spin, that fact can be used in the construction and verification of all subsequent models. PROMELA programs consist of processes, message channels, and variables. Processes are global objects that represent the concurrent entities of the distributed system. Message channels and variables can be declared either globally or locally within a process. Processes specify behavior, channels and global variables define the environment in which the processes run. The basic data types used in PROMELA are presented in the table below. The sizes in bits are given for a PC i386/Linux machine. The names bit and bool are synonyms for a single bit of information. A byte is an unsigned quantity that can store a value between 0 and 255. shorts and ints are signed quantities that differ only in the range of values they can hold.",
    id: "7Aco",
  },
  {
    name: "RAPID",
    description:
      'Although PROSE was a rich block-structured procedural language, its focus was the blending of simultaneous-variable mathematical systems such as: Each of these kinds of system models were distinct and had operator templates to automate and solve them, added to the procedural syntax. These automated system problems were considered "holistic" because their unknowns were simultaneous, and they could not be reduced in formulation to solve piecewise, or by algebra manipulation (e.g. substitution), but had to be solved as wholes. And wholeness also pertained to algorithmic determinacy or mathematical "closure", which made solution convergence possible and certain in principle, if not corrupted by numerical instability. Since these holistic problem models could be independently automated and solved due to this closure, they could be blended into higher wholes by nesting one inside of another, in the manner of subroutines. Users could regard them as if they were ordinary subroutines. Yet semantically, this mathematical blending was considerably more complex than the mechanics of subroutines because an iterative solution engine was attached to each problem model by its calling operator template above it in the program hierarchy. In its numerical solution process, this engine would take control and would call the problem model subroutine iteratively, not returning to the calling template until its system problem was solved. During some or maybe all of the iterative model-subroutine calls the engine would invoke automatic differentiation of the formulas in the model holarchy with respect to the model\'s input-unknowns (arguments) defined in the calling template. Additional mechanisms were performed in the semantics to accommodate ubiquitous nesting of these holistic models.',
    id: "qFWX",
  },
  {
    name: "Rapira",
    description:
      "PROTEL languages were designed to meet the needs of digital telephony and is the basis of the DMS-100 line of switching systems PROTEL is a strongly typed, block-structured language which is based heavily on PASCAL and ALGOL 68 with left-to-right style of variable assignment, variable-sized arrays, and extensible structures. The designers of PROTEL significantly extended PASCAL of the day by adding external compilation and extending the data structures available in the language. Variables are declared in a manner similar to Pascal. To assign a value: Note: The digraph '->' is colloquially called the gazinta operator (because, in the example above, 5 goes into (=gazinta) MYVAR).",
    id: "XlbX",
  },
  {
    name: "ProvideX",
    description:
      "ProvideX is available on several operating systems (Unix/Linux/Windows/Mac OS X) and includes not only the programming language but also file system, presentation layer interface, and other components. The language is primarily designed for use in the development of business applications. Over the years since its inception and as the computer industry has changed, ProvideX has added functionality such as a graphical interface, client-server capabilities, access to external databases, web services, and, more recently, object-oriented programming capabilities. On October 8, 2010, PVX Plus Technologies announced that it has assumed all ongoing sales, development, and support of the ProvideX product line for Independent Software Vendors. This brings the development of the language back under control of the original creator, Mike King and is the end result of almost 2 years of negotiations between Sage, EDIAS, and PVX Plus Technologies.  ",
    "Designed by": "Michael F. King",
    Developer: "Sage Software Canada",
    "First appeared": "1992; 30 years ago",
    "Stable release": "9.10 / July 15, 2010; 11 years ago",
    "Typing discipline": "strong",
    OS: "Windows / Unix / Linux / Mac OS X",
    "Filename extensions": ".pvx, .pvc, .pvk, .pvt",
    Website: "www.pvxplus.com",
    id: "05uN",
  },
  {
    name: "Pure",
    image: "https://upload.wikimedia.org/wikipedia/en/5/5a/Pure_lang_logo.png",
    description:
      "Pure comes with an interpreter and debugger, provides automatic memory management, has powerful functional and symbolic programming abilities, and interfaces to libraries in C (e.g., for numerics, low-level protocols, and other such tasks). At the same time, Pure is a small language designed from scratch; its interpreter is not large, and the library modules are written in Pure. The syntax of Pure resembles that of Miranda and Haskell, but it is a free-format language and thus uses explicit delimiters (rather than off-side rule indents) to denote program structure. The Pure language is a successor of the equational programming language Q, previously created by the same author, Albert Gräf at the University of Mainz, Germany. Relative to Q, it offers some important new features (such as local functions with lexical scoping, efficient vector and matrix support, and the built-in C interface) and programs run much faster as they are compiled just-in-time to native code on the fly. Pure is mostly aimed at mathematical applications and scientific computing currently, but its interactive interpreter environment, the C interface and the growing set of addon modules make it suitable for a variety of other applications, such as artificial intelligence, symbolic computation, and real-time multimedia processing. Pure plug-ins are available for the Gnumeric spreadsheet and Miller Puckette's Pure Data graphical multimedia software, which make it possible to extend these programs with functions written in the Pure language. Interfaces are also provided as library modules to GNU Octave, OpenCV, OpenGL, the GNU Scientific Library, FAUST, SuperCollider, and liblo (for Open Sound Control (OSC)). The Fibonacci numbers (naive version):",
    Paradigm: "Functional, declarative, term rewriting",
    "Designed by": "Albert Gräf",
    Developer: "Albert Gräf",
    "First appeared": "2008; 14 years ago",
    "Stable release": "0.68 / 11 April 2018; 3 years ago",
    "Typing discipline": "Strong, dynamic",
    OS: "Cross-platform: FreeBSD, Linux, macOS, Windows",
    License: "GNU Lesser General Public License",
    Website: "agraef.github.io/pure-lang/",
    id: "mvdM",
  },
  {
    name: "Pure Data",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/34/Pure_Data_logo.svg/120px-Pure_Data_logo.svg.png",
    description:
      'Pd is very similar in scope and design to Puckette\'s original Max program, developed while he was at IRCAM, and is to some degree interoperable with Max/MSP, the commercial predecessor to the Max language. They may be collectively discussed as members of the Patcher family of languages. With the addition of the Graphics Environment for Multimedia (GEM) external, and externals designed to work with it (like Pure Data Packet / PiDiP for Linux, Mac OS X), framestein for Windows, GridFlow (as n-dimensional matrix processing, for Linux, Mac OS X, Windows), it is possible to create and manipulate video, OpenGL graphics, images, etc., in realtime with extensive possibilities for interactivity with audio, external sensors, etc. Pd is natively designed to enable live collaboration across networks or the Internet, allowing musicians connected via LAN or even in disparate parts of the globe to create music together in real time. Pd uses FUDI as a networking protocol. Pure Data and Max are both examples of dataflow programming languages. Dataflow languages model a program as a directed graph of the data flowing between operations. In Pure Data and Max, functions or "objects" are linked or "patched" together in a graphical environment which models the flow of the control and audio. Unlike the original version of Max, however, Pd was always designed to do control-rate and audio processing on the host central processing unit (CPU), rather than offloading the sound synthesis and signal processing to a digital signal processor (DSP) board (such as the Ariel ISPW which was used for Max/FTS). Pd code forms the basis of David Zicarelli\'s MSP extensions to the Max language to do software audio processing.',
    "Original author(s)": "Miller Puckette",
    "Stable release": "0.51-4 / June 9, 2021; 7 months ago",
    Repository: "github.com/pure-data/pure-data ",
    Type: "Visual programming language",
    License: "BSD-3-Clause",
    Website: "puredata.info",
    Paradigm: "Dataflow",
    "Designed by": "Miller S. Puckette",
    "First appeared": "1996",
    OS: "Cross-platform (macOS, Windows, Linux)",
    other_details: {
      type: "data",
      extensions: [".pd"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 300,
    },
    id: "66R5",
  },
  {
    name: "PureScript",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/PureScript_Logo.png/220px-PureScript_Logo.png",
    description:
      'PureScript was initially designed by Phil Freeman in 2013. He started to work on PureScript since he wasn\'t satisfied by other attempts to compile Haskell to JavaScript (e.g. using Fay, Haste, or GHCJS). Since then it has been picked up by the community and is developed on GitHub. Additional core tools developed by the community include the dedicated build tool "Pulp", the documentation directory "Pursuit", and the package manager "Spago" PureScript features strict evaluation, persistent data structures and type inference. The PureScript type system shares many features with those of similar functional languages like Haskell: algebraic data types and pattern matching, higher kinded types, type classes and functional dependencies, and higher-rank polymorphism. PureScript\'s type system adds support for row polymorphism and extensible records. However, PureScript lacks support for some of the more advanced features of Haskell like GADTs and type families. The PureScript compiler attempts to produce readable JavaScript code, where possible. Through a simple FFI interface, it also allows the reuse of existing JavaScript code.',
    Paradigm: "Functional",
    "Designed by": "Phil Freeman",
    "First appeared": "2013",
    "Stable release": "0.14.5 / October 22, 2021; 2 months ago",
    "Typing discipline": "Inferred, static, strong",
    License: "BSD",
    "Filename extensions": ".purs",
    Website: "www.purescript.org",
    other_details: {
      type: "programming",
      color: "#1D222D",
      extensions: [".purs"],
      tm_scope: "source.purescript",
      ace_mode: "haskell",
      codemirror_mode: "haskell",
      codemirror_mime_type: "text/x-haskell",
      language_id: 302,
    },
    id: "nwc5",
  },
  {
    name: "Python",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/121px-Python-logo-notext.svg.png",
    description:
      'Python is an interpreted high-level general-purpose programming language. Its design philosophy emphasizes code readability with its use of significant indentation. Its language constructs as well as its object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects. Python is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly, procedural), object-oriented and functional programming. It is often described as a "batteries included" language due to its comprehensive standard library. Guido van Rossum began working on Python in the late 1980s, as a successor to the ABC programming language, and first released it in 1991 as Python 0.9.0. Python 2.0 was released in 2000 and introduced new features, such as list comprehensions and a cycle-detecting garbage collection system (in addition to reference counting). Python 3.0 was released in 2008 and was a major revision of the language that is not completely backward-compatible. Python 2 was discontinued with version 2.7.18 in 2020. Python consistently ranks as one of the most popular programming languages.',
    Paradigm:
      "Multi-paradigm: object-oriented, procedural (imperative), functional, structured, reflective",
    "Designed by": "Guido van Rossum",
    Developer: "Python Software Foundation",
    "First appeared": "20 February 1991; 30 years ago",
    "Stable release": "3.10.2  / 14 January 2022; 1 day ago",
    "Preview release": "3.11.0a4  / 14 January 2022; 1 day ago",
    "Typing discipline":
      "Duck, dynamic, strong typing; gradual (since 3.5, but ignored in CPython)",
    OS: "Windows, Linux/UNIX, macOS and more",
    License: "Python Software Foundation License",
    "Filename extensions":
      ".py, .pyi, .pyc, .pyd, .pyo (prior to 3.5), .pyw, .pyz (since 3.5)",
    Website: "www.python.org",
    other_details: {
      type: "programming",
      ace_mode: "python",
      codemirror_mode: "python",
      codemirror_mime_type: "text/x-python",
      color: "#3572A5",
      extensions: [
        ".py",
        ".bzl",
        ".cgi",
        ".fcgi",
        ".gyp",
        ".gypi",
        ".lmi",
        ".py3",
        ".pyde",
        ".pyi",
        ".pyp",
        ".pyt",
        ".pyw",
        ".rpy",
        ".spec",
        ".tac",
        ".wsgi",
        ".xpy",
      ],
      filenames: [
        ".gclient",
        "BUCK",
        "BUILD",
        "BUILD.bazel",
        "SConscript",
        "SConstruct",
        "Snakefile",
        "WORKSPACE",
        "wscript",
      ],
      interpreters: ["python", "python2", "python3"],
      aliases: ["rusthon", "python3"],
      language_id: 303,
    },
    id: "elma",
  },
  {
    name: "q",
    description:
      "The fundamental building blocks of q are atoms, lists, and functions. Atoms are scalars and include the data types numeric, character, date, and time. Lists are ordered collections of atoms (or other lists) upon which the higher level data structures dictionaries and tables are internally constructed. A dictionary is a map of a list of keys to a list of values. A table is a transposed dictionary of symbol keys and equal length lists (columns) as values. A keyed table, analogous to a table with a primary key placed on it, is a dictionary where the keys and values are arranged as two tables. The following code demonstrates the relationships of the data structures. Expressions to evaluate appear prefixed with the q) prompt, with the output of the evaluation shown beneath: These entities are manipulated via functions, which include the built-in functions that come with Q (which are defined as K macros) and user-defined functions. Functions are a data type, and can be placed in lists, dictionaries and tables, or passed to other functions as parameters. Like K, Q is interpreted and the result of the evaluation of an expression is immediately displayed, unless terminated with a semi-colon. The Hello world program is thus trivial:",
    Paradigm: "Array, functional",
    "Designed by": "Arthur Whitney",
    Developer: "Kx Systems",
    "First appeared": "2003",
    "Stable release": "4.0 / March 17, 2020; 21 months ago",
    "Typing discipline": "Dynamic, strong",
    Website: "code.kx.com",
    other_details: {
      type: "programming",
      extensions: [".q"],
      tm_scope: "source.q",
      ace_mode: "text",
      color: "#0040cd",
      language_id: 970539067,
    },
    id: "a-fk",
  },
  {
    name: "Q#",
    description:
      "During a Microsoft Ignite Keynote on September 26, 2017, Microsoft announced that they were going to release a new programming language geared specifically towards quantum computers. On December 11, 2017, Microsoft released Q# as a part of the Quantum Development Kit. At Build 2019, Microsoft announced that it is open-sourcing the Quantum Development Kit, including its Q# compilers and simulators. Q# is available as a separately downloaded extension for Visual Studio, but it can also be run as an independent tool from the Command line or Visual Studio Code. The Quantum Development Kit ships with a quantum simulator which is capable of running Q#. In order to invoke the quantum simulator, another .NET programming language, usually C#, is used, which provides the (classical) input data for the simulator and reads the (classical) output data from the simulator.",
    Paradigm: "Quantum, functional, imperative",
    "Designed by":
      "Microsoft Research (quantum architectures and computation group; QuArC)",
    Developer: "Microsoft",
    "First appeared": "December 11, 2017",
    "Typing discipline": "Static, strong",
    Platform: "Common Language Infrastructure",
    License: "MIT License",
    "Filename extensions": ".qs",
    Website: "docs.microsoft.com/en-us/quantum",
    id: "9vlb",
  },
  {
    name: "قلب",
    description:
      "The syntax is like that of Lisp or Scheme, consisting of parenthesized lists. All keywords are appropriate Arabic terms, and program text is laid out right-to-left, like all Arabic text. Specifically, the Arabic used is Lebanese Arabic, as is evident by the use of قول instead of the Modern Standard Arabic قل. The language provides a minimal set of primitives for defining functions, conditionals, looping, list manipulation, and basic arithmetic expressions. It is Turing-complete, and the Fibonacci sequence and Conway's Game of Life have been implemented. Because all program text is written in Arabic, and the connecting strokes between characters in the Arabic script can be extended to any length, it is possible to align the source code in artistic patterns, in the tradition of Arabic calligraphy. A JavaScript-based interpreter is currently hosted on herokuapp and the project can be forked on GitHub.  ",
    Paradigm: "Functional",
    "Designed by": "Ramsey Nasser",
    "First appeared": "2012",
    Website: "qlb-repl.herokuapp.com",
    id: "bi_b",
  },
  {
    name: "ROOP",
    description:
      "The QCL standard library provides standard quantum operators used in quantum algorithms such as: The basic built-in quantum data type in QCL is the qureg (quantum register). It can be interpreted as an array of qubits (quantum bits). Since the qcl interpreter uses qlib simulation library, it is possible to observe the internal state of the quantum machine during execution of the quantum program. Note that the dump operation is different from measurement, since it does not influence the state of the quantum machine and can be realized only using a simulator.",
    id: "Uhk1",
  },
  {
    name: "RPG",
    description:
      "The scripting language is based on the ECMAScript standard with a few extensions, such as QObject-style signal and slot connections. The library contains the engine, and a C++ API for evaluating QtScript code and exposing custom QObject-derived C++ classes to QtScript. The QtScript Binding Generator provides bindings for the Qt API to access directly from ECMAScript.[clarification needed update needed?] QtScript and the binding generator are used for Amarok 2's scripting system. The current (as of Qt 4.7) implementation uses JavaScriptCore and will not be further developed. The module is deprecated as of Qt 5.5. An earlier and unrelated scripting engine, called Qt Script for Applications (QSA), was shipped by Trolltech as a separate Qt-based library, dual-licensed under GPL and a commercial license.",
    id: "jrKP",
  },
  {
    name: "QuakeC",
    description:
      'The QuakeC source to the original id Software Quake game logic was published in 1996 and used as the basis for modifications like capture the flag and others. QuakeC source code is compiled using a tool called qcc into a bytecode kept in a file called progs.dat. The programmers of Quake modifications could then publish their progs.dat bytecode without revealing their source code. Most Quake mods were published this way. QuakeC allowed the Quake engine to dominate the direction of the first-person shooter genre.[citation needed] Thanks to Carmack\'s idea of extending video game life by adding unlimited expandability (extensibility already played a big role in Doom), an enormous Internet community of gamers and programmers alike has arisen and many modern multiplayer games are extensible in some form.[citation needed] QuakeC is known as interpreted because as Quake runs, it is continually interpreting the progs.dat file. The syntax of QuakeC is based on that of the C programming language, explaining its name, but it does not support the implementation of new types, structures, arrays, or any kind of referencing other than the "entity" type (which is always a reference). QuakeC also suffers from the fact that many built-in functions (functions prototyped in the QuakeC code but actually defined within the game engine and written in C) return strings in a temporary string buffer, which can only hold one string at any given time. In other words, a construct such as',
    Paradigm: "imperative (procedural), structured",
    "Designed by": "John Carmack",
    Developer: "id Software",
    "First appeared": "1996",
    "Typing discipline": "static, strong",
    id: "lYlr",
  },
  {
    name: "RSL",
    description:
      "Quantum instruction sets are used to turn higher level algorithms into physical instructions that can be executed on quantum processors. Sometimes these instructions are specific to a given hardware platform, e.g. ion traps or superconducting qubits. cQASM, also known as common QASM, is a hardware-agnostic QASM which guarantees the interoperability between all the quantum compilation and simulation tools. It was introduced by the QCA Lab at TUDelft. Quil is an instruction set architecture for quantum computing that first introduced a shared quantum/classical memory model. It was introduced by Robert Smith, Michael Curtis, and William Zeng in A Practical Quantum Instruction Set Architecture. Many quantum algorithms (including quantum teleportation, quantum error correction, simulation, and optimization algorithms) require a shared memory architecture. OpenQASM is the intermediate representation introduced by IBM for use with Qiskit and the IBM Q Experience.",
    id: "CxXa",
  },
  {
    name: ".QL",
    image: "https://upload.wikimedia.org/wikipedia/en/b/b4/Dotql.png",
    description:
      "Queries written in .QL are optimised, compiled into SQL and can then be executed on any major relational database management system. .QL query language is being used in SemmleCode to query a relational representation of Java programs. .QL is developed at Semmle Limited and is based on the company's proprietary technology. .QL has several language features to make queries concise, intuitive and reusable: The sample query below illustrates use of .QL to query a Java program. This is how one would select all classes that contain more than ten public methods:",
    Paradigm: "multi-paradigm, logic-paradigm, object-oriented-paradigm",
    Developer: "Semmle",
    "First appeared": "2007",
    "Typing discipline": "static, strong",
    id: "MUYG",
  },
  {
    name: "R",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/121px-R_logo.svg.png",
    description:
      "R is a programming language for statistical computing and graphics supported by the R Core Team and the R Foundation for Statistical Computing. Created by statisticians Ross Ihaka and Robert Gentleman, R is used among data miners and statisticians for data analysis and developing statistical software. Users have created packages to augment the functions of the R language. Polls, data mining surveys and studies of scholarly literature databases show that R is highly popular. As of January 2022, R ranks 12th in the TIOBE index, a measure of programming language popularity. The official R software environment is an open-source free software environment within the GNU package, available under the GNU General Public License. It is written primarily in C, Fortran, and R itself (partially self-hosting). Precompiled executables are provided for various operating systems. R has a command line interface. Multiple third-party graphical user interfaces are also available, such as RStudio, an integrated development environment, and Jupyter, a notebook interface. R is an open-source implementation of the S programming language combined with lexical scoping semantics from Scheme, which allow objects to be defined in predetermined blocks rather than the entirety of the code. S was created by Rick Becker, John Chambers, Doug Dunn, Jean McRae, and Judy Schilling at Bell Labs around 1976. Designed for statistical analysis, the language is an interpreted language whose code could be directly run without a compiler. Many codes written for S run unaltered in R. Scheme was created by Gerald J. Sussman and Guy L. Steele Jr. at MIT around 1975.",
    Paradigms:
      "Multi-paradigm: procedural, object-oriented, functional, reflective, imperative, array",
    "Designed by": "Ross Ihaka and Robert Gentleman",
    Developer: "R Core Team",
    "First appeared": "August 1993; 28 years ago",
    "Stable release": "4.1.2 / 1 November 2021; 2 months ago",
    "Typing discipline": "Dynamic",
    License: "GNU GPL v2",
    "Filename extensions": ".r .rdata .rds .rda",
    Website: "www.r-project.org ",
    other_details: {
      type: "programming",
      color: "#198CE7",
      aliases: ["R", "Rscript", "splus"],
      extensions: [".r", ".rd", ".rsx"],
      filenames: [".Rprofile", "expr-dist"],
      interpreters: ["Rscript"],
      ace_mode: "r",
      codemirror_mode: "r",
      codemirror_mime_type: "text/x-rsrc",
      language_id: 307,
    },
    id: "QXAT",
  },
  {
    name: "Racket",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Racket-logo.svg/121px-Racket-logo.svg.png",
    description:
      'The Racket language is a modern dialect of Lisp and a descendant of the Scheme. It is designed as a platform for programming language design and implementation. In addition to the core Racket language, Racket is also used to refer to the family of programming languages and set of tools supporting development on and with Racket. Racket is also used for scripting, computer science education, and research. The Racket platform provides an implementation of the Racket language (including a runtime system, libraries, and compiler supporting several compilation modes: machine code, machine-independent, interpreted, and JIT) along with the DrRacket integrated development environment (IDE) written in Racket. Racket is used by the ProgramByDesign outreach program, which aims to turn computer science into "an indispensable part of the liberal arts curriculum". The core Racket language is known for its extensive macro system which enables creating embedded and domain-specific languages, language constructs such as classes or modules, and separate dialects of Racket with different semantics. The platform distribution is free and open-source software distributed under the Apache 2.0 and MIT licenses. Extensions and packages written by the community may be uploaded to Racket\'s package catalog.',
    Paradigm:
      "Multi-paradigm: functional, imperative, logic, meta, modular, object-oriented, reflective",
    Family: "Lisp",
    "Designed by": "PLT Inc.",
    Developer: "PLT Inc.",
    "First appeared": "1995; 27 years ago",
    "Stable release": "8.3  / 6 November 2021; 2 months ago",
    "Typing discipline": "Dynamic, static, strong",
    Platform: "x86, PowerPC, SPARC, MIPS, ARM",
    OS: "Cross-platform",
    License: "MIT or Apache 2.0",
    "Filename extensions": ".rkt",
    Website: "racket-lang.org",
    other_details: {
      type: "programming",
      color: "#22228f",
      extensions: [".rkt", ".rktd", ".rktl", ".scrbl"],
      interpreters: ["racket"],
      tm_scope: "source.racket",
      ace_mode: "lisp",
      language_id: 316,
    },
    id: "cLu5",
  },
  {
    name: "Raku",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/85/Camelia.svg/250px-Camelia.svg.png",
    description:
      'In Perl 6, we decided it would be better to fix the language than fix the user. The Raku design process was first announced on 19 July 2000, on the fourth day of that year\'s Perl Conference, by Larry Wall in his State of the Onion 2000 talk. At that time, the primary goals were to remove "historical warts" from the language; "easy things should stay easy, hard things should get easier, and impossible things should get hard"; a general cleanup of the internal design and APIs. The process began with a series of requests for comments or "RFCs". This process was open to all contributors, and left no aspect of the language closed to change. Once the RFC process was complete, Wall reviewed and classified each request (361 were received). He then began the process of writing several "Apocalypses", using the original meaning of the term, "revealing". While the original goal was to write one Apocalypse for each chapter of Programming Perl, it became obvious that, as each Apocalypse was written, previous Apocalypses were being invalidated by later changes. For this reason, a set of Synopses were published, each one relating the contents of an Apocalypse, but with any subsequent changes reflected in updates. Today, the Raku specification is managed through the "roast" testing suite, while the Synopses are kept as a historical reference. There are also a series of Exegeses written by Damian Conway that explain the content of each Apocalypse in terms of practical usage. Each Exegesis consists of code examples along with discussion of the usage and implications of the examples.',
    Paradigm: "Multi-paradigm",
    Family: "Perl",
    "Designed by": "Larry Wall",
    Developer: "Raku community",
    "First appeared": "25 December 2015; 6 years ago",
    "Stable release": "6.d 'Diwali'  / 24 October 2020; 14 months ago",
    "Typing discipline": "Dynamic, gradual",
    OS: "Cross-platform",
    License: "GNU General Public License or Artistic License 2",
    "Filename extensions":
      ".p6, .pm6, .pod6, .t6, .raku, .rakumod, .rakudoc, .rakutest ",
    Website: "raku.org",
    id: "zr7g",
  },
  {
    name: "Rapira",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/RAPIRA_example.png/300px-RAPIRA_example.png",
    description:
      "Rapira (Russian: Рапира, rapier) is an educational procedural programming language developed in the Soviet Union and implemented on the Agat computer, PDP-11 clones (Electronika, DVK, BK series), and Intel 8080 and Zilog Z80 clones (Korvet). It is interpreted with a dynamic type system and high level constructions. The language originally had a Russian-based set of reserved words (keywords), but English and Romanian were added later. It was considered more elegant and easier to use than Pascal implementations of the time.[according to whom?] Rapira was used to teach computer programming in Soviet schools. The integrated development environment included a text editor and a debugger. Sample program: The same, but using the English lexics [sic, from the article referenced below]:",
    Paradigms: "procedural, structured",
    "Designed by": "Andrey Ershov",
    "First appeared": "1982; 40 years ago",
    "Typing discipline": "dynamic",
    Scope: "Lexical (static)",
    Platform:
      "Agat, PDP-11 (clones: Electronika, DVK series); Intel 8080, Zilog Z80",
    id: "2g7M",
  },
  {
    name: "Ratfor",
    description:
      'Ratfor provides the following kinds of flow-control statements, described by Kernighan and Plauger as "shamelessly stolen from the language C, developed for the UNIX operating system by D.M. Ritchie" ("Software Tools", p. 318): For example, the following code might be translated as The version of Ratfor in Software Tools is written in Ratfor, as are the sample programs, and inasmuch as its own translation to Fortran is available, it can be ported to any Fortran system. Ratfor source code file names end in .r or .rat.',
    Developer: "Brian Kernighan",
    "First appeared": "1976",
    Website: "sepwww.stanford.edu",
    id: "hvW7",
  },
  {
    name: "Ratfor",
    description:
      'Ratfor provides the following kinds of flow-control statements, described by Kernighan and Plauger as "shamelessly stolen from the language C, developed for the UNIX operating system by D.M. Ritchie" ("Software Tools", p. 318): For example, the following code might be translated as The version of Ratfor in Software Tools is written in Ratfor, as are the sample programs, and inasmuch as its own translation to Fortran is available, it can be ported to any Fortran system. Ratfor source code file names end in .r or .rat.',
    Developer: "Brian Kernighan",
    "First appeared": "1976",
    Website: "sepwww.stanford.edu",
    id: "l84v",
  },
  {
    name: "rc",
    description:
      'A port of the original rc to Unix is part of Plan 9 from User Space. A rewrite of rc for Unix-like operating systems by Byron Rakitzis is also available but includes some incompatible changes. Rc uses C-like control structures instead of the original Bourne shell\'s ALGOL-like structures, except that it uses an if not construct instead of else, and has a Bourne-like for loop to iterate over lists. In rc, all variables are lists of strings, which eliminates the need for constructs like "$@". Variables are not re-split when expanded. The language is described in Duff\'s paper. es (for "extensible shell") is an open source, command line interpreter developed by Rakitzis and Paul Haahr that uses a scripting language syntax influenced by the rc shell. It was originally based on code from Byron Rakitzis\'s clone of rc for Unix. Extensible shell is intended to provide a fully functional programming language as a Unix shell. It does so by introducing "program fragments" in braces as a new datatype, lexical scoping via let, and some more minor improvements. The bulk of es development occurred in the early 1990s, after the shell was introduced at the Winter 1993 USENIX conference in San Diego, Official releases appear to have ceased after 0.9-beta-1 in 1997, and es lacks features as compared to more popular shells, such as zsh and bash. A public domain fork of es is active as of 2019.',
    Paradigm: "imperative, pipeline",
    "Designed by": "Tom Duff",
    Developer: "Bell Labs",
    "First appeared": "1989; 33 years ago",
    "Typing discipline": "weak",
    OS: "Cross-platform (Version 10 Unix, Plan 9, Plan 9 from User Space)",
    Website: "doc.cat-v.org/plan_9/4th_edition/papers/rc",
    id: "Kabi",
  },
  {
    name: "Rebol",
    image: "https://upload.wikimedia.org/wikipedia/commons/a/a2/Rebol_logo.png",
    description:
      "Rebol (/ˈrɛbəl/ REB-əl; historically REBOL) is a cross-platform data exchange language and a multi-paradigm dynamic programming language designed by Carl Sassenrath for network communications and distributed computing. It introduces the concept of dialecting: small, optimized, domain-specific languages for code and data, which is also the most notable property of the language according to its designer Carl Sassenrath: Although it can be used for programming, writing functions, and performing processes, its greatest strength is the ability to easily create domain-specific languages or dialects Douglas Crockford, known for his involvement in the development of JavaScript, has described Rebol as \"a more modern language, but with some very similar ideas to Lisp, in that it's all built upon a representation of data which is then executable as programs\" and as one of JSON's influences. Originally, the language and its official implementation were proprietary and closed source, developed by REBOL Technologies. Following discussion with Lawrence Rosen, the Rebol version 3 interpreter was released under the Apache 2.0 license on December 12, 2012. Older versions are only available in binary form, and no source release for them is planned.",
    Paradigm:
      "language oriented programming, data exchange, functional, prototype-based, imperative",
    "Designed by": "Carl Sassenrath",
    Developer: "REBOL Technologies",
    "First appeared": "1997; 25 years ago",
    "Stable release": "2.7.8 / January 2011; 11 years ago",
    "Preview release": "2.101.0 / December 2012; 9 years ago",
    "Typing discipline": "dynamic, strong",
    OS: "cross-platform",
    License:
      "2.7.8 is Freely redistributable software, 2.101.0 has Apache 2.0 license",
    "Filename extensions": ".r, .reb",
    Website: "www.rebol.com",
    other_details: {
      type: "programming",
      color: "#358a5b",
      extensions: [".reb", ".r", ".r2", ".r3", ".rebol"],
      ace_mode: "text",
      tm_scope: "source.rebol",
      language_id: 319,
    },
    id: "TYKU",
  },
  {
    name: "Red",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/e/e9/Red_Language_Tower_Logo.png/150px-Red_Language_Tower_Logo.png",
    description:
      'The implementation choices of Red intend to create a full stack programming language: Red can be used for extremely high-level programming (DSLs and GUIs) as well as low-level programming (operating systems and device drivers). Key to the approach is that the language has two parts: Red/System and Red. Red seeks to remain independent of any other toolchain; it does its own code generation. It is therefore possible to cross-compile Red programs from any platform it supports to any other, via a command-line switch. Both Red and Red/System are distributed as open-source software under the modified BSD license. The runtime library is distributed under the more permissive Boost Software License. As of version 0.6.4 Red includes a garbage collector "the Simple GC". Red was introduced in the Netherlands on February 2011 at the Rebol & Boron conference by its author Nenad Rakočević. In September 2011, the Red programming language was presented to a larger audience during the Software Freedom Day 2011. Rakočević is a long-time Rebol developer known as the creator of the Cheyenne HTTP server.',
    Paradigm: "imperative, functional, symbolic",
    "Designed by": "Nenad Rakočević",
    Developer: "Nenad Rakočević",
    "First appeared": "2011",
    "Stable release": "0.6.4 (Alpha) / December 7, 2018",
    OS: "Linux, Windows, OS X, Syllable",
    License: "modified BSD and Boost",
    "Filename extensions": ".red, .reds",
    Website: "www.red-lang.org ",
    other_details: {
      type: "programming",
      color: "#f50000",
      extensions: [".red", ".reds"],
      aliases: ["red/system"],
      tm_scope: "source.red",
      ace_mode: "text",
      language_id: 320,
    },
    id: "omhN",
  },
  {
    name: "Sather",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/c/c2/Core_War_PMars_Screenshot.png",
    description:
      "At the beginning of a game, each battle program is loaded into memory at a random location, after which each program executes one instruction in turn. The goal of the game is to cause the processes of opposing programs to terminate (which happens if they execute an invalid instruction), leaving the victorious program in sole possession of the machine. The earliest published version of Redcode defined only eight instructions. The ICWS-86 standard increased the number to 10 while the ICWS-88 standard increased it to 11. The currently used 1994 draft standard has 16 instructions. However, Redcode supports a number of different addressing modes and (starting from the 1994 draft standard) instruction modifiers which increase the actual number of operations possible to 7168. The Redcode standard leaves the underlying instruction representation undefined and provides no means for programs to access it. Arithmetic operations may be done on the two address fields contained in each instruction, but the only operations supported on the instruction codes themselves are copying and comparing for equality. A number of versions of Redcode exist. The earliest version described by A. K. Dewdney differs in many respects from the later standards established by the International Core War Society, and could be considered a different, albeit related, language. The form of Redcode most commonly used today is based on a draft standard submitted to the ICWS in 1994 that was never formally accepted, as the ICWS had become effectively defunct around that time. Development of Redcode, however, has continued in an informal manner, chiefly via online forums such as the rec.games.corewar newsgroup. Warriors are commonly divided into a number of broad categories, although actual warriors may often combine the behavior of two or more of these. Three of the common strategies (replicator, scanner and bomber) are also known as paper, scissors and stone, since their performance against each other approximates that of their namesakes in the well-known playground game.",
    "Developer(s)": "D. G. Jones & A. K. Dewdney",
    Release: "March 1984",
    "Genre(s)": "Programming game",
    id: "jfuY",
  },
  {
    name: "Refal",
    description:
      "One of the first functional programming languages to do so, and unlike Lisp of its time, Refal is based on pattern matching. Its pattern matching works in conjunction with term rewriting. The basic data structure of Lisp and Prolog is a linear list built by cons operation in a sequential manner, thus with O(n) access to list's nth element. Refal's lists are built and scanned from both ends, with pattern matching working for nested lists as well as the top-level one. In effect, the basic data structure of Refal is a tree rather than a list. This gives freedom and convenience in creating data structures while using only mathematically simple control mechanisms of pattern matching and substitution. Refal also includes a feature called the freezer to support efficient partial evaluation. Refal can be applied to the processing and transformation of tree structures, similarly to XSLT.",
    Paradigm: "Pattern-matching and term-rewriting",
    "Designed by": "Valentin Turchin",
    Developer: "Valentin Turchin, S. Florentsev, V. Olyunin, et al.",
    "First appeared": "1968",
    "Typing discipline": "strong, dynamic",
    Website: "http://www.refal.net",
    id: "XMqx",
  },
  {
    name: "Rexx",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/f/f7/Rexx-img-lg.png/220px-Rexx-img-lg.png",
    description:
      'Rexx (Restructured Extended Executor) is a programming language that can be interpreted or compiled. It was developed at IBM by Mike Cowlishaw. It is a structured, high-level programming language designed for ease of learning and reading. Proprietary and open source Rexx interpreters exist for a wide range of computing platforms; compilers exist for IBM mainframe computers. Rexx is a full language that can be used as a scripting, macro language, and application development language. It is often used for processing data and text and generating reports; these similarities with Perl mean that Rexx works well in Common Gateway Interface (CGI) programming and it is indeed used for this purpose. Rexx is the primary scripting language in some operating systems, e.g. OS/2, MVS, VM, AmigaOS, and is also used as an internal macro language in some other software, such as SPFPC, KEDIT, THE and the ZOC terminal emulator. Additionally, the Rexx language can be used for scripting and macros in any program that uses Windows Scripting Host ActiveX scripting engines languages (e.g. VBScript and JScript) if one of the Rexx engines is installed. Rexx is supplied with VM/SP Release 3 on up, TSO/E Version 2 on up, OS/2 (1.3 and later, where it is officially named Procedures Language/2), AmigaOS Version 2 on up, PC DOS (7.0 or 2000), ArcaOS, and Windows NT 4.0 (Resource Kit: Regina). REXX scripts for OS/2 share the filename extension .cmd with other scripting languages, and the first line of the script specifies the interpreter to be used. REXX macros for REXX-aware applications use extensions determined by the application. In the late 1980s, Rexx became the common scripting language for IBM Systems Application Architecture, where it was renamed "SAA Procedure Language REXX". A Rexx script or command is sometimes referred to as an EXEC in a nod to the CMS file type used for EXEC, EXEC 2 and REXX scripts on CP/CMS and VM/370 through z/VM.',
    Paradigm: "multiparadigm: procedural, structured",
    "Designed by": "Mike Cowlishaw",
    Developer: "Mike Cowlishaw, IBM",
    "First appeared": "1979; 43 years ago",
    "Stable release": "ANSI X3.274 / 1996; 26 years ago",
    "Typing discipline": "Dynamic",
    "Filename extensions": ".cmd, .bat, .exec, .rexx, .rex, EXEC",
    id: "yIwj",
  },
  {
    name: "RPG Report Program Generator",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/IBM_RPG_logo.png/220px-IBM_RPG_logo.png",
    description:
      "The RPG programming language originally was created by IBM for their 1401 systems. They also produced an implementation for the System/360, and it became the primary programming language for their midrange computer product line, (the System/3, System/32, System/34, System/38, System/36 and AS/400). There have also been implementations for the Digital VAX, Sperry Univac BC/7, Univac system 80, Siemens BS2000, Burroughs B700, B1700, Hewlett Packard HP 3000, the ICL 2900 series, Honeywell 6220 and 2020, Four-Phase IV/70 and IV/90 series, Singer System 10 and WANG VS, as well as miscellaneous compilers and runtime environments for Unix-based systems, such as Infinite36 (formerly Unibol 36), and PCs (Baby/400, Lattice-RPG). RPG II applications are still supported under the IBM z/VSE and z/OS operating systems, Unisys MCP, Microsoft Windows and OpenVMS. Originally developed by IBM in 1959, the name Report Program Generator was descriptive of the purpose of the language: generation of reports from data files. FOLDOC accredits Wilf Hey with work at IBM that resulted in the development of RPG. FARGO (Fourteen-o-one Automatic Report Generation Operation) was the predecessor to RPG on the IBM 1401. Both languages were intended to facilitate ease of transition for IBM tabulating machine (Tab) unit record equipment technicians to the then-new computers. Tab machine technicians were accustomed to plugging wires into control panels to implement input, output, control and counter operations (add, subtract, multiply, divide). Tab machines programs were executed by impulses emitted in a machine cycle; hence, FARGO and RPG emulated the notion of the machine cycle with the program cycle. RPG was superior to and rapidly replaced FARGO as the report generator program of choice.",
    Paradigm: "Multi-paradigm",
    Developer: "IBM",
    "First appeared": "1959; 63 years ago",
    "Stable release": "RPG IV version 7 release 4 / October 6, 2020",
    "Typing discipline": "Strong, static",
    OS: "CPF, SSP, OS/400, IBM i, OS/VS1, z/OS, DOS/VSE, VSE/SP, VSE/ESA, z/VSE, VS/9, PRIMOS, OpenVMS, Wang VS, Burroughs MCP, HP MPE, MS-DOS, OS/2, Microsoft Windows",
    id: "cxiK",
  },
  {
    name: "RPL",
    description:
      "RPL is a handheld calculator operating system and application programming language used on Hewlett-Packard's scientific graphing RPN (Reverse Polish Notation) calculators of the HP 28, 48, 49 and 50 series, but it is also usable on non-RPN calculators, such as the 38, 39 and 40 series. RPL is a structured programming language based on RPN, but equally capable of processing algebraic expressions and formulae, implemented as a threaded interpreter. RPL has many similarities to Forth, both languages being stack-based, as well as the list-based LISP. Contrary to previous HP RPN calculators, which had a fixed four-level stack, the stack used by RPL is only limited by available calculator RAM. RPL originated from HP's Corvallis, Oregon development facility in 1984 as a replacement for the previous practice of implementing the operating systems of calculators in assembly language. The last pocket calculator supporting RPL, the HP 50g, was discontinued in 2015. However, multiple emulators that can emulate HP's RPL calculators exist that run on a range of operating systems, and devices, including iOS and Android smartphones. The internal low- to medium-level variant of RPL, called System RPL (or SysRPL) is used on some earlier HP calculators as well as the aforementioned ones, as part of their operating system implementation language. In the HP 48 series this variant of RPL is not accessible to the calculator user without the use of external tools, but in the HP 49/50 series there is a compiler built into ROM to use SysRPL. It is possible to cause a serious crash while coding in SysRPL, so caution must be used while using it. The high-level User RPL (or UserRPL) version of the language is available on said graphing calculators for developing textual as well as graphical application programs. All UserRPL programs are internally represented as SysRPL programs, but use only a safe subset of the available SysRPL commands. The error checking that is a part of UserRPL commands, however, makes UserRPL programs noticeably slower than equivalent SysRPL programs. The UserRPL command SYSEVAL tells the calculator to process designated parts of a UserRPL program as SysRPL code.",
    Paradigm: "Stack, structured, concatenative, partially object-oriented",
    "Designed by": "Hewlett-Packard",
    "First appeared": "1984 (1986)",
    OS: "HP calculators",
    id: "dCFc",
  },
  {
    name: "Script.NET",
    image:
      "https://upload.wikimedia.org/wikipedia/en/5/56/Image-Robot_Battle_Logo.png",
    description:
      "Robot Battle is a programming game for Microsoft Windows where players design and code adaptable battling robots. Robot Battle takes strategy rather than reflexes, accuracy, or timing to succeed. What differentiates one robot from the next is its programming, for which the player is responsible. The game is inspired by the similar game RobotWar. Robot Battle was created by Brad Schick in 1994 and released to the public for free in the same year, when it reached version 1.2. It went through many versions until seeming to peak at 1.3 in 1995, until in 1997 David Finch released 1.33. The community was at that time held together by the Robot Battle Mailing List (RBML) (which was closed in February 2004 when the Robot Battle Registry, an Internet forum, opened), where tournaments were held, new players could be helped and complicated coding questions could be posed and answered. Early in 2001 Brad began work on Robot Battle 1.4, which promised to be a massive upgrade. The RBML was alive with ideas, suggestions and offers to help, which resulted in the Robot Battle that new players will know, including new features such as: Then in mid-2001 a small company called GarageGames showed an interest in Robot Battle and Brad agreed to sell the game through them. Soon after the first official 1.4 release in December 2002 work began on the Robot Battle Registry, a forum and a way of storing robots so that other people can download them, as well as a way to organise and advertise tournaments. The registry opened in May 2003.",
    "Developer(s)": "Brad Schick",
    "Publisher(s)": "GarageGames",
    "Platform(s)": "Windows",
    Release: "2002",
    "Genre(s)": "Programming game",
    "Mode(s)": "Single-player",
    id: "axoP",
  },
  {
    name: "RTL/2",
    description:
      "RTL/2 (Real-Time Language) is a discontinued high-level programming language for use in real-time computing, developed at Imperial Chemical Industries, Ltd. (ICI), by J.G.P. Barnes. It was originally used internally in ICI but was distributed by SPL International in 1974. It was based on concepts from ALGOL 68, and intended to be small and simple. RTL/2 was standardised in 1980 by the British Standards Institution. The data types in RTL/2 were strongly typed, with separate compiling. The compilation units contained one or more items named bricks, i.e.: A procedure brick was a procedure, which may or may not return a (scalar) value, have (scalar) parameters, or have local (scalar) variables. The entry mechanism and implementation of local variables was reentrant. Non-scalar data could only be accessed via reference (so-called REF variables were considered scalar). A data brick was a named static collection of scalars, arrays and records. There was no heap or garbage collection, so programmers had to implement memory management manually.",
    Paradigms: "Multi-paradigm: imperative, structured, real-time",
    Family: "ALGOL",
    "Designed by": "J.G.P. Barnes",
    Developer: "Imperial Chemical Industries",
    "First appeared": "1972; 50 years ago",
    "Typing discipline": "static, strong, safe, structural",
    Scope: "Lexical",
    Platform: "PDP-11, VAX",
    OS: "Cross- (multi-) platformRSX-11M, VMS",
    id: "fTnU",
  },
  {
    name: "Ruby",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Ruby_logo.svg/64px-Ruby_logo.svg.png",
    description:
      "Ruby is dynamically typed and uses garbage collection and just-in-time compilation. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. According to the creator, Ruby was influenced by Perl, Smalltalk, Eiffel, Ada, BASIC, and Lisp. Matsumoto has said that Ruby was conceived in 1993. In a 1999 post to the ruby-talk mailing list, he describes some of his early ideas about the language: I was talking with my colleague about the possibility of an object-oriented scripting language. I knew Perl (Perl4, not Perl5), but I didn't like it really, because it had the smell of a toy language (it still has). The object-oriented language seemed very promising. I knew Python then. But I didn't like it, because I didn't think it was a true object-oriented language – OO features appeared to be add-on to the language. As a language maniac and OO fan for 15 years, I really wanted a genuine object-oriented, easy-to-use scripting language. I looked for but couldn't find one. So I decided to make it. Matsumoto describes the design of Ruby as being like a simple Lisp language at its core, with an object system like that of Smalltalk, blocks inspired by higher-order functions, and practical utility like that of Perl.",
    Paradigm:
      "Multi-paradigm: functional, imperative, object-oriented, reflective",
    "Designed by": "Yukihiro Matsumoto",
    Developer: "Yukihiro Matsumoto, et al.",
    "First appeared": "1995; 27 years ago",
    "Stable release": "3.1.0  / 25 December 2021; 23 days ago",
    "Typing discipline": "Duck, dynamic, strong",
    Scope: "Lexical, sometimes dynamic",
    "Implementation language": "C",
    OS: "Cross-platform",
    License: "Ruby License",
    "Filename extensions": ".rb",
    Website: "www.ruby-lang.org",
    other_details: {
      type: "programming",
      ace_mode: "ruby",
      codemirror_mode: "ruby",
      codemirror_mime_type: "text/x-ruby",
      color: "#701516",
      aliases: ["jruby", "macruby", "rake", "rb", "rbx"],
      extensions: [
        ".rb",
        ".builder",
        ".eye",
        ".fcgi",
        ".gemspec",
        ".god",
        ".jbuilder",
        ".mspec",
        ".pluginspec",
        ".podspec",
        ".rabl",
        ".rake",
        ".rbuild",
        ".rbw",
        ".rbx",
        ".ru",
        ".ruby",
        ".spec",
        ".thor",
        ".watchr",
      ],
      interpreters: ["ruby", "macruby", "rake", "jruby", "rbx"],
      filenames: [
        ".irbrc",
        ".pryrc",
        "Appraisals",
        "Berksfile",
        "Brewfile",
        "Buildfile",
        "Capfile",
        "Dangerfile",
        "Deliverfile",
        "Fastfile",
        "Gemfile",
        "Gemfile.lock",
        "Guardfile",
        "Jarfile",
        "Mavenfile",
        "Podfile",
        "Puppetfile",
        "Rakefile",
        "Snapfile",
        "Thorfile",
        "Vagrantfile",
        "buildfile",
      ],
      language_id: 326,
    },
    id: "5Gxr",
  },
  {
    name: "Rust",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Rust_programming_language_black_logo.svg/220px-Rust_programming_language_black_logo.svg.png",
    description:
      'Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references. Rust achieves memory safety without garbage collection, and reference counting is optional. Rust has been called a systems programming language and in addition to high-level features such as functional programming it also offers mechanisms for low-level memory management. First appearing in 2010, Rust was designed by Graydon Hoare at Mozilla Research, with contributions from Dave Herman, Brendan Eich, and others. The designers refined the language while writing the Servo experimental browser engine and the Rust compiler. Rust\'s major influences include C++, OCaml, Haskell, and Erlang. It has gained increasing use and investment in industry, by companies including Amazon, Discord, Dropbox, Facebook, Google, and Microsoft. Rust has been voted the "most loved programming language" in the Stack Overflow Developer Survey every year since 2016, and was used by 7% of the respondents in 2021. The language grew out of a personal project begun in 2006 by Mozilla employee Graydon Hoare. Hoare has stated that the project was possibly named after rust fungi and that the name is also a substring of "robust". Mozilla began sponsoring the project in 2009 and announced it in 2010. The same year, work shifted from the initial compiler (written in OCaml) to an LLVM-based self-hosting compiler written in Rust. Named rustc, it successfully compiled itself in 2011.',
    Paradigms:
      "Multi-paradigm: concurrent, functional, generic, imperative, structured",
    "Designed by": "Graydon Hoare",
    Developer: "The Rust Foundation",
    "First appeared": "July 7, 2010; 11 years ago",
    "Stable release": "1.58.0  / January 13, 2022; 2 days ago",
    "Typing discipline": "Affine, inferred, nominal, static, strong",
    "Implementation language": "Rust",
    Platform:
      "AMD64 , i686, arm, AArch64, armv7, mips, mips64, mipsel, mips64el, powerpc, powerpc64, powerpc64le, risc-v, s390x, WebAssembly[note 1]",
    OS: "Windows, Linux, macOS, FreeBSD, NetBSD, Illumos, Haiku, Android, Redox, iOS, Fuchsia[note 2]",
    License: "MIT or Apache 2.0",
    "Filename extensions": ".rs, .rlib",
    Website: "foundation.rust-lang.org",
    Formation: "February 8, 2021; 11 months ago",
    Founders: "Amazon Web Services Google Huawei Microsoft Mozilla Foundation",
    Type: "Nonprofit organization",
    Location: "United States",
    Chairperson: "Shane Miller",
    "Executive Director": "Rebecca Rumbul",
    other_details: {
      type: "programming",
      color: "#dea584",
      extensions: [".rs", ".rs.in"],
      ace_mode: "rust",
      codemirror_mode: "rust",
      codemirror_mime_type: "text/x-rustsrc",
      language_id: 327,
    },
    id: "C5kh",
  },
  {
    name: "S",
    description:
      "The modern implementation of S is R, a part of the GNU free software project. S-PLUS, a commercial product, was formerly sold by TIBCO Software.[citation needed] S is one of several statistical computing languages that were designed at Bell Laboratories, and first took form between 1975–1976. Up to that time, much of the statistical computing was done by directly calling Fortran subroutines; however, S was designed to offer an alternate and more interactive approach. Early design decisions that hold even today include interactive graphics devices (printers and character terminals at the time), and providing easily accessible documentation for the functions. The first working version of S was built in 1976, and operated on the GCOS operating system. At this time, S was unnamed, and suggestions included ISCS (Interactive SCS), SCS (Statistical Computing System), and SAS (Statistical Analysis System) (which was already taken: see SAS System). The name 'S' (used with single quotation marks until 1979) was chosen, as it was a common letter in the suggestions and consistent with other programming languages designed from the same institution at the time (namely the C programming language). When UNIX/32V was ported to the (then new) 32-bit DEC VAX, computing on the Unix platform became feasible for S. In late 1979, S was ported from GCOS to UNIX, which would become the new primary platform.",
    Paradigm: "multi-paradigm: imperative, object oriented",
    Developer: "Rick Becker, Allan Wilks, John Chambers",
    "First appeared": "1976; 46 years ago",
    "Typing discipline": "dynamic, strong",
    License: "depends on implementation",
    Website:
      "ect.bell-labs.com/sl/S/ at the Wayback Machine (archived 2018-10-14)",
    id: "b22p",
  },
  {
    name: "S2",
    description:
      "The S2 system is, at its heart, completely general and can be used for almost any web application; however there exists no documentation for the implementation of S2 within other applications, which ties it relatively closely to LiveJournal. This article will make use of LiveJournal's implementation of S2 for examples. A link to detailed documentation about this implementation can be found at the bottom. S2's structure closely resembles that of most imperative programming languages, and includes basic instructions such as variable assignments, arithmetic operations, conditional flow control and for loops over finite sets (however, it distinctly lacks while loops). Being object-oriented, S2 allows the declaration of classes with members and methods, but global (non-class-specific) functions can also be defined. Recursion is allowed, but nesting functions is not. A distinguishing feature of S2 is that source code is organised into individual layers, of which there are six different types (core, i18nc, layout, i18n, theme and user). These layers form a tree-like structure.",
    Paradigm: "Object-oriented",
    Developer: "Brad Fitzpatrick, Martin Atkins",
    "First appeared": "1999",
    Website: "www.livejournal.com/doc/s2",
    id: "tS-6",
  },
  {
    name: "S3",
    description:
      'A rare example of an S3 program available in the public domain is the implementation of Kermit developed at the South-West Universities Regional Computer Centre, and archived in the Columbia University archive of Kermit implementations. The examples below are selected highlights of the main module (kmt_main_module). The program starts with a module identification, and comments which we quote by way of acknowledgment to the authors: Next follow a number of "mode declarations". Mode is the Algol 68 term for a type. The first type is an array of 96 bytes; the next two are references (pointers) to arrays of bytes. KMT_MTM_VALUES is a union type allowing a variety of different types to appear. Note that WORD is a 32-bit unsigned integer, INT is a 32-bit signed integer; LONG makes it 64 bits. The last option in the union is marked REF()REF()BYTE, which means it is a pointer to an array whose members are pointers to arrays of bytes.',
    Paradigm: "Structured, imperative",
    Developer: "International Computers Limited",
    id: "4pdK",
  },
  {
    name: "S-Lang",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/JED-editor-slang-source.png/300px-JED-editor-slang-source.png",
    description:
      "The S-Lang programming library was started in 1992 by John E. Davis, considering that functions he wrote for a text editor might be useful in other programs. The earliest version of the library contained input/output routines for interacting with computer terminals and an implementation of a simple stack-based interpreter with a PostScript-like syntax that he developed for use in a scientific plotting program. The JED text editor was the first program to both embed the interpreter and use the terminal I/O components of the library. The interpreter makes up most of the S-Lang library, and is also where most of the development takes place. Although the original syntax supported by the interpreter resembled PostScript, the syntax has evolved to be much more C-like, with additional support for object-oriented style constructs. As a reflection of Davis's background in physics and professional interest in scientific computing, the language natively supports many vectorized array-based operations similar to MATLAB and IDL. Until version 2.0, the interpreter was not a standalone program. Instead, Davis advocated embedding it into applications to make them extensible. Using the interpreter meant either embedding it in a C program, or using it in the context of another application (e.g., the JED editor). The S-Lang shell, slsh, was a demonstration program capable of little more than running scripts. Version 2.0, released in 2005, made slsh interactive, and it has evolved into an application in its own right, with a number of external modules for use by it. As such, it has become the S-Lang interpreter. In the mid-1990s while porting the sc spreadsheet to the S-Lang library, Davis developed the library's screen management facility.[citation needed] This component was designed to optimize screen output (by minimizing the number of characters sent to the terminal), and provide a simple way to support a variety of terminals through an extra layer of abstraction between the application code and the terminal. The slrn newsreader was the first application to make full use of this interface.[citation needed] Since then, a number of other programs (e.g., Mutt) have taken advantage of this feature of the library, and it has become arguably the most used aspect of the library, as this component is considered to be an alternative to curses. Since version 2.0, the screen management routines have had transparent support for UTF-8.",
    "Developer(s)": "John E. Davis",
    "Stable release": "2.3.2 / 4 March 2018",
    "Written in": "S-Lang scripting language",
    "Operating system": "POSIX",
    Type: "Widget toolkit",
    License: "GPL",
    Website: "www.jedsoft.org/slang/ ",
    id: "GCrB",
  },
  {
    name: "S-PLUS",
    description:
      "It features object-oriented programming capabilities and advanced analytical algorithms. Due to the increasing popularity of the open source S successor R, TIBCO Software released the TIBCO Enterprise Runtime for R (TERR) as an alternative R interpreter. 1988: S-PLUS is first produced by a Seattle-based start-up company called Statistical Sciences, Inc. The founder and sole owner is R. Douglas Martin, professor of statistics at the University of Washington, Seattle. 1993: Statistical Sciences acquires the exclusive license to distribute S and merges with MathSoft, becoming the firm's Data Analysis Products Division (DAPD).",
    "Developer(s)": "TIBCO Software Inc.",
    "Stable release": "8.2 / November 2010; 11 years ago",
    "Operating system": "Windows, Unix/Linux",
    Type: "Statistical package",
    License: "Proprietary",
    id: "xnv4",
  },
  {
    name: "SiMPLE",
    description:
      "SAIL's main feature is a symbolic data system based upon an associative store (based on the LEAP system of Jerry Feldman and Paul Rovner). Items may be stored as unordered sets or as associations (triples). Other features include processes, events and interrupts, contexts, backtracking and record garbage collection. It also has block-structured macros, a coroutining facility and some new data types intended for building search trees and association lists. A number of interesting software systems were coded in SAIL, including some early versions of FTP and TeX, a document formatting system called PUB, and BRIGHT, a clinical database project sponsored by the National Institutes of Health. In 1978, there were half a dozen different operating systems for the PDP-10: ITS (MIT), WAITS (Stanford), TOPS-10 (DEC), CMU TOPS-10 (Carnegie Mellon), TENEX (BBN), Tymcom-X (Tymshare), and TOPS-20 (DEC, based on TENEX). SAIL was ported from WAITS to ITS so that MIT researchers could make use of software developed at Stanford University. Every port usually required the rewriting of I/O code in each application.",
    id: "pDBq",
  },
  {
    name: "SAS",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/%E0%A6%B8%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%B8_%E0%A6%B2%E0%A7%8B%E0%A6%97%E0%A7%8B.png/148px-%E0%A6%B8%E0%A7%8D%E0%A6%AF%E0%A6%BE%E0%A6%B8_%E0%A6%B2%E0%A7%8B%E0%A6%97%E0%A7%8B.png",
    description:
      'SAS was developed at North Carolina State University from 1966 until 1976, when SAS Institute was incorporated. SAS was further developed in the 1980s and 1990s with the addition of new statistical procedures, additional components and the introduction of JMP. A point-and-click interface was added in version 9 in 2004. A social media analytics product was added in 2010. SAS is a software suite that can mine, alter, manage and retrieve data from a variety of sources and perform statistical analysis on it. SAS provides a graphical point-and-click user interface for non-technical users and more through the SAS language. SAS programs have DATA steps, which retrieve and manipulate data, and PROC steps, which analyze the data. Each step consists of a series of statements. The DATA step has executable statements that result in the software taking an action, and declarative statements that provide instructions to read a data set or alter the data\'s appearance. The DATA step has two phases: compilation and execution. In the compilation phase, declarative statements are processed and syntax errors are identified. Afterwards, the execution phase processes each executable statement sequentially. Data sets are organized into tables with rows called "observations" and columns called "variables". Additionally, each piece of data has a descriptor and a value.',
    "Developer(s)": "SAS Institute",
    "Initial release": "1976; 46 years ago",
    "Stable release": "9.4M7 / August 18, 2020; 16 months ago",
    "Written in": "C",
    "Operating system": "Windows, IBM mainframe, Unix/Linux, OpenVMS Alpha",
    Type: "Numerical analysis",
    License: "Proprietary",
    Website: "www.sas.com/en_us/home.html",
    other_details: {
      type: "programming",
      color: "#B34936",
      extensions: [".sas"],
      tm_scope: "source.sas",
      ace_mode: "text",
      codemirror_mode: "sas",
      codemirror_mime_type: "text/x-sas",
      language_id: 328,
    },
    id: "8Z_R",
  },
  {
    name: "Sather",
    description:
      "Sather is an object-oriented programming language. It originated circa 1990 at the International Computer Science Institute (ICSI) at the University of California, Berkeley, developed by an international team led by Steve Omohundro. It supports garbage collection and generics by subtypes. Originally, it was based on Eiffel, but it has diverged, and now includes several functional programming features. The name is inspired by Eiffel; the Sather Tower is a recognizable landmark at Berkeley, named after Jane Krom Sather, the widow of Peder Sather, who donated large sums to the foundation of the university. Sather also takes inspiration from other programming languages and paradigms: iterators, design by contract, abstract classes, multiple inheritance, anonymous functions, operator overloading, contravariant type system.",
    Paradigm: "object-oriented, functional",
    "Designed by": "Steve Omohundro",
    Developer:
      "University of California, Berkeley, University of Waikato, GNU project",
    "First appeared": "1990",
    "Stable release": "1.2.3 / 7 July 2007; 14 years ago",
    "Typing discipline": "static, strong",
    Website: "www.gnu.org/software/sather/",
    id: "U4zE",
  },
  {
    name: "Sawzall",
    description:
      "Google's server logs are stored as large collections of records (Protocol Buffers) that are partitioned over many disks within GFS. In order to perform calculations involving the logs, engineers can write MapReduce programs in C++ or Java. MapReduce programs need to be compiled and may be more verbose than necessary, so writing a program to analyze the logs can be time-consuming. To make it easier to write quick scripts, Rob Pike et al. developed the Sawzall language. A Sawzall script runs within the Map phase of a MapReduce and \"emits\" values to tables. Then the Reduce phase (which the script writer does not have to be concerned about) aggregates the tables from multiple runs into a single set of tables. Currently, only the language runtime (which runs a Sawzall script once over a single input) has been open-sourced; the supporting program built on MapReduce has not been released. Some interesting features include: Sawzall's design favors efficiency and engine simplicity over power:",
    Developer: "Google",
    "First appeared": "2003; 19 years ago",
    License: "Apache License 2.0",
    Website: "code.google.com/archive/p/szl/",
    id: "B16z",
  },
  {
    name: "Scala",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Scala-full-color.svg/220px-Scala-full-color.svg.png",
    description:
      "Scala source code can be compiled to Java bytecode and run on a Java virtual machine (JVM). Scala provides language interoperability with Java so that libraries written in either language may be referenced directly in Scala or Java code. Like Java, Scala is object-oriented, and uses a syntax termed curly-brace which is similar to the language C. Since Scala 3, there is also an option to use the off-side rule (indenting) to structure blocks, and its use is advised. Martin Odersky has said that this turned out to be the most productive change introduced in Scala 3. Unlike Java, Scala has many features of functional programming languages like Scheme, Standard ML, and Haskell, including currying, immutability, lazy evaluation, and pattern matching. It also has an advanced type system supporting algebraic data types, covariance and contravariance, higher-order types (but not higher-rank types), and anonymous types. Other features of Scala not present in Java include operator overloading, optional parameters, named parameters, and raw strings. Conversely, a feature of Java not in Scala is checked exceptions, which has proved controversial. The name Scala is a portmanteau of scalable and language, signifying that it is designed to grow with the demands of its users. The design of Scala started in 2001 at the École Polytechnique Fédérale de Lausanne (EPFL) (in Lausanne, Switzerland) by Martin Odersky. It followed on from work on Funnel, a programming language combining ideas from functional programming and Petri nets. Odersky formerly worked on Generic Java, and javac, Sun's Java compiler.",
    Paradigm:
      "Multi-paradigm: concurrent, functional, imperative, object-oriented",
    "Designed by": "Martin Odersky",
    Developer:
      "Programming Methods Laboratory of École Polytechnique Fédérale de Lausanne",
    "First appeared": "20 January 2004; 17 years ago",
    "Stable release": "3.1.0  / 18 October 2021; 2 months ago",
    "Preview release": "3.1.1-RC1  / 18 October 2021; 2 months ago",
    "Typing discipline": "Inferred, static, strong, structural",
    "Implementation language": "Scala",
    Platform:
      "Java virtual machine (JVM) JavaScript (Scala.js) LLVM (Scala Native) (experimental)",
    License: "Apache 2.0",
    "Filename extensions": ".scala, .sc",
    Website: "www.scala-lang.org",
    other_details: {
      type: "programming",
      ace_mode: "scala",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-scala",
      color: "#c22d40",
      extensions: [".scala", ".kojo", ".sbt", ".sc"],
      interpreters: ["scala"],
      language_id: 341,
    },
    id: "Kn5e",
  },
  {
    name: "Scheme",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Lambda_lc.svg/121px-Lambda_lc.svg.png",
    description:
      'Scheme was created during the 1970s at the MIT AI Lab and released by its developers, Guy L. Steele and Gerald Jay Sussman, via a series of memos now known as the Lambda Papers. It was the first dialect of Lisp to choose lexical scope and the first to require implementations to perform tail-call optimization, giving stronger support for functional programming and associated techniques such as recursive algorithms. It was also one of the first programming languages to support first-class continuations. It had a significant influence on the effort that led to the development of Common Lisp. The Scheme language is standardized in the official IEEE standard and a de facto standard called the Revisedn Report on the Algorithmic Language Scheme (RnRS). The most widely implemented standard is R5RS (1998). The most recent standard, R7RS, provides "small" and "large" versions of the Scheme language; the "small" language standard was ratified in 2013. Scheme has a diverse user base due to its compactness and elegance, but its minimalist philosophy has also caused wide divergence between practical implementations, so much that the Scheme Steering Committee calls it "the world\'s most unportable programming language" and "a family of dialects" rather than a single language. Scheme started in the 1970s as an attempt to understand Carl Hewitt\'s Actor model, for which purpose Steele and Sussman wrote a "tiny Lisp interpreter" using Maclisp and then "added mechanisms for creating actors and sending messages". Scheme was originally called "Schemer", in the tradition of other Lisp-derived languages such as Planner or Conniver. The current name resulted from the authors\' use of the ITS operating system, which limited filenames to two components of at most six characters each. Currently, "Schemer" is commonly used to refer to a Scheme programmer. A new language standardization process began at the 2003 Scheme workshop, with the goal of producing an R6RS standard in 2006. This process broke with the earlier RnRS approach of unanimity.',
    Paradigms: "Multi-paradigm: functional, imperative, meta",
    Family: "Lisp",
    "Designed by": "Guy L. Steele Gerald Jay Sussman",
    "First appeared": "1975; 47 years ago",
    "Stable release": "R7RS / 2013; 9 years ago",
    "Typing discipline": "Dynamic, latent, strong",
    Scope: "Lexical",
    "Filename extensions": ".scm, .ss",
    Website: "www.scheme-reports.org",
    other_details: {
      type: "programming",
      color: "#1e4aec",
      extensions: [".scm", ".sch", ".sld", ".sls", ".sps", ".ss"],
      interpreters: [
        "scheme",
        "guile",
        "bigloo",
        "chicken",
        "csi",
        "gosh",
        "r6rs",
      ],
      ace_mode: "scheme",
      codemirror_mode: "scheme",
      codemirror_mime_type: "text/x-scheme",
      language_id: 343,
    },
    id: "nNZ7",
  },
  {
    name: "Scilab",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Scilab_Logo.png/90px-Scilab_Logo.png",
    description:
      "Scilab is one of the two major open-source alternatives to MATLAB, the other one being GNU Octave. Scilab puts less emphasis on syntactic compatibility with MATLAB than Octave does, but it is similar enough that some authors suggest that it is easy to transfer skills between the two systems. Scilab is a high-level, numerically oriented programming language. The language provides an interpreted programming environment, with matrices as the main data type. By using matrix-based computation, dynamic typing, and automatic memory management, many numerical problems may be expressed in a reduced number of code lines, as compared to similar solutions using traditional languages, such as Fortran, C, or C++. This allows users to rapidly construct models for a range of mathematical problems. While the language provides simple matrix operations such as multiplication, the Scilab package also provides a library of high-level operations such as correlation and complex multidimensional arithmetic. Scilab also includes a free package called Xcos for modeling and simulation of explicit and implicit dynamical systems, including both continuous and discrete sub-systems. Xcos is the open source equivalent to Simulink from the MathWorks. As the syntax of Scilab is similar to MATLAB, Scilab includes a source code translator for assisting the conversion of code from MATLAB to Scilab. Scilab is available free of cost under an open source license. Due to the open source nature of the software, some user contributions have been integrated into the main program.",
    "Developer(s)": "ESI Group",
    "Stable release": "6.1.1 / 16 July 2021; 5 months ago",
    Repository: "git.scilab.org/scilab ",
    "Written in": "Scilab, C, C++, Java, Fortran",
    "Operating system": "BSDs (e.g., FreeBSD), Linux, macOS, Windows",
    "Available in":
      "English, German, Spanish, French, Italian, Japanese, Portuguese (Brazil), Russian, Ukrainian, Chinese, Czech, Polish",
    Type: "Technical computing",
    License: "GPLv2, previously CeCILL",
    Website: "www.scilab.org",
    other_details: {
      type: "programming",
      extensions: [".sci", ".sce", ".tst"],
      ace_mode: "text",
      language_id: 344,
    },
    id: "ysDa",
  },
  {
    name: "Scratch",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Scratchlogo.svg/172px-Scratchlogo.svg.png",
    description:
      'Scratch is a high-level block-based visual programming language and website targeted primarily at children 8–16 as an educational tool for programming. Users on the site, called Scratchers, can create projects on the website using a block-like interface. Projects can be exported to HTML5, Android apps and EXE files using external tools. The service is developed by the MIT Media Lab, has been translated into 70+ languages, and is used in most parts of the world. Scratch is taught and used in after-school centers, schools, and colleges, as well as other public knowledge institutions. As of December 2021, community statistics on the language\'s official website show more than 92 million projects shared by over 82 million users, and more than 98 million monthly website visits. Scratch takes its name from a technique used by disk jockeys called "scratching", where vinyl records are clipped together and manipulated on a turntable to produce different sound effects and music. Like scratching, the website lets users mix together different media (including graphics, sound, and other programs) in creative ways by creating and \'remixing\' projects, like video games, animations, and simulations. The Scratch interface is divided into three main sections: a stage area, block palette, and a coding area to place and arrange the blocks into scripts that can be run by pressing the green flag or clicking on the code itself. Users may also create their own code blocks and they will appear in "My Blocks". The stage area features the results (e.g., animations, turtle graphics, either in a small or normal size, with a full-screen option also available) and all sprites thumbnails being listed in the bottom area. The stage uses x and y coordinates, with 0,0 being the stage center.',
    Paradigm: "Event-driven, block-based programming language",
    "First appeared":
      "2003 (first prototype) 2004 (second prototype) 15 May 2007; 14 years ago (public launch) 9 May 2013; 8 years ago (Scratch 2.0) 2 January 2019; 3 years ago (Scratch 3.0)",
    "Implementation language":
      "Squeak (Scratch 0.x, 1.x) ActionScript (Scratch 2.0) JavaScript (Scratch 3.0)",
    OS: "Microsoft Windows, macOS, Linux (via renderer), HTML5, iOS, iPadOS, and Android.",
    License: "GPLv2 and Scratch Source Code License",
    "Filename extensions":
      ".scratch (Scratch 0.x) *.sb, *.sprite (Scratch 1.x) *.sb2, *.sprite2 (Scratch 2.0) *.sb3, *.sprite3 (Scratch 3.0)",
    Website: "scratch.mit.edu Official Wiki: scratch-wiki.info",
    id: "TKr3",
  },
  {
    name: "Script.NET",
    description:
      "Script.NET is an open-source project. Script.NET has a special quotation operator <[ program ]> which returns the AST of a given program. Additionally, the AST of the current program may be accessed with the prog object. Here is an example: The <[ ... ]> operator and prog objects allow Script.NET to generate new scripts or modify existing scripts at runtime.",
    Paradigm: "imperative, meta, scripting",
    Developer: "Microsoft",
    "Typing discipline": "dynamic",
    Platform: ".NET Framework",
    License: "Free",
    Website: "www.protsyk.com/scriptdotnet",
    id: "rMCn",
  },
  {
    name: "sed",
    description:
      'First appearing in Version 7 Unix, sed is one of the early Unix commands built for command line processing of data files. It evolved as the natural successor to the popular grep command. The original motivation was an analogue of grep (g/re/p) for substitution, hence "g/re/s". Foreseeing that further special-purpose programs for each command would also arise, such as g/re/d, McMahon wrote a general-purpose line-oriented stream editor, which became sed. The syntax for sed, notably the use of / for pattern matching, and s/// for substitution, originated with ed, the precursor to sed, which was in common use at the time, and the regular expression syntax has influenced other languages, notably ECMAScript and Perl. Later, the more powerful language AWK developed, and these functioned as cousins, allowing powerful text processing to be done by shell scripts. sed and AWK are often cited as progenitors and inspiration for Perl, and influenced Perl\'s syntax and semantics, notably in the matching and substitution operators. GNU sed added several new features, including in-place editing of files. Super-sed is an extended version of sed that includes regular expressions compatible with Perl. Another variant of sed is minised, originally reverse-engineered from 4.1BSD sed by Eric S. Raymond and currently maintained by René Rebe. minised was used by the GNU Project until the GNU Project wrote a new version of sed based on the new GNU regular expression library. The current minised contains some extensions to BSD sed but is not as feature-rich as GNU sed. Its advantage is that it is very fast and uses little memory.[citation needed] It is used on embedded systems and is the version of sed provided with Minix.[citation needed] sed is a line-oriented text processing utility: it reads text, line by line, from an input stream or file, into an internal buffer called the pattern space. Each line read starts a cycle. To the pattern space, sed applies one or more operations which have been specified via a sed script. sed implements a programming language with about 25 commands that specify the operations on the text. For each input line, after running the script, sed ordinarily outputs the pattern space (the line as modified by the script) and begins the cycle again with the next line. Other end-of-script behaviors are available through sed options and script commands, e.g. d to delete the pattern space, q to quit, N to add the next line to the pattern space immediately, and so on. Thus a sed script corresponds to the body of a loop that iterates through the lines of a stream, where the loop itself and the loop variable (the current line number) are implicit and maintained by sed. The sed script can either be specified on the command line (-e option) or read from a separate file (-f option). Commands in the sed script may take an optional address, in terms of line numbers or regular expressions. The address determines when the command is run. For example, 2d would only run the d (delete) command on the second input line (printing all lines but the second), while /^ /d would delete all lines beginning with a space. A separate special buffer, the hold space, may be used by a few sed commands to hold and accumulate text between cycles. sed\'s command language has only two variables (the "hold space" and the "pattern space") and GOTO-like branching functionality; nevertheless, the language is Turing-complete, and esoteric sed scripts exist for games such as sokoban, arkanoid, chess, and tetris.',
    Paradigm: "scripting",
    "Designed by": "Lee E. McMahon",
    "First appeared": "1974; 48 years ago",
    "Implementation language": "C",
    Website: "www.gnu.org/software/sed/",
    other_details: {
      type: "programming",
      color: "#64b970",
      extensions: [".sed"],
      interpreters: ["gsed", "minised", "sed", "ssed"],
      ace_mode: "text",
      tm_scope: "source.sed",
      language_id: 847830017,
    },
    id: "ArzJ",
  },
  {
    name: "Seed7",
    description:
      "Seed7 supports the programming paradigms: imperative, object-oriented (OO), and generic. It also supports features such as call by name, multiple dispatch, function overloading, operator overloading, exception handling and arbitrary-precision arithmetic. Major features include: Several programming language concepts are generalized: The Seed7 project includes both an interpreter and a compiler. The interpreter starts programs very quickly, supporting fast program development. The compiler uses the parser and reflection interfaces from the run-time library to generate a C program, which is subsequently compiled to machine code. Compiled Seed7 programs can have comparable performance to C programs.",
    Paradigm:
      "multi-paradigm: extensible, object-oriented, imperative, structured, generic, reflective",
    "Designed by": "Thomas Mertes",
    "First appeared": "2005; 17 years ago",
    "Stable release": "2021-08-07 / 163 days ago",
    "Typing discipline": "static, strong, safe, nominative, manifest",
    OS: "Cross-platform: BSD, Linux, OS X, Unix, Windows",
    License: "GPL, LGPL (for the runtime library)",
    "Filename extensions": ".sd7, .s7i",
    Website: "seed7.sourceforge.net",
    id: "5EdS",
  },
  {
    name: "Self",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Self-logo.svg/200px-Self-logo.svg.png",
    description:
      "Several just-in-time compilation techniques were pioneered and improved in Self research as they were required to allow a very high level object oriented language to perform at up to half the speed of optimized C. Much of the development of Self took place at Sun Microsystems, and the techniques they developed were later deployed for Java's HotSpot virtual machine. At one point a version of Smalltalk was implemented in Self. Because it was able to use the JIT, this also gave extremely good performance. Self was designed mostly by David Ungar and Randall Smith in 1986 while working at Xerox PARC. Their objective was to push forward the state of the art in object-oriented programming language research, once Smalltalk-80 was released by the labs and began to be taken seriously by the industry. They moved to Stanford University and continued work on the language, building the first working Self compiler in 1987. At that point, focus changed to attempting to bring up an entire system for Self, as opposed to just the language. The first public release was in 1990, and the next year the team moved to Sun Microsystems where they continued work on the language. Several new releases followed until falling largely dormant in 1995 with the 4.0 version. The 4.3 version was released in 2006 and ran on Mac OS X and Solaris. A new release in 2010, version 4.4, has been developed by a group comprising some of the original team and independent programmers and is available for Mac OS X and Linux, as are all following versions. The follow-up 4.5 was released in January 2014, and three years later, version 2017.1 was released in May 2017.",
    Paradigm: "object-oriented (prototype-based)",
    "Designed by": "David Ungar, Randall Smith",
    Developer:
      "David Ungar, Randall Smith, Stanford University, Sun Microsystems",
    "First appeared": "1987; 35 years ago",
    "Stable release": "Mandarin 2017.1 / May 24, 2017; 4 years ago",
    "Typing discipline": "dynamic, strong",
    License: "BSD-like license",
    Website: "www.selflanguage.org",
    other_details: {
      type: "programming",
      color: "#0579aa",
      extensions: [".self"],
      tm_scope: "none",
      ace_mode: "text",
      language_id: 345,
    },
    id: "NoAR",
  },
  {
    name: "SenseTalk",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/9/9c/ST-HelloWorld2.png/250px-ST-HelloWorld2.png",
    description:
      "To this end, SenseTalk includes a number of language elements that provide functionality oriented towards human tasks rather than the underlying machine behavior. For example, to check whether a quantity is divisible by 3, the script could use the expression “if quantity is divisible by 3 …” or “if quantity is a multiple of 3 …”, with the emphasis being on readability and a focus on the human concept of divisibility.  Compare this to more traditional programming languages (C, Java, Python, etc.) where the same test would typically be written as “if (quantity % 3) == 0 …” , with the focus being on the machine operations needed to determine the result.  This shift in focus away from the underlying machine computation, towards an English-like description of the behavior in human terms leads to the description of SenseTalk as a “People Oriented Programming language”.  As a self-styled “People Oriented Programming” language, certain aspects of SenseTalk’s design distinguish it from other programming languages, and give it a distinctive flavor. These range from mundane characteristics such as case insensitivity, to syntactic elements that enhance readability, to more subtle characteristics such as fluid variable types. SenseTalk keywords and variable names are all case-insensitive. This allows people to be casual in their use of capitalization without any change of behavior.",
    Paradigm: "People Oriented Programming, Multi-paradigm, Object-oriented",
    Family: "Scripting language",
    "Designed by": "Douglas Simons",
    Developer: "Eggplant (software)",
    "First appeared": "1992; 30 years ago",
    "Stable release": "2.07 / November 2021; 2 months ago",
    "Typing discipline": "Duck",
    License: "Proprietary",
    "Filename extensions": ".script.st",
    Website: "www.sensetalk.com",
    id: "MR_6",
  },
  {
    name: "SequenceL",
    description:
      'Programs written in SequenceL can be compiled to multithreaded code that runs in parallel, with no explicit indications from a programmer of how or what to parallelize. As of 2015, versions of the SequenceL compiler generate parallel code in C++ and OpenCL, which allows it to work with most popular programming languages, including C, C++, C#, Fortran, Java, and Python. A platform-specific runtime manages the threads safely, automatically providing parallel performance according to the number of cores available, currently supporting x86, POWER8, and ARM platforms. SequenceL was initially developed over a 20-year period starting in 1989, mostly at Texas Tech University. Primary funding was from NASA, which originally wanted to develop a specification language which was "self-verifying"; that is, once written, the requirements could be executed, and the results verified against the desired outcome. The principal researcher on the project was initially Dr. Daniel Cooke, who was soon joined by Dr. Nelson Rushton (another Texas Tech professor) and later Dr. Brad Nemanich (then a PhD student under Cooke). The goal of creating a language that was simple enough to be readable, but unambiguous enough to be executable, drove the inventors to settle on a functional, declarative language approach, where a programmer describes desired results, rather than the means to achieve them. The language is then free to solve the problem in the most efficient manner that it can find. As the language evolved, the researchers developed new computational approaches, including consume-simplify-produce (CSP). In 1998, research began to apply SequenceL to parallel computing. This culminated in 2004 when it took its more complete form with the addition of the normalize-transpose (NT) semantic, which coincided with the major vendors of central processing units (CPUs) making a major shift to multi-core processors rather than continuing to increase clock speeds. NT is the semantic work-horse, being used to simplify and decompose structures, based on a dataflow-like execution strategy similar to GAMMA and NESL. The NT semantic achieves a goal similar to that of the Lämmel and Peyton-Jones’ boilerplate elimination. All other features of the language are definable from these two laws - including recursion, subscripting structures, function references, and evaluation of function bodies.',
    Paradigms:
      "Parallel computing, Functional, Purely functional, Declarative programming",
    "Designed by": "Dr. Daniel Cooke, Dr. Nelson Rushton, Dr. Brad Nemanich",
    Developers: "Texas Tech University, Texas Multicore Technologies",
    "First appeared": "1989; 33 years ago",
    "Typing discipline": "Static, type inference",
    Platform: "x86, Power, ARM",
    OS: "Windows, macOS, Linux",
    License: "Proprietary",
    Website: "texasmulticore.com[dead link]",
    id: "idRi",
  },
  {
    name: "Ethereum",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Ethereum-icon-purple.svg/220px-Ethereum-icon-purple.svg.png",
    description:
      "Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether (ETH or Ξ) is the native cryptocurrency of the platform. Amongst cryptocurrencies, Ether is second only to Bitcoin in market capitalization. Ethereum was conceived in 2013 by programmer Vitalik Buterin. Additional founders of Ethereum included Gavin Wood, Charles Hoskinson, Anthony Di Iorio and Joseph Lubin. In 2014, development work commenced and was crowdfunded, and the network went live on 30 July 2015. The platform allows anyone to deploy permanent and immutable decentralized applications onto it, with which users can interact. Decentralized finance (DeFi) applications provide a broad array of financial services without the need for typical financial intermediaries like brokerages, exchanges, or banks, such as allowing cryptocurrency users to borrow against their holdings or lend them out for interest. Ethereum also allows for the creation and exchange of NFTs, which are non-interchangeable tokens connected to digital works of art or other real-world items and sold as unique digital property. Additionally, many other cryptocurrencies operate as ERC-20 tokens on top of the Ethereum blockchain and have utilized the platform for initial coin offerings. Ethereum has started implementing a series of upgrades called Ethereum 2.0, which includes a transition to proof of stake and aims to increase transaction throughput using sharding. Ethereum was initially described in a white paper by Vitalik Buterin, a programmer and co-founder of Bitcoin Magazine, in late 2013 with a goal of building decentralized applications. Buterin argued to the bitcoin core developers that Bitcoin and blockchain technology could benefit from other applications besides money and needed a more robust language for application development that could lead to attaching real-world assets, such as stocks and property, to the blockchain. In 2013, Buterin briefly worked with eToro CEO Yoni Assia on the Colored Coins project and drafted its white paper outlining additional use cases for blockchain technology. However, after failing to gain agreement on how the project should proceed, he proposed the development of a new platform with a more robust scripting language—a Turing-complete programming language—that would eventually become Ethereum.",
    "Original author(s)": "Vitalik Buterin Gavin Wood",
    "Developer(s)":
      "Ethereum Foundation, Hyperledger, Nethermind, OpenEthereum, EthereumJS",
    "Initial release": "30 July 2015; 6 years ago",
    "Stable release": "London / 5 August 2021; 5 months ago",
    "Development status": "Active",
    "Software used": "EVM 1 Bytecode",
    "Written in": "Go, Rust, C#, C++, Java, Python",
    "Operating system": "Cross-platform",
    Platform: "x86-64, ARM",
    Size: "991.56 GB (2021-09-30)",
    "Available in": "Multilingual, but primarily English",
    Type: "Distributed computing",
    License: "Open-source licenses",
    "Active hosts": "3,481 nodes (2021-09-30)",
    Website: "ethereum.org",
    id: "g2vo",
  },
  {
    name: "SETL",
    description:
      "SETL provides two basic aggregate data types: unordered sets, and sequences (the latter also called tuples). The elements of sets and tuples can be of any arbitrary type, including sets and tuples themselves. Maps are provided as sets of pairs (i.e., tuples of length 2) and can have arbitrary domain and range types. Primitive operations in SETL include set membership, union, intersection, and power set construction, among others. SETL provides quantified boolean expressions constructed using the universal and existential quantifiers of first-order predicate logic. SETL provides several iterators to produce a variety of loops over aggregate data structures. Print all prime numbers from 2 to N:",
    Paradigm:
      "multi-paradigm: imperative, procedural, structured, object-oriented",
    "Designed by": "(Jack) Jacob T. Schwartz",
    Developer: "Courant Institute of Mathematical Sciences",
    "First appeared": "1969; 53 years ago",
    "Stable release": "1.1 / January 7, 2005; 17 years ago",
    "Typing discipline": "Dynamic",
    Website: "setl.org",
    id: "VXK2",
  },
  {
    name: "Short Code",
    description:
      "Short Code was proposed by John Mauchly in 1949 and originally known as Brief Code. William Schmitt implemented a version of Brief Code in 1949 for the BINAC computer, though it was never debugged and tested. The following year Schmitt implemented a new version of Brief Code for the UNIVAC I, where it was now known as Short Code (also Short Order Code). A revised version of Short Code was developed in 1952 for the Univac II by A. B. Tonik and J. R. Logan. While Short Code represented expressions, the representation itself was not direct and required a process of manual conversion. Elements of an expression were represented by two-character codes and then divided into 6-code groups in order to conform to the 12-byte words used by BINAC and Univac computers. For example, the expression was converted to Short Code by a sequence of substitutions and a final regrouping: Along with basic arithmetic, Short Code allowed for branching and calls to a library of functions. The language was interpreted and ran about 50 times slower than machine code.",
    Developer: "William F Schmitt, A. B. Tonik, J. R. Logan",
    "First appeared": "1950",
    id: "Tm2j",
  },
  {
    name: "Superbase",
    description:
      'It was originally created in 1983 by Precision Software for the Commodore 64 and 128 and later the Amiga and Atari ST. In 1989, it was the first database management system to run on a Windows computer. Precision Software, a UK-based company, was the original creator of the product Superbase. Superbase was and still is used by a large number of people on various platforms. It was often used only as an end-user database but a very large number of applications were built throughout industry, government, and academia and these were often of significant complexity. Some of these applications continue in use to the current day, mostly in small businesses. The initial versions were text mode only, but with the release of the Amiga version, Superbase became the first product to use the now common VCR control panel for browsing through records.[citation needed] It also supported a number of different media formats, including images, sounds, and video. Superbase was often referred to as the multimedia database in early years, when such features were uncommon. The Amiga version also featured an internal language and the capability to generate front end "masks" for queries and reports, years before Microsoft Access. This version was a huge success and that resulted in a version being created for a number of platforms using the same approach. Eventually a Microsoft Windows version was released and a couple of years later the company was sold by its founders to Software Publishing Corporation. SPC sold off the non-Windows versions of the product and after releasing version 2 and in the late alpha stages of version 3, sold the product to a company called Computer Concepts Corporation.',
    "Original author(s)": "Precision Software",
    "Developer(s)": "Superbase Software Ltd",
    "Initial release": "1983; 39 years ago",
    "Operating system": "Cross-platform",
    Type: "Database software",
    Website: "www.superbase.com",
    id: "uoyR",
  },
  {
    name: "SPIN",
    description:
      "The SIGNAL formal model provides the capability to describe systems with several clocks (polychronous systems) as relational specifications. Relations are useful as partial specifications and as specifications of non-deterministic devices (for instance a non-deterministic bus) or external processes (for instance an unsafe car driver). Using SIGNAL allows one to specify an application, to design an architecture, to refine detailed components down to RTOS[clarification needed] or hardware description. The SIGNAL model supports a design methodology which goes from specification to implementation, from abstraction to concretization, from synchrony to asynchrony. SIGNAL has been mainly developed in INRIAEspresso team since the 1980s, at the same time as similar programming languages, Esterel and Lustre. The SIGNAL language was first designed for signal processing applications in the beginning of the 1980s. It has been proposed to answer the demand of new domain-specific language for the design of signal processing applications, adopting a dataflow and block-diagram style with array and sliding window operators. P. Le Guernic, A. Benveniste, and T. Gautier have been in charge of the language definition. The first paper on SIGNAL was published in 1982, while the first complete description of SIGNAL appeared in the PhD thesis of T. Gautier. The symbolic representation of SIGNAL via z/3z (over ) has been introduced in 1986. A full compiler of SIGNAL based on the clock calculus on hierarchy of Boolean clocks, was described by L. Besnard in his PhD thesis in 1992. The clock calculus has been improved later by T. Amagbegnon with the proposition of arborescent canonical forms.",
    id: "HUEO",
  },
  {
    name: "SP/k",
    description:
      'Following the death of SiMPLE creator Bob Bishop, the SiMPLE Codeworks website and forums are now offline, however they can be accessed via the internet archive archive.org. In 1995, Bob Bishop and Rich Whicker, (both former Apple Computer Engineers) decided to create a new programming language that would be easy enough for everyone to understand and use. (They felt that other existing languages such as C++ and their environments were far too complicated for beginners.) The programming language that they created was called SiMPLE. SiMPLE is vaguely reminiscent of the AppleSoft BASIC programming language that existed on the old Apple-II computers. However, SiMPLE is not (and was never intended to be) merely a "clone" of Applesoft BASIC. It was merely "inspired" by it. There are many features of Applesoft that needed to be improved. For example, Applesoft was an interpreted language, and so it ran somewhat slowly (even for a 1MHZ processor). SiMPLE, on the other hand, compiles into an executable (.EXE) file. So it not only produces programs that run faster, but those programs can even run on computers that don\'t have SiMPLE installed. Another difference between the two languages is in the use of line numbers. Applesoft required them; SiMPLE doesn\'t even use them. (Instead of typing program statements onto the black Apple screen, SiMPLE uses a text editor.) Furthermore the "FOR-NEXT" loops in Applesoft have been replaced by "Do-Loop" instructions in SiMPLE. (But they function in much the same way).',
    id: "gZsr",
  },
  {
    name: "SPS",
    description:
      "Though earlier versions were released into the public domain, SIMSCRIPT was commercialized by Markowitz's company, California Analysis Center, Inc. (CACI), which produced proprietary versions SIMSCRIPT I.5 and SIMSCRIPT II.5. SIMSCRIPT II.5 was the last pre-PC incarnation of SIMSCRIPT, one of the oldest computer simulation languages. Although military contractor CACI released it in 1971, it still enjoys wide use in large-scale military and air-traffic control simulations. SIMSCRIPT III Release 4.0 was available by 2009, and by then it ran on Windows 7, SUN OS and Linux and has Object-oriented features. By 1997, SIMSCRIPT III already had a GUI interface to its compiler. The latest version is Release 5; earlier versions already supported 64-bit processing.",
    id: "iXTQ",
  },
  {
    name: "Simula",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Simula_-_logo.svg/120px-Simula_-_logo.svg.png",
    description:
      "Simula 67 introduced objects,: 2, 5.3  classes,: 1.3.3, 2  inheritance and subclasses,: 2.2.1  virtual procedures,: 2.2.3  coroutines,: 9.2  and discrete event simulation,: 14.2  and featured garbage collection.: 9.1  Other forms of subtyping (besides inheriting subclasses) were introduced in Simula derivatives.[citation needed] Simula is considered the first object-oriented programming language. As its name suggests, the first Simula version by 1962 was designed for doing simulations; Simula 67 though was designed to be a general-purpose programming language and provided the framework for many of the features of object-oriented languages today. Simula has been used in a wide range of applications such as simulating very-large-scale integration (VLSI) designs, process modeling, communication protocols, algorithms, and other applications such as typesetting, computer graphics, and education. The influence of Simula is often understated, and Simula-type objects are reimplemented in C++, Object Pascal, Java, C#, and many other languages. Computer scientists such as Bjarne Stroustrup, creator of C++, and James Gosling, creator of Java, have acknowledged Simula as a major influence. The following account is based on Jan Rune Holmevik's historical essay.",
    Paradigms:
      "Multi-paradigm: procedural, imperative, structured, object-oriented",
    Family: "ALGOL",
    "Designed by": "Ole-Johan Dahl",
    Developer: "Kristen Nygaard",
    "First appeared": "1962; 60 years ago",
    "Stable release": "Simula 67, Simula I",
    "Typing discipline": "Static, nominative",
    Scope: "Lexical",
    "Implementation language":
      "ALGOL 60 (primarily; some components Simscript)",
    OS: "Unix-like, Windows, z/OS, TOPS-10, MVS",
    Website: "www.simula67.info",
    id: "ULka",
  },
  {
    name: "Simulink",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/3/36/Simulink_Logo_%28non-wordmark%29.png/100px-Simulink_Logo_%28non-wordmark%29.png",
    description:
      "MathWorks and other third-party hardware and software products can be used with Simulink. For example, Stateflow extends Simulink with a design environment for developing state machines and flow charts. MathWorks claims that, coupled with another of their products, Simulink can automatically generate C source code for real-time implementation of systems. As the efficiency and flexibility of the code improves, this is becoming more widely adopted for production systems, in addition to being a tool for embedded system design work because of its flexibility and capacity for quick iteration[citation needed]. Embedded Coder creates code efficient enough for use in embedded systems. Simulink Real-Time (formerly known as xPC Target), together with x86-based real-time systems, is an environment for simulating and testing Simulink and Stateflow models in real-time on the physical system. Another MathWorks product also supports specific embedded targets. When used with other generic products, Simulink and Stateflow can automatically generate synthesizable VHDL and Verilog[citation needed]. Simulink Verification and Validation enables systematic verification and validation of models through modeling style checking, requirements traceability and model coverage analysis. Simulink Design Verifier uses formal methods to identify design errors like integer overflow, division by zero and dead logic, and generates test case scenarios for model checking within the Simulink environment.",
    "Developer(s)": "MathWorks",
    "Stable release":
      "10.2 (part of R2020b) / September 17, 2020; 15 months ago",
    "Operating system": "Linux, macOS, Microsoft Windows",
    License: "Proprietary",
    Website: "mathworks.com",
    id: "EDEV",
  },
  {
    name: "SISAL",
    description:
      'SISAL was defined in 1983 by James McGraw et al., at the University of Manchester, LLNL, Colorado State University and DEC. It was revised in 1985, and the first compiled implementation was made in 1986. Its performance is superior to C and rivals Fortran, according to some sources, combined with efficient and automatic parallelization. SISAL\'s name came from grepping "sal" for "Single Assignment Language" from the Unix dictionary /usr/dict/words. Versions exist for the Cray X-MP, Y-MP, 2; Sequent, Encore Alliant, DEC VAX-11/784, dataflow architectures, KSR1, Transputers and systolic arrays. The requirements for a fine-grain parallelism language are better met with a dataflow language than a systems language.[citation needed]',
    Paradigm: "functional, dataflow",
    "Designed by": "James McGraw",
    Developer:
      "James McGraw et al., at University of Manchester, LLNL, Colorado State University, and DEC",
    "First appeared": "1983",
    "Typing discipline": "static, strong",
    id: "Atxp",
  },
  {
    name: "Squirrel",
    description:
      'In a nutshell, SLIP consisted of a set of FORTRAN "accessor" functions which operated on circular doubly linked lists with fixed-size data fields. The "accessor" functions had direct and indirect addressing variants. The list representation had four types of cell: a reader, a header, a sublist indicator, and a payload cell. The header included a reference count field for garbage collection purposes. The sublist indicator allowed it to be able to represent nested lists, such as (A, B, C, (1, 2, 3), D, E, F) where (1, 2, 3) is a sublist indicated by a cell in the \'*\' position in the list (A, B, C, *, D, E, F). The reader was essentially a state history stack—a good example of a memento pattern—where each cell pointed to the header of the list being read, the current position within the list being read, and the level or depth of the history stack.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.',
    other_details: {
      type: "programming",
      color: "#800000",
      extensions: [".nut"],
      tm_scope: "source.c++",
      ace_mode: "c_cpp",
      codemirror_mode: "clike",
      codemirror_mime_type: "text/x-c++src",
      language_id: 355,
    },
    id: "k4wd",
  },
  {
    name: "Smalltalk",
    image: "https://upload.wikimedia.org/wikipedia/en/c/c0/Smalltalk80book.jpg",
    description:
      'The language was first generally released as Smalltalk-80. Smalltalk-like languages are in active development and have gathered loyal communities of users around them. ANSI Smalltalk was ratified in 1998 and represents the standard version of Smalltalk. Smalltalk took second place for "most loved programming language" in the Stack Overflow Developer Survey in 2017, but it was not among the 26 most loved programming languages of the 2018 survey. There are a large number of Smalltalk variants. The unqualified word Smalltalk is often used to indicate the Smalltalk-80 language, the first version to be made publicly available and created in 1980. The first hardware-environments which run the Smalltalk VMs were Xerox Alto computers. Smalltalk was the product of research led by Alan Kay at Xerox Palo Alto Research Center (PARC); Alan Kay designed most of the early Smalltalk versions, Adele Goldberg wrote most of the documentation, and Dan Ingalls implemented most of the early versions. The first version, termed Smalltalk-71, was created by Kay in a few mornings on a bet that a programming language based on the idea of message passing inspired by Simula could be implemented in "a page of code". A later variant used for research work is now termed Smalltalk-72 and influenced the development of the Actor model. Its syntax and execution model were very different from modern Smalltalk variants.',
    Paradigm: "Object-oriented",
    "Designed by": "Alan Kay, Dan Ingalls, Adele Goldberg",
    Developer:
      "Alan Kay, Dan Ingalls, Adele Goldberg, Ted Kaehler, Diana Merry, Scott Wallace, Peter Deutsch and Xerox PARC",
    "First appeared": "1972; 50 years ago (development began in 1969)",
    "Stable release": "Smalltalk-80 version 2 / 1980; 42 years ago",
    "Typing discipline": "Strong, dynamic",
    Scope: "Lexical (static)",
    "Implementation language": "Smalltalk",
    Platform: "Xerox Alto (74181)",
    OS: "Cross-platform (multi-platform)",
    other_details: {
      type: "programming",
      color: "#596706",
      extensions: [".st", ".cs"],
      aliases: ["squeak"],
      ace_mode: "text",
      codemirror_mode: "smalltalk",
      codemirror_mime_type: "text/x-stsrc",
      language_id: 352,
    },
    id: "yqwX",
  },
  {
    name: "Standard ML",
    description:
      "Standard ML is a modern dialect of ML, the language used in the Logic for Computable Functions (LCF) theorem-proving project. It is distinctive among widely used languages in that it has a formal specification, given as typing rules and operational semantics in The Definition of Standard ML. Standard ML is a functional programming language with some impure features. Programs written in Standard ML consist of expressions as opposed to statements or commands, although some expressions of type unit are only evaluated for their side-effects. Like all functional languages, a key feature of Standard ML is the function, which is used for abstraction. The factorial function can be expressed as follows: An SML compiler must infer the static type val factorial : int -> int without user-supplied type annotations. It has to deduce that n is only used with integer expressions, and must therefore itself be an integer, and that all terminal expressions are integer expressions.",
    Paradigm: "Multi-paradigm: functional, imperative, modular",
    Family: "ML",
    "First appeared": "1983; 39 years ago",
    "Stable release": "Standard ML '97 / 1997; 25 years ago",
    "Typing discipline": "Inferred, static, strong",
    "Filename extensions": ".sml",
    Website: "smlfamily.github.io",
    other_details: {
      type: "programming",
      color: "#dc566d",
      aliases: ["sml"],
      extensions: [".ML", ".fun", ".sig", ".sml"],
      tm_scope: "source.ml",
      ace_mode: "text",
      codemirror_mode: "mllike",
      codemirror_mime_type: "text/x-ocaml",
      language_id: 357,
    },
    id: "BhWm",
  },
  {
    name: "Snap! (BYOB)[Note 1]",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/Snap%21.png/180px-Snap%21.png",
    description:
      "In Snap!, the screen is organized in three resizable columns containing five regions: the block group selector (top of left column), the blocks palette (left column), the main area (middle column), and the stage area (top of right column) with the sprite selector (also called the sprite corral) showing sprite thumbnails below it.[Note 3] In the interactively resizable stage area (full-screen is available, too) are drawn the graphical results (i.e. animations, graphics, etc.) of the scripts running in the script area, and/or interactively double-clicked individual blocks in any palette. Individual blocks can be dragged from the palette onto the scripts area to be associated with the selected sprite. Snap!'s blocks are divided into eight groups: Motion, Looks, Sound, Pen, Control, Sensing, Operators, and Variables. The layout of these groups in the block group selector is shown in the table below. The central area can show scripts, costumes, or sounds associated with the selected sprite. What the main area shows depends on the selected tab.",
    Paradigm: "object-oriented, educational, event-driven",
    "Designed by": "Brian Harvey and Jens Mönig",
    Developer: "Jens Mönig",
    "First appeared": "2011; 11 years ago",
    "Stable release": "7.0.2 / December 21, 2021; 26 days ago ",
    "Typing discipline": "dynamic",
    "Implementation language":
      "JavaScript (Snap!), previously Squeak (BYOB version)",
    OS: "Cross-platform",
    License: "AGPL",
    "Filename extensions": ".xml (Snap!)",
    Website: "snap.berkeley.edu",
    id: "Mmc1",
  },
  {
    name: "SNOBOL",
    description:
      'SNOBOL4 stands apart from most programming languages of its era by having patterns as a first-class data type (i.e. a data type whose values can be manipulated in all ways permitted to any other data type in the programming language) and by providing operators for pattern concatenation and alternation. SNOBOL4 patterns are a type of object and admit various manipulations, much like later object-oriented languages such as JavaScript whose patterns are known as regular expressions. In addition SNOBOL4 strings generated during execution can be treated as programs and either interpreted or compiled and executed (as in the eval function of other languages). SNOBOL4 was quite widely taught in larger US universities in the late 1960s and early 1970s and was widely used in the 1970s and 1980s as a text manipulation language in the humanities. In the 1980s and 1990s its use faded as newer languages such as AWK and Perl made string manipulation by means of regular expressions fashionable. SNOBOL4 patterns subsume BNF grammars, which are equivalent to context-free grammars and more powerful than regular expressions. The "regular expressions" in current versions of AWK and Perl are in fact extensions of regular expressions in the traditional sense, but regular expressions, unlike SNOBOL4 patterns, are not recursive, which gives a distinct computational advantage to SNOBOL4 patterns. (Recursive expressions did appear in Perl 5.10, though, released in December 2007.) The later SL5 (1977) and Icon (1978) languages were designed by Griswold to combine the backtracking of SNOBOL4 pattern matching with more standard ALGOL-like structuring.',
    Paradigm: "Imperative, unstructured",
    "Designed by": "David J. Farber, Ralph E. Griswold and Ivan P. Polonsky",
    Developer:
      "David J. Farber, Ralph E. Griswold, Ivan P. Polonsky, and Bell Labs",
    "First appeared": "1962; 60 years ago",
    "Stable release": "SNOBOL4 / 1967; 55 years ago",
    Website: "www.snobol4.org",
    id: "0wLS",
  },
  {
    name: "Subtext",
    description:
      "Prior to the development of SPITBOL, SNOBOL4 was thought to be slow, memory-intensive, and impossible to compile due to its dynamic nature. While delayed binding prevents everything from being determined at compile time, SPITBOL adopts various strategies for making decisions as early as possible. Recent versions of the SPITBOL compiler are available. Since 2001 the source code for the original SPITBOL 360 compiler has been made available under the GNU General Public License. MACRO SPITBOL is an implementation of SPITBOL written in the 1970s by Robert Dewar and Anthony P. McCann. MACRO SPITBOL is coded in MINIMAL, an assembly language for an abstract machine. The instruction set is carefully defined to allow some latitude in its implementation, so that hardware operations favorable to string processing can be exploited. An implementation of MINIMAL that was designed for interpretation on microcomputers was done by translating MINIMAL into MICRAL using a translator that was itself implemented in SPITBOL. The MICRAL version of MACRO SPITBOL, together with the MICRAL interpreter ran in under 40K bytes. This extreme object code compression of MICRAL is achieved using a set of machine code macro substitutions that minimizes the space required for the object code and macro table. The complexity of known algorithms for an optimal solution to this problem are high, but efficient heuristics attain near-optimal results. The source code for MACRO SPITBOL was released under the GNU General Public License on April 17, 2009.",
    id: "vqhb",
  },
  {
    name: "SBL",
    description:
      "The Snowball compiler translates a Snowball script (a .sbl file) into program in thread-safe ANSI C, Java, Ada, C#, Go, Javascript, Object Pascal, Python or Rust. For ANSI C, each Snowball script produces a program file and corresponding header file (with .c and .h extensions). The Snowball compiler checks the consistency of its script, and this check was used to discover a typo in a seminal academic paper by Lovins which had remained undetected for 30 years. The basic datatypes handled by Snowball are strings of characters, signed integers, and boolean truth values, or more simply strings, integers and booleans. Snowball's characters are either 8-bit wide, or 16-bit, depending on the mode of use. In particular, both ASCII and 16-bit Unicode are supported. Like the SNOBOL programming language, the flow of control in Snowball is arranged by the implicit use of signals (each statement returns a true or false value), rather than the explicit use of constructs such as if, then, and break found in C and many other programming languages. The name Snowball was chosen as a tribute to the SNOBOL programming language, with which it shares the concept of string patterns delivering signals that are used to control the flow of the program. The creator of Snowball, Dr. Martin Porter, \"toyed with the idea of calling it 'strippergram' \", because it \"effectively provides a 'suffix STRIPPER GRAMmar' \".  ",
    id: "cM0P",
  },
  {
    name: "Solidity",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Solidity_logo.svg/80px-Solidity_logo.svg.png",
    description:
      "Solidity is an object-oriented programming language for writing smart contracts. It is used for implementing smart contracts on various blockchain platforms, most notably, Ethereum. It was developed by Christian Reitwiessner, Alex Beregszaszi, and several former Ethereum core contributors to enable writing smart contracts on blockchain platforms such as Ethereum. The programs compiled by the Solidity are intended to be run on Ethereum Virtual Machine. Solidity was initially proposed in August 2014 by Gavin Wood;[non-primary source needed] the language was later developed by the Ethereum project's Solidity team, led by Christian Reitwiessner. At present, Solidity is the primary language on Ethereum as well as on other private blockchains running on platforms that compete with Ethereum, such as Monax and its Hyperledger Burrow blockchain, which uses Tendermint for consensus. SWIFT has deployed a proof of concept using Solidity running on Burrow.[non-primary source needed][unreliable source] Solidity is a statically-typed programming language designed for developing smart contracts that run on the Ethereum Virtual Machine, also known as EVM.",
    Website: "github.com/ethereum/solidity",
    other_details: {
      type: "programming",
      color: "#AA6746",
      ace_mode: "text",
      tm_scope: "source.solidity",
      language_id: 237469032,
    },
    id: "DZIR",
  },
  {
    name: "source",
    description:
      'During the development of SICP JS, starting in 2008, it became clear that purpose-designed sublanguages of JavaScript would contribute to the learning experience. Initially called "JediScript" and inspired by JavaScript: The Good Parts. O\'Reilly. 2008. ISBN 9780596517748., Douglas Crockford, the Source sublanguages follow the chapters of SICP JS; each language Source §x is a sublanguage of the next language Source §(x+1). Source §1 is a very small purely functional sublanguage of JavaScript, designed for Chapter 1 of SICP JS. Source §2 adds pairs and a list library, following the data structures theme of Chapter 2. Source §3 adds stateful constructs, and Source §4 adds support for meta-circular evaluation. Chapter 5 of SICP JS does not require language support beyond Source §4. All Source languages are properly tail recursive, as required by Chapter 1 of SICP and as specified by ECMAScript 2015. Since the Safari browser is ECMAScript-2015-compliant, including proper tail calls, it can serve as an implementation of all Source languages, provided that the SICP package is loaded. The Source Academy is a web-based programming environment that implements all Source languages, regardless of browser support for proper tail calls, and features various tools for the readers of SICP JS. The language implementation in the Source Academy, js-slang, is also available as a stand-alone environment based on Node.js.  ',
    Paradigm: "Multi-paradigm: scripting, imperative, procedural, functional",
    "First appeared": "2017; 5 years ago",
    "Stable release": "2022 (Rook) / 25 June 2021; 6 months ago",
    "Typing discipline": "Dynamic, duck",
    OS: "browser-based",
    License: "Apache License",
    "Filename extensions": ".js",
    Website: "docs.sourceacademy.org",
    id: "Yd10",
  },
  {
    name: "SPARK",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/1/16/Sparkada.jpg/250px-Sparkada.jpg",
    description:
      'Originally, there were three versions of the SPARK language (SPARK83, SPARK95, SPARK2005) based on Ada 83, Ada 95 and Ada 2005 respectively. A fourth version of the SPARK language, SPARK 2014, based on Ada 2012, was released on April 30, 2014. SPARK 2014 is a complete re-design of the language and supporting verification tools. The SPARK language consists of a well-defined subset of the Ada language that uses contracts to describe the specification of components in a form that is suitable for both static and dynamic verification. In SPARK83/95/2005, the contracts are encoded in Ada comments and so are ignored by any standard Ada compiler, but are processed by the SPARK "Examiner" and its associated tools.',
    Paradigm: "Multi-paradigm",
    Developer: "Altran and AdaCore",
    "Stable release": "Community 2021 / June 1, 2021; 7 months ago",
    "Typing discipline": "static, strong, safe, nominative",
    OS: "Cross-platform: Linux, Microsoft Windows, Mac OS X",
    License: "GPLv3",
    Website: "About SPARK",
    id: "PqJu",
  },
  {
    name: "Speakeasy",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/d/d8/Speakeasy_Red_Logo.png",
    description:
      'Speakeasy was a numerical computing interactive environment also featuring an interpreted programming language. It was initially developed for internal use at the Physics Division of Argonne National Laboratory by the theoretical physicist Stanley Cohen. He eventually founded Speakeasy Computing Corporation to make the program available commercially. Speakeasy is a very long-lasting numerical package. In fact, the original version of the environment was built around a core dynamic data repository called "Named storage" developed in the early 1960s, while the most recent version has been released in 2006. Speakeasy was aimed to make the computational work of the physicists at the Argonne National Laboratory easier. Speakeasy was initially conceived to work on mainframes (the only kind of computers at that time), and was subsequently ported to new platforms (minicomputers, personal computers) as they became available. The porting of the same code on different platforms was made easier by using Mortran metalanguage macros to face systems dependencies and compilers deficiencies and differences. Speakeasy is currently available on several platforms: PCs running Windows, macOS, Linux, departmental computers and workstations running several flavors of Linux, AIX or Solaris.',
    "Developer(s)": "Speakeasy Computing Corporation",
    "Stable release": "IV Iota / 2006",
    "Written in": "Mortran, FORTRAN, C[citation needed]",
    "Operating system":
      "Windows, macOS, RedHat Linux, SUSE Linux, Mandrake Linux, Debian, Solaris, HP-UX",
    Type: "Technical computing",
    License: "Trialware",
    Paradigm: "imperative",
    "Designed by": "Stanley Cohen",
    Developer: "Speakeasy Computing Corporation",
    "First appeared": "1964",
    "Typing discipline": "dynamic",
    id: "7hZl",
  },
  {
    name: "TACL",
    description:
      "The Propeller microcontroller, Propeller assembly language, and Spin interpreter were designed by Parallax's cofounder and president, Chip Gracey. The Spin programming language and Propeller Tool integrated development environment (IDE) were designed by Chip Gracey and Parallax's software engineer Jeff Martin. On August 6, 2014, Parallax Inc., released all of the Propeller 1 P8X32A hardware and tools as open-source hardware and software under the GNU General Public License (GPL) 3.0. This included the Verilog code, top-level hardware description language (HDL) files, Spin interpreter, PropellerIDE and SimpleIDE programming tools and compilers. Each of the eight 32-bit cores (termed a cog) has a central processing unit (CPU) which has access to 512 32-bit long words (2 KB) of instructions and data. Self-modifying code is possible and is used internally, for example, as the boot loader overwrites itself with the Spin Interpreter. Subroutines in Spin (object-based high-level code) use a call-return mechanism requiring use of a call stack. Assembly (PASM, low-level) code needs no call stack. Access to shared memory (32 KB random-access memory (RAM); 32 KB read-only memory (ROM)) is controlled via round-robin scheduling by an internal computer bus controller termed the hub. Each cog also has access to two dedicated hardware counters and a special video generator for use in generating timing signals for PAL, NTSC, VGA, servomechanism-control, and others. The Propeller can be clocked using either an internal, on-chip oscillator (providing a lower total part count, but sacrificing some accuracy and thermal stability) or an external crystal oscillator or ceramic resonator (providing higher maximum speed with greater accuracy at higher total cost). Only the external oscillator may be run through an on-chip phase-locked loop (PLL) clock multiplier, which may be set at 1x, 2x, 4x, 8x, or 16x.",
    id: "y9aL",
  },
  {
    name: "TADS (Text Adventure Development System)",
    description:
      "SPS-1 could run on a low-end machine with 1.4K memory, SPS-2 required at least 4K memory. As the 1400 series matured additional assemblers, programming languages and report generators became available, replacing SPS in most sites.   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    id: "RIXQ",
  },
  {
    name: "SQL (Structured Query Language)",
    description:
      'Originally based upon relational algebra and tuple relational calculus, SQL consists of many types of statements, which may be informally classed as sublanguages, commonly: a data query language (DQL),[a] a data definition language (DDL),[b] a data control language (DCL), and a data manipulation language (DML).[c] The scope of SQL includes data query, data manipulation (insert, update and delete), data definition (schema creation and modification), and data access control. Although SQL is essentially a declarative language (4GL), it also includes procedural elements. SQL was one of the first commercial languages to use Edgar F. Codd’s relational model. The model was described in his influential 1970 paper, "A Relational Model of Data for Large Shared Data Banks". Despite not entirely adhering to the relational model as described by Codd, it became the most widely used database language. SQL became a standard of the American National Standards Institute (ANSI) in 1986, and of the International Organization for Standardization (ISO) in 1987. Since then, the standard has been revised to include a larger set of features. Despite the existence of standards, most SQL code requires at least some changes before being ported to different database systems. SQL was initially developed at IBM by Donald D. Chamberlin and Raymond F. Boyce after learning about the relational model from Edgar F. Codd in the early 1970s. This version, initially called SEQUEL (Structured English Query Language), was designed to manipulate and retrieve data stored in IBM\'s original quasirelational database management system, System R, which a group at IBM San Jose Research Laboratory had developed during the 1970s.',
    Paradigm: "Declarative",
    Family: "Query language",
    "Designed by": "Donald D. Chamberlin Raymond F. Boyce",
    Developer: "ISO/IEC",
    "First appeared": "1974; 48 years ago",
    "Stable release": "SQL:2016 / December 2016; 5 years ago",
    "Typing discipline": "Static, strong",
    OS: "Cross-platform",
    Website: "www.iso.org/standard/63555.html",
    "Filename extension": ".sql",
    "Internet media type": "application/sql",
    "Developed by": "ISO/IEC",
    "Initial release": "1986",
    "Type of format": "Database",
    Standard: "ISO/IEC 9075",
    "Open format?": "Yes",
    id: "sveo",
  },
  {
    name: "Tcl",
    description:
      "In the early 80's SQR was a 'free' add-on to Gupta's SQLBase. At the time SQLBase was the only relational database that ran on IBM PCs (x86) machines. SQR was written by Israel Stern in Cleveland, Ohio, probably around 1984 or 1985. SQ Software created SQR in the mid 1980s. It had a marketing agreement with D & N Systems, which changed its name to SQL Solutions and was later acquired by Sybase Inc in the early 1990s. To avoid competing directly with Oracle Corporation, Sybase had a marketing and development agreement with MITI for the Oracle database compatible versions of SQR. MITI acquired the full rights to SQR in the mid-1990s. MITI changed its name to SQRiBE Technologies in 1997. Brio Technology acquired SQRiBE in August, 1999. Brio Technology later changed its name to Brio Software. Brio licensed its source code to PeopleSoft Inc. sometime around 2000. Hyperion Solutions Corporation acquired Brio Software in October, 2003. Oracle Corporation acquired PeopleSoft in December, 2004. In March 2007, Oracle Corporation acquired Hyperion Solutions. SQR stands for Structured Query Report. SQR is notable for its database and printing functions. It can embed any SQL statement almost anywhere in a program. One configuration of SQR can access multidimensional databases such as Essbase. It can combine database reads with print instructions, flexibly format data and page breaks, and print variable fonts, sizes, and colors. SQR contains a graph generation command that offers dozens of parameters for adjusting content and appearance.",
    other_details: {
      type: "programming",
      color: "#e4cc98",
      extensions: [".tcl", ".adp", ".tm"],
      filenames: ["owh", "starfield"],
      interpreters: ["tclsh", "wish"],
      ace_mode: "tcl",
      codemirror_mode: "tcl",
      codemirror_mime_type: "text/x-tcl",
      language_id: 367,
    },
    id: "_mmC",
  },
  {
    name: "Squeak",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Squeak.svg/100px-Squeak.svg.png",
    description:
      "Squeak runs on a virtual machine (VM), allowing for a high degree of portability. The Squeak system includes code for generating a new version of the VM on which it runs, along with a VM simulator written in Squeak. Dan Ingalls, an important contributor to the Squeak project, wrote the paper upon which Squeak is built, and constructed the architecture for five generations of the Smalltalk language. Alan Kay is an important contributor to the Squeak project, and Squeak incorporates many elements of his proposed Dynabook concept. Squeak includes four user interface frameworks:",
    Paradigm: "object-oriented",
    "Designed by": "Alan Kay, Dan Ingalls, Adele Goldberg",
    Developers: "The Squeak Community",
    "First appeared": "1996; 26 years ago",
    "Stable release": "5.3 / March 4, 2020; 22 months ago",
    "Typing discipline": "Dynamic",
    Platform: "Cross-platform",
    OS: "Cross-platform: Unix-like, macOS, iOS, Windows, more",
    License: "MIT, Apache",
    "Filename extensions": ".image, .changes, .sources, .st",
    Website: "www.squeak.org",
    id: "mUu2",
  },
  {
    name: "TELCOMP",
    description:
      "Resources encapsulate processes and the variables they share, and can be separately compiled. Operations provide the primary mechanism for process interaction. SR provides a novel integration of the mechanisms for invoking and servicing operations. Consequently, it supports local and remote procedure call, rendezvous, message passing, dynamic process creation, multicast, semaphores and shared memory. Version 2.2 has been ported to the Apollo, DECstation, Data General AViiON, HP 9000 Series 300, Multimax, NeXT, PA-RISC, RS/6000, Sequent Symmetry, SGI IRIS, Sun-3, Sun-4 and others.  ",
    id: "kef4",
  },
  {
    name: "TeX",
    description:
      "S/SL is a small programming language that supports cheap recursion and defines input, output, and error token names (& values), semantic mechanisms (class interfaces whose methods are really escapes to routines in a host programming language but allow good abstraction in the pseudocode) and a pseudocode program that defines the syntax of the input language by the token stream the program accepts. Alternation, control flow and one-symbol look-ahead constructs are part of the language. The S/SL processor compiles this pseudocode into a table (byte-codes) that is interpreted by the S/SL table-walker (interpreter). The pseudocode language processes the input language in LL(1) recursive descent style but extensions allow it to process any LR(k) language relatively easily. S/SL is designed to provide excellent syntax error recovery and repair. It is more powerful and transparent than Yacc but can be slower. S/SL's \"semantic mechanisms\" extend its capabilities to all phases of compiling, and it has been used to implement all phases of compilation, including scanners, parsers, semantic analyzers, code generators and virtual machine interpreters in multi-pass language processors. S/SL has been used to implement production commercial compilers for languages such as PL/I, Euclid, Turing, Ada, and COBOL, as well as interpreters, command processors, and domain specific languages of many kinds. It is the primary technology used in IBM's ILE/400 COBOL compiler, and the ZMailer mail transfer agent uses S/SL for defining both its mail router processing language and its RFC 822 email address validation.",
    other_details: {
      type: "markup",
      color: "#3D6117",
      ace_mode: "tex",
      codemirror_mode: "stex",
      codemirror_mime_type: "text/x-stex",
      wrap: true,
      aliases: ["latex"],
      extensions: [
        ".tex",
        ".aux",
        ".bbx",
        ".bib",
        ".cbx",
        ".cls",
        ".dtx",
        ".ins",
        ".lbx",
        ".ltx",
        ".mkii",
        ".mkiv",
        ".mkvi",
        ".sty",
        ".toc",
      ],
      language_id: 369,
    },
    id: "OjdB",
  },
  {
    name: "StarLogo",
    description:
      "The first StarLogo ran on a Connection Machine 2 parallel computer. A subsequent version ran on Macintosh computers. It was later renamed MacStarLogo, and now is named MacStarLogo Classic. The current StarLogo is written in the language Java and works on most computers. StarLogo is also available in a version named OpenStarLogo. Its source code is available online, but the license under which it is released is not an open-source license according to The Open Source Definition, because of restrictions on the commercial use of the code. StarLogo TNG (The Next Generation) version 1.0 was released in July 2008. It provides a 3D world using OpenGL graphics and a block-based graphical language to increase ease of use and learnability. It is written in C and Java. StarLogo TNG uses blocks to put together puzzle-like pieces. StarLogo TNG reads the blocks in the order that they fit together, and sets the program in the Spaceland view. StarLogo is a primary influence for the Kedama particle system, programmed by Yoshiki Oshima, found in the Etoys educational programming environment and language, which can be viewed as a Logo done originally in Squeak Smalltalk.",
    Paradigm:
      "Multi-paradigm: educational, procedural, agent-based, simulation",
    Family: "Lisp",
    "Designed by": "Mitchel Resnick, Eric Klopfer, Daniel Wendel",
    Developers: "MIT: Media Lab, Scheller Teacher Education Program",
    "First appeared": "2001; 21 years ago",
    "Stable release": "StarLogo Nova 2.1 / November 24, 2018; 3 years ago",
    "Typing discipline": "duck, dynamic, strong",
    "Implementation language": "Java, C",
    Platform: "Java virtual machine",
    OS: "Windows, macOS",
    License: "Various",
    Website: "www.slnova.org",
    id: "NhX_",
  },
  {
    name: "TIE",
    description:
      "Artificial Intelligence Ltd were awarded the British Computer Society Award for Technical Innovation 1989 for Strand88. The language was created by computer scientists Ian Foster and Stephen Taylor. Felix Winkelmann's web site - Strand   This programming-language-related article is a stub. You can help Wikipedia by expanding it.",
    id: "65j_",
  },
  {
    name: "Stata",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Stata_logo_med_blue.png/225px-Stata_logo_med_blue.png",
    description:
      "Stata was initially developed by Computing Resource Center in California and the first version was released in 1985. In 1993, the company moved to College Station, TX and was renamed Stata Corporation, now known as StataCorp. A major release in 2003 included a new graphics system and dialog boxes for all commands. Since then, a new version has been released once every two years. The current version is Stata 17, released in April 2021. From its creation, Stata has always employed an integrated command-line interface. Starting with version 8.0, Stata has included a graphical user interface based on Qt framework which uses menus and dialog boxes to give access to many built-in commands. The dataset can be viewed or edited in spreadsheet format. From version 11 on, other commands can be executed while the data browser or editor is opened. Until the release of version 16, Stata could only open a single dataset at any one time. Stata allows for flexibility with assigning data types to data. Its compress command automatically reassigns data to data types that take up less memory without loss of information. Stata utilizes integer storage types which occupy only one or two bytes rather than four, and single-precision (4 bytes) rather than double-precision (8 bytes) is the default for floating-point numbers. Stata's data format is always tabular in format. Stata refers to the columns of tabular data as variables.",
    "Original author(s)": "William Gould",
    "Developer(s)": "StataCorp",
    "Initial release": "1985",
    "Stable release": "17.0 / April 20, 2021; 8 months ago",
    "Written in": "C",
    "Operating system": "Windows, macOS, Linux",
    Type: "Statistical analysis Numerical analysis",
    License: "Proprietary",
    Website: "www.stata.com",
    other_details: {
      type: "programming",
      extensions: [".do", ".ado", ".doh", ".ihlp", ".mata", ".matah", ".sthlp"],
      ace_mode: "text",
      language_id: 358,
    },
    id: "B3I2",
  },
  {
    name: "Toi",
    description:
      'Subtext was created by Jonathan Edwards who submitted a paper on the language to OOPSLA. It was accepted as part of the 2005 conference. Early video previews of the Subtext environment were released circa 2006, which demonstrated the semantics of Subtext programs, and the close integration with the Subtex environment and runtime. Subtext programs are declared and manipulated (or mutated) by adding and linking elements of various types to a syntax tree, and entering in values or names as necessary, as opposed to typing out textual programs. Due to the design of the Subtext language and environment, there is no distinction between a program\'s representation and its execution. Like spreadsheets, Subtext programs are live executions within an environment and runtime, and programming is direct manipulation of these executions via a graphical environment. Unlike typical functional programming languages, Subtext has simple semantics and is easily applicable to reactive systems that require mutable state, I/O, and concurrency, under a model known as "Reactive Programming". Console input ("invocations") can be utilized via data flow within a Subtext program, allowing users to manipulate values interactively. A continuation and subset of the Subtext language using other principles, is Coherence, an experimental programming language and environment, which uses a new model of change-driven computation called "Coherent reaction", to coordinate the effects and side-effects of programs interactively as they are being developed. The language is specialized for interactive application software, and is being designed by the creator of Subtext, Jonathan Edwards, who reports upon its development by publishing white papers.',
    id: "o_Z9",
  },
  {
    name: "Superbase",
    description:
      'It was originally created in 1983 by Precision Software for the Commodore 64 and 128 and later the Amiga and Atari ST. In 1989, it was the first database management system to run on a Windows computer. Precision Software, a UK-based company, was the original creator of the product Superbase. Superbase was and still is used by a large number of people on various platforms. It was often used only as an end-user database but a very large number of applications were built throughout industry, government, and academia and these were often of significant complexity. Some of these applications continue in use to the current day, mostly in small businesses. The initial versions were text mode only, but with the release of the Amiga version, Superbase became the first product to use the now common VCR control panel for browsing through records.[citation needed] It also supported a number of different media formats, including images, sounds, and video. Superbase was often referred to as the multimedia database in early years, when such features were uncommon. The Amiga version also featured an internal language and the capability to generate front end "masks" for queries and reports, years before Microsoft Access. This version was a huge success and that resulted in a version being created for a number of platforms using the same approach. Eventually a Microsoft Windows version was released and a couple of years later the company was sold by its founders to Software Publishing Corporation. SPC sold off the non-Windows versions of the product and after releasing version 2 and in the late alpha stages of version 3, sold the product to a company called Computer Concepts Corporation.',
    "Original author(s)": "Precision Software",
    "Developer(s)": "Superbase Software Ltd",
    "Initial release": "1983; 39 years ago",
    "Operating system": "Cross-platform",
    Type: "Database software",
    Website: "www.superbase.com",
    id: "URda",
  },
  {
    name: "SuperCollider",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/SuperCollider_logo.svg/100px-SuperCollider_logo.svg.png",
    description:
      "Since then it has been evolving into a system used and further developed by both scientists and artists working with sound. It is a dynamic programming language providing a framework for acoustic research, algorithmic music, interactive programming and live coding. Originally released under the terms of the GPL-2.0-or-later in 2002, and from version 3.4 under GPL-3.0-or-later, SuperCollider is free and open-source software. Starting with version 3, the SuperCollider environment has been split into two components: a server, scsynth; and a client, sclang. These components communicate using OSC (Open Sound Control). The SC language combines the object-oriented structure of Smalltalk and features from functional programming languages with a C-family syntax.",
    "Original author(s)": "James McCartney",
    "Initial release": "1996; 26 years ago",
    "Stable release": "3.12.2 / 8 January 2022; 7 days ago",
    Repository: "github.com/supercollider/supercollider",
    "Written in": "C++",
    "Operating system": "FreeBSD, Linux, macOS, Windows",
    Type: "Audio programming language",
    License: "GPL-3.0-or-later",
    Website: "supercollider.github.io",
    other_details: {
      type: "programming",
      color: "#46390b",
      extensions: [".sc", ".scd"],
      interpreters: ["sclang", "scsynth"],
      tm_scope: "source.supercollider",
      ace_mode: "text",
      language_id: 361,
    },
    id: "yYez",
  },
  {
    name: "TTM",
    description:
      "One of the most powerful features SuperCard adds to the HyperTalk language is user properties. Where HyperTalk had a fixed set of properties on its objects, SuperCard scripters can use the define property propName command to add new properties to buttons and fields. These properties can contain arbitrary text (including numbers and object references, which are also represented using text in xTalks), and even dumps of entire files. SuperTalk provides several variations on HyperTalk's answer and answer file commands, which let one choose several items from a list, choose an icon from all available icons, pick a MIDI instrument to play sound with, or choose a file of a supported image format (including a preview), or disks and folders. Different from HyperTalk's dialogs, SuperTalk answer and ask dialogs do not all resize dynamically to hold more text. However, since SuperCard allows having cards (i.e. \"pages\") in windows of arbitrary types, one can easily build one's own dialog that is large enough. SuperTalk also has an alert command that displays standard system alert windows and sheets, including standard system icons. A switch command is available for more readability in complex conditionals, and various types of media can be recorded (e.g. screen grabs of a card, sound and QuickTime movies). There is also a clone command that is equivalent to copying and pasting but leaves the clipboard unchanged, an enumeration command that creates global variables with sequential integer values, and recently MetaCard's familiar repeat for each item x command for iterating through lists was added. SuperCard also offers exception handling using a try statement with associated throw command.",
    id: "XA8Y",
  },
  {
    name: "Swift",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Swift_logo.svg/200px-Swift_logo.svg.png",
    description:
      "Swift is a general-purpose, multi-paradigm, compiled programming language developed by Apple Inc. and the open-source community. First released in 2014, Swift was developed as a replacement for Apple's earlier programming language Objective-C, as Objective-C had been largely unchanged since the early 1980s and lacked modern language features. Swift works with Apple's Cocoa and Cocoa Touch frameworks, and a key aspect of Swift's design was the ability to interoperate with the huge body of existing Objective-C code developed for Apple products over the previous decades. It is built with the open source LLVM compiler framework and has been included in Xcode since version 6, released in 2014. On Apple platforms, it uses the Objective-C runtime library, which allows C, Objective-C, C++ and Swift code to run within one program. Apple intended Swift to support many core concepts associated with Objective-C, notably dynamic dispatch, widespread late binding, extensible programming and similar features, but in a \"safer\" way, making it easier to catch software bugs; Swift has features addressing some common programming errors like null pointer dereferencing and provides syntactic sugar to help avoid the pyramid of doom. Swift supports the concept of protocol extensibility, an extensibility system that can be applied to types, structs and classes, which Apple promotes as a real change in programming paradigms they term \"protocol-oriented programming\" (similar to traits). Swift was introduced at Apple's 2014 Worldwide Developers Conference (WWDC). It underwent an upgrade to version 1.2 during 2014 and a major upgrade to Swift 2 at WWDC 2015. Initially a proprietary language, version 2.2 was made open-source software under the Apache License 2.0 on December 3, 2015, for Apple's platforms and Linux. Through version 3.0 the syntax of Swift went through significant evolution, with the core team making source stability a focus in later versions. In the first quarter of 2018 Swift surpassed Objective-C in measured popularity.",
    Paradigm:
      "Multi-paradigm: protocol-oriented, object-oriented, functional, imperative, block structured, declarative, concurrent",
    "Designed by":
      "Chris Lattner, Doug Gregor, John McCall, Ted Kremenek, Joe Groff, and Apple Inc.",
    Developer: "Apple Inc. and open-source contributors",
    "First appeared": "June 2, 2014; 7 years ago",
    "Stable release": "5.5.2  / 13 December 2021; 34 days ago",
    "Preview release": "5.6 branch",
    "Typing discipline": "Static, strong, inferred",
    OS: "Apple's operating systems (Darwin, iOS, iPadOS, macOS, tvOS, watchOS), Linux, Windows 10, Android",
    License:
      "Apache License 2.0 (Swift 2.2 and later) Proprietary (up to Swift 2.2)",
    "Filename extensions": ".swift, .SWIFT",
    Website: "swift.org",
    other_details: {
      type: "programming",
      color: "#ffac45",
      extensions: [".swift"],
      ace_mode: "text",
      codemirror_mode: "swift",
      codemirror_mime_type: "text/x-swift",
      language_id: 362,
    },
    id: "28-x",
  },
  {
    name: "SystemVerilog",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/e/ef/SystemVerilog_logo.png/240px-SystemVerilog_logo.png",
    description:
      "SystemVerilog, standardized as IEEE 1800, is a hardware description and hardware verification language used to model, design, simulate, test and implement electronic systems. SystemVerilog is based on Verilog and some extensions, and since 2008 Verilog is now part of the same IEEE standard. It is commonly used in the semiconductor and electronic design industry as an evolution of Verilog. SystemVerilog started with the donation of the Superlog language to Accellera in 2002 by the startup company Co-Design Automation. The bulk of the verification functionality is based on the OpenVera language donated by Synopsys. In 2005, SystemVerilog was adopted as IEEE Standard 1800-2005. In 2009, the standard was merged with the base Verilog (IEEE 1364-2005) standard, creating IEEE Standard 1800-2009. The current version is IEEE standard 1800-2017. The feature-set of SystemVerilog can be divided into two distinct roles: The remainder of this article discusses the features of SystemVerilog not present in Verilog-2005.",
    Paradigm: "Structured (design) Object-oriented (verification)",
    "Designed by": "Synopsys, later IEEE",
    "First appeared": "2002; 20 years ago",
    "Stable release": "IEEE 1800-2017 / February 22, 2018; 3 years ago",
    "Typing discipline": "Static, weak",
    "Filename extensions": ".sv, .svh",
    other_details: {
      type: "programming",
      color: "#DAE1C2",
      extensions: [".sv", ".svh", ".vh"],
      ace_mode: "verilog",
      codemirror_mode: "verilog",
      codemirror_mime_type: "text/x-systemverilog",
      language_id: 363,
    },
    id: "aRBO",
  },
  {
    name: "T",
    description:
      "T's purpose is to test the thesis developed by Guy L. Steele Jr. and Gerald Jay Sussman in their series of papers about Scheme: that Scheme may be used as the basis for a practical programming language of exceptional expressive power, and that implementations of Scheme could perform better than other Lisp systems, and competitively with implementations of programming languages, such as C and BLISS, which are usually considered to be inherently more efficient than Lisp on conventional machine architectures. Much of this occurs via an optimizing compiler named Orbit. T contains some features that modern Scheme lacks. For example, T is object-oriented, and it has first-class environments, called locales, which can be modified non-locally and used as a module system. T has several extra special forms for lazy evaluation and flow control, and an equivalent to Common Lisp's setf. T, like Scheme, supports call-with-current-continuation (call/cc), but it also has a more limited form called catch. From the T manual, a hypothetical implementation of cons could be: This example shows that objects in T are intimately related to closures and message-passing. A primitive called join puts two objects together, allowing for something resembling inheritance. T was ported to many hardware platforms and operating systems, including:",
    Paradigm: "Multi-paradigm: object-oriented, imperative, functional, meta",
    Family: "Lisp",
    "Designed by": "Jonathan A. Rees Norman I. Adams",
    Developers: "Jonathan A. Rees Norman I. Adams",
    "First appeared": "1982; 40 years ago",
    "Final release": "3.0 / August 1, 1984; 37 years ago",
    "Typing discipline": "dynamic, strong",
    Platform: "Cross-platform",
    OS: "Cross-platform",
    Website: "mumble.net/~jar/tproject",
    id: "YHS-",
  },
  {
    name: "TXL",
    description:
      'Tandem Computers were originally designed and sold by Tandem Computers, Inc., based in Cupertino, CA. These were the first commercially available parallel processing computers, originally referred to as "mini-computers". Tandem\'s strategy was the emerging concept of "continuous availability" that relied on mirrored disks, their controllers and software, and a well engineered operating system (Guardian, and later NonStop Kernel or NSK) to ensure continuous application availability by ensuring the system could survive any single point of hardware failure. Tandem Computers, Inc. was acquired by Compaq Computer Corporation in 1997; and Compaq Computer Corp. was subsequently purchased by Hewlett-Packard in 2001. Today they are known as "HPE Nonstop", with products such as the HP Integrity NonStop Blade systems. TACL continues to be the scripting language used on Hewlett Packard NonStop Servers. NonStop servers are key components of the backbone infrastructure of the largest banks, casinos, retailers, telephone companies, email systems, and stock exchanges worldwide. Many computer systems that were produced after the Tandem NonStop platform relied on some form of redundancy (or HOT backup) and a "failover" scheme to continue running. On the Tandem NonStop, however, each CPU performs its own work and may contain a dormant "backup" process for another CPU. Each pair of CPUs, 0 and 1 for example, share hardware ownership of controllers and disk drives. The drives are not REDUNDANT. Writes to the disk pair are performed on both the primary and backup drives. Reads, however, take advantage of which head on which drive is closer to the information and choose that drive onto which to perform the read. For example if CPU 0 fails, then CPU 1 takes over ownership of a disk drive, providing continuous availability to that data. A primary process that is running may be given a backup process, which receives checkpoint information. If the primary process fails, through whatever reason, the backup process takes over, that backup process may spawn its own backup. This is what earned them the name NonStop, since application programs can be fault-tolerant. This makes them very attractive for their customers, because of their ability for continuous availability, or being NonStop. These systems are also known for handling very high numbers of transactions per second, which is very useful for banks and stock exchanges.',
    other_details: {
      type: "programming",
      extensions: [".txl"],
      tm_scope: "source.txl",
      ace_mode: "text",
      language_id: 366,
    },
    id: "WtW7",
  },
  {
    name: "TypeScript",
    description:
      "Unlike PL/I, TACPOL keywords—called particles—are reserved words and cannot be used as identifiers. There are roughly 100 reserved words. TACPOL identifiers can be any length, but if longer than eight characters only the first five concatenated with the last three characters were actually used. TACPOL supports fixed-point binary numeric data, fixed-length character strings up to 512 bytes, and fixed-length bit strings up to 32 bits. There is no support for floating point numeric data or for pointers. Arrays may have up to three dimensions, but dynamic bounds are not permitted. Additional types are records, called groups, limited to a single level of nesting, tables (arrays of groups), and unions, called cells. Control structures include IF-THEN-ELSE, iteration, WHILE and CASE statements.",
    other_details: {
      type: "programming",
      color: "#2b7489",
      aliases: ["ts"],
      interpreters: ["node"],
      extensions: [".ts", ".tsx"],
      tm_scope: "source.ts",
      ace_mode: "typescript",
      codemirror_mode: "javascript",
      codemirror_mime_type: "application/typescript",
      language_id: 378,
    },
    id: "R1PI",
  },
  {
    name: "TADS",
    description:
      'The original TADS 1 was released by High Energy Software as shareware in 1988, and was followed by TADS 2 not long after. From the late 1980s to early 1990s, free development tools such as TADS and Inform enabled amateur communities to create interactive fiction. In the mid-1990s, TADS was a top development tool for interactive fiction. At the time, it was a more improved tool for parsing and world building than existing systems like AGT (Adventure Game Toolkit). TADS 2 syntax is based on C, with bits of Pascal. TADS 2 has been maintained and updated at regular intervals by its creator, Michael J. Roberts, even after it became freeware in July 1996. Graham Nelson, creator of Inform, describes Inform and TADS as the "only two systems... widely used" in the last half of the 1990s, and TADS has been called "The second most commonly used IF programming language today". Multimedia TADS, introduced in 1998, allows games to display graphics, animation and play sounds, if the platform supports it. In 2006, TADS received a major overhaul with the release of TADS 3, which is a complete rewrite of the TADS engine, only retaining the platform-dependent code to ease porting. TADS 3 uses a language with a syntax that resembles C++ and Java. It has many new features, such as efficient dynamic objects (with automatic garbage collection), structured exceptions, native UTF-8 strings, and many useful function classes. The TADS 3 compiler and interpreter have been ported to the DOS, Macintosh and Unix platforms. Several TADS 3 games have been released.',
    Paradigm: "prototype-based, domain-specific",
    "Designed by": "Michael J. Roberts",
    Developer: "Michael J. Roberts",
    "First appeared": "1988; 34 years ago",
    "Stable release": "Version 3.1.3 / May 16, 2013; 8 years ago",
    "Typing discipline": "Strong typing, type inference",
    OS: "Amiga, BeOS, DOS, Microsoft Windows, Unix (Linux, Mac OS X), others",
    License: "TADS 2 Freeware source code[clarification needed]",
    Website: "www.tads.org",
    id: "F-yD",
  },
  {
    name: "UCSD Pascal",
    description:
      "The design concept of TAL, an evolution of Hewlett Packard's SPL, was intimately associated and optimized with a microprogrammed CISC instruction set. Each TAL statement could easily compile into a sequence of instructions that manipulated data on a transient floating register stack. The register stack itself floated at the crest of the program's memory allocation and call stack. The language itself has the appearance of ALGOL or Pascal, with BEGIN and END statements. However, its semantics are far more like C. It does not permit indefinite levels of procedure nesting, it does not pass complex structured arguments by value, and it does not strictly type most variable references. Programming techniques are much like C using pointers to structures, occasional overlays, deliberate string handling and casts when appropriate. Available datatypes include 8 bit, 16 bit, 32 bit and (introduced later) 64 bit integers. Microcode level support was available for null terminated character strings. However, this is not commonly used. Originally the Tandem NonStop operating system was written in TAL. Recently much of it has been rewritten in C and TAL has been deprecated for new development.",
    id: "OZSh",
  },
  {
    name: "Tcl",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/e/eb/Tcl-powered.svg/70px-Tcl-powered.svg.png",
    description:
      'It is commonly used embedded into C applications, for rapid prototyping, scripted applications, GUIs, and testing. Tcl interpreters are available for many operating systems, allowing Tcl code to run on a wide variety of systems. Because Tcl is a very compact language, it is used on embedded systems platforms, both in its full form and in several other small-footprint versions. The popular combination of Tcl with the Tk extension is referred to as Tcl/Tk, and enables building a graphical user interface (GUI) natively in Tcl. Tcl/Tk is included in the standard Python installation in the form of Tkinter. The Tcl programming language was created in the spring of 1988 by John Ousterhout while working at the University of California, Berkeley. Originally "born out of frustration", according to the author, with programmers devising their own languages intended to be embedded into applications, Tcl gained acceptance on its own. Ousterhout was awarded the ACM Software System Award in 1997 for Tcl/Tk. The name originally comes from Tool Command Language, but is conventionally spelled "Tcl" rather than "TCL".',
    Paradigm:
      "Multi-paradigm: event-driven, functional, imperative, object-oriented",
    "Designed by": "John Ousterhout",
    Developer: "Tcl Core Team",
    "First appeared": "1988; 34 years ago",
    "Stable release": "8.6.12 / October 31, 2021; 2 months ago",
    "Preview release": "9.0a3 / June 23, 2021; 6 months ago",
    "Typing discipline":
      "Dynamic typing, everything can be treated as a string",
    License: "BSD-style",
    "Filename extensions": ".tcl, .tbc",
    Website: "www.tcl-lang.org www.tcl.tk",
    other_details: {
      type: "programming",
      color: "#e4cc98",
      extensions: [".tcl", ".adp", ".tm"],
      filenames: ["owh", "starfield"],
      interpreters: ["tclsh", "wish"],
      ace_mode: "tcl",
      codemirror_mode: "tcl",
      codemirror_mime_type: "text/x-tcl",
      language_id: 367,
    },
    id: "Vd8H",
  },
  {
    name: "TECO",
    description:
      'According to Murphy, the initial acronym was Tape Editor and Corrector because "punched paper tape was the only medium for the storage of program source on our PDP-1. There was no hard disk, floppy disk, magnetic tape (magtape), or network." By the time TECO was made available for general use, the name had become "Text Editor and Corrector," since even the PDP-1 version by then supported other media. It was subsequently modified by many other people and is a direct ancestor of Emacs, which was originally implemented in TECO macros. TECO is not only an editor but also an interpreted programming language for text manipulation. Arbitrary programs (called "macros") for searching and modifying text give it great power. Unlike regular expressions, however, the language was imperative, though some versions had an "or" operator in string search. TECO does not really have syntax; each character in a program is an imperative command, dispatched to its corresponding routine. That routine may read further characters from the program stream (giving the effect of string arguments), change the position of the "program counter" (giving the effect of control structures), or push values onto a value stack (giving the effect of nested parentheses). But there is nothing to prevent operations like jumping into the middle of a comment, since there is no syntax and no parsing. TECO ignores case and whitespace (except tab, which is an insertion command).',
    "Original author(s)": "Dan Murphy",
    "Initial release": "1962/63",
    "Operating system":
      "OS/8, ITS, TOPS-10, TOPS-20, RT-11, RSTS/E, RSX-11, OpenVMS, Multics",
    Type: "Text editor",
    id: "xMQU",
  },
  {
    name: "TELCOMP",
    description:
      "It was an interactive, conversational language based on JOSS, developed by BBN after Cliff Shaw from RAND visited the labs in 1964 as part of the NIH survey. It was first implemented on the PDP-1 and was used to provide a commercial time sharing service by BBN in the Boston area and later by Time Sharing Ltd. in the United Kingdom. In 1996, Leo Beranek said \"We even developed a programming language called TELCOMP that to this day, some say was better than the programming language that the industry adopted, namely BASIC.\" There were at least three versions: TELCOMP I, TELCOMP II, and TELCOMP III. TELCOMP I was implemented on the PDP-1, TELCOMP II on the PDP-7 and TELCOMP III on the PDP-10, running on DEC 's TOPS-10 operating system or on BBN's own TENEX operating system.",
    Developer: "BBN",
    "First appeared": "1965",
    id: "Z_C1",
  },
  {
    name: "TeX",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/TeX_logo.svg/100px-TeX_logo.svg.png",
    description:
      'TeX (/tɛx/, see below), stylized within the system as TEX, is a typesetting system which was designed and written by Donald Knuth and first released in 1978. TeX is a popular means of typesetting complex mathematical formulae; it has been noted as one of the most sophisticated digital typographical systems. TeX is widely used in academia, especially in mathematics, computer science, economics, political science, engineering, linguistics, physics, statistics, and quantitative psychology. It has long since displaced Unix troff,[b] the previously favored formatting system, in most Unix installations. It is also used for many other typesetting tasks, especially in the form of LaTeX, ConTeXt, and other macro packages. TeX was designed with two main goals in mind: to allow anybody to produce high-quality books with minimal effort, and to provide a system that would give exactly the same results on all computers, at any point in time (together with the Metafont language for font description and the Computer Modern family of typefaces). TeX is free software, which made it accessible to a wide range of users. When the first paper volume of Donald Knuth\'s The Art of Computer Programming was published in 1968, it was typeset using hot metal typesetting set by a Monotype machine. This method, dating back to the 19th century, produced a "classic style" appreciated by Knuth. When the second edition was published, in 1976, the whole book had to be typeset again because the Monotype technology had been largely replaced by phototypesetting, and the original fonts were no longer available. When Knuth received the galley proofs of the new book on 30 March 1977, he found them inferior.',
    "Developer(s)": "Donald Knuth",
    "Initial release": "1978; 44 years ago",
    "Stable release": "3.141592653 / February 2021; 11 months ago",
    Repository: "www.tug.org/svn/texlive/ ",
    "Written in": "WEB/Pascal",
    "Operating system": "Cross-platform",
    Type: "Typesetting",
    License: "Permissive free software",
    Website: "tug.org",
    "Filename extension": ".tex",
    "Internet media type": "application/x-tex [a]",
    "Type of format": "Document file format",
    other_details: {
      type: "markup",
      color: "#3D6117",
      ace_mode: "tex",
      codemirror_mode: "stex",
      codemirror_mime_type: "text/x-stex",
      wrap: true,
      aliases: ["latex"],
      extensions: [
        ".tex",
        ".aux",
        ".bbx",
        ".bib",
        ".cbx",
        ".cls",
        ".dtx",
        ".ins",
        ".lbx",
        ".ltx",
        ".mkii",
        ".mkiv",
        ".mkvi",
        ".sty",
        ".toc",
      ],
      language_id: 369,
    },
    id: "CEYR",
  },
  {
    name: "Verilog",
    description:
      "TEX extended the Honeywell Time-Sharing service (TSS) line editor with programmable capabilities which allowed the user greater latitude in developing ease-of-use editing extensions as well as write scripts to automate many other time-sharing tasks formerly done by more complex TSS FORTRAN programs. TEX was a subsystem of Honeywell TSS. Users would enter the TSS command 'tex' to change to a TEX session mode of operation. TEX expressions could be entered directly on the command line or run from script file via the TEX command CALL ⟨filename⟩. TEX programs are a collection of TSS line editing commands, TSS session commands and TEX statements. TEX variables could be inserted into TSS commands and TSS line editor commands via the TEX variable substitution feature. TEX programs were primarily designed to extend the line editor system. Consequently, TEX had no concept of file input/output relying instead on applying line edit commands to the working file and saving as needed. The key developers of TEX at Honeywell were Eric Clamons and Richard Keys with Robert Bemer, famous as the father of ASCII and grandfather of COBOL, acting in an advisory capacity.",
    other_details: {
      type: "programming",
      color: "#b2b7f8",
      extensions: [".v", ".veo"],
      ace_mode: "verilog",
      codemirror_mode: "verilog",
      codemirror_mime_type: "text/x-verilog",
      language_id: 387,
    },
    id: "Xbm5",
  },
  {
    name: "VHDL",
    description:
      "By using TIE, the user can customize the Xtensa architecture by adding custom instructions and register files, instantiating TIE Ports and Queues for multiprocessor communication, and adding pre-configured extensions (such as Tensilica's DSP). Software applications can greatly benefit from properly targeted user-defined instructions, while TIE ports and TIE queues facilitate multiprocessor communication by adding separate input and output interfaces to the processor core. Using the TIE language and Xtensa Xplorer toolkit, the generation and verification of the instructions used to extend the processor ISA are automated. Such automation helps to reduce the hardware verification time that typically consumes a large percentage of the project duration of a typical hardware developed for the same functionality. TIE was added by Tensilica to extend the instruction set of the Xtensa processors. TIE code can be created in two ways. TIE can be: Manual coding is similar to programming using Verilog, a Hardware description language. Automatic generation of TIE code is done using Xtensa Xpress tool. This is done by first compiling & executing the code using the Xplorer and Xtensa Xpress tools. Xpress analyses the code that will be executed on the processor and generates additional TIE instructions for the processor core. These additional instructions will be automatically substituted when the C/C++ compiler generates the assembly code, preventing any manual intervention. This provides a complete user abstraction to the automatic TIE generation process.",
    other_details: {
      type: "programming",
      color: "#adb2cb",
      extensions: [
        ".vhdl",
        ".vhd",
        ".vhf",
        ".vhi",
        ".vho",
        ".vhs",
        ".vht",
        ".vhw",
      ],
      ace_mode: "vhdl",
      codemirror_mode: "vhdl",
      codemirror_mime_type: "text/x-vhdl",
      language_id: 385,
    },
    id: "Ff7t",
  },
  {
    name: "TMG",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Brainfuck_to_C_translator_in_Unix_TMG.png/225px-Brainfuck_to_C_translator_in_Unix_TMG.png",
    description:
      'Douglas McIlroy ported TMG to an early version of Unix. According to Ken Thompson, McIlroy wrote TMG in TMG on a piece of paper and "decided to give his piece of paper his piece of paper," hand-compiling assembly language that he entered and assembled on Thompson\'s Unix system running on PDP-7. Thompson used TMG in 1970 as a tool to offer Fortran, but due to memory limitations of PDP-7 ended up creating the B programming language which was much influenced by BCPL. The recursive descent algorithm of TMG was studied formally by Alexander Birman and Jeffrey Ullman. The formal description of the algorithms was named TMG recognition scheme (or simply TS).   This programming-language-related article is a stub. You can help Wikipedia by expanding it.',
    "Designed by": "Robert M. McClure",
    Developer: "Douglas McIlroy",
    "First appeared": "1969; 53 years ago",
    "Filename extensions": ".t",
    id: "xiAE",
  },
  {
    name: "Visual DataFlex",
    description:
      "The runtime context keeps track of an individual threads metadata, such as: This context gives definition to an 'environment' where code is executed. A key part to any operational computer language is the notion of a 'Namespace'. This notion of a 'Namespace' refers to the ability to declare a name, along with needed metadata, and call upon the same name to retrieve the values associated with that name. In this definition, the namespace will provide the following key mechanisms:",
    id: "MIym",
  },
  {
    name: "Clarion",
    description:
      "The Clarion development environment (IDE) runs on the Clarion language. The IDE provides code generation facilities via a system of templates which allow programmers to describe the program from an abstract level higher than code statements. The generator then turns this higher level into code, which in turn is then compiled and linked using a normal compiler and linker. This generation layer is sometimes referred to as 4GL programming. Using the generation layer is optional. It is possible to create programs fully at the code level (the so-called 3GL layer), bypassing all code generation facilities. If the templates are used to generate code, then programmers are able to inject their own code into the generated code to alter, or extend, the functions offered by the template layer. This process of embedding code can be done while viewing the surrounding generated code. This mixing of template code and generated code allows the template settings to be updated, and the code regenerated, without loss of the embedded code. The templates (from which the code is generated) are provided in source form and developers are free to create their own templates. Many templates have been written by various developers: some are offered as commercial add-ons, and some are free. Three main Clarion products exist: Professional Edition, Enterprise Edition, and .NET.",
    Paradigms: "Imperative, structured, object-oriented",
    Family: "Pascal",
    Developer:
      "Jensen & Partners International (JPI), Clarion International, SoftVelocity",
    "First appeared": "April 1986; 35 years ago",
    "Stable release": "11 / October 2018; 3 years ago",
    Platform: "IA-32",
    OS: "DOS, Windows",
    License: "Proprietary",
    Website: "www.softvelocity.com",
    other_details: {
      type: "programming",
      color: "#db901e",
      ace_mode: "text",
      extensions: [".clw"],
      tm_scope: "source.clarion",
      language_id: 59,
    },
    id: "PEt8",
  },
  {
    name: "Visual FoxPro",
    description:
      "In 1986, DEC developed a new version of EDT written in TPU, having released EVE (Extensible Versatile Editor), also a TPU-based editor, by mid-1985. TPU is distributed with OpenVMS. It is designed to be used on a terminal or console, so that it is not necessary to have DECwindows installed to use it. Among other things, the Language-Sensitive Editor and EVE are implemented using DECTPU. TPU provides text buffer management APIs in concert with window management APIs which were targeted for the VT-XXX line of terminals.[citation needed] This allowed split-screen windows with scrolling and hence multiple views of the same buffer content.[citation needed] There were also key mapping APIs provided, allowing a wide range of functionality for editing text. The keyboard mapping could be easily adapted by the user or the admin.[citation needed] A version of the vi editor was created by Gregg Wonderly at Oklahoma State University called TPUVI or VITPU.[citation needed] VITPU is still available via the DECUS archives online.[citation needed]",
    id: "4Sbg",
  },
  {
    name: "TRAC",
    description:
      "TRAC is a purely text-based language — a kind of macro language. Unlike traditional ad hoc macro languages of the time, such as those found in assemblers, TRAC is well planned, consistent, and in many senses complete. It has explicit input and output operators, unlike the typical implicit I/O at the outermost macro level, which makes it simultaneously simpler and more versatile than older macro languages. It also differs from traditional macro languages in that TRAC numbers are strings of digits, with integer arithmetic (without specific limits on maximum values) being provided through built-in (\"primitive\") functions. Arguably, one aspect of its completeness is that the concept of error is limited to events like lack of file space and requesting expansion of a string longer than the interpreter's working storage; what would in many languages be described as illegal operations are dealt with in TRAC by defining a result (often a null string) for every possible combination of a function's argument strings. TRAC is a text-processing language, also called a string processing language. The emphasis on strings as strings is so strong that TRAC provides mechanisms for handling the language's own syntactic characters either in their syntactic roles or like any other character, and self-modifying code has more the feel of a natural consequence of typical TRAC programming techniques than of being a special feature.",
    Paradigm: "general-purpose macro processor",
    "Designed by": "Calvin Mooers",
    "First appeared": "1964",
    id: "Grji",
  },
  {
    name: "TTM",
    description:
      "TTM is a string oriented, general purpose macro processing programming language developed in 1968 by Steven Caine and E. Kent Gordon at the California Institute of Technology. The following description is taken from the original TTM reference manual and the subsequent batch processing extension. TTM Is a recursive, interpretive language designed primarily for string manipulation, text editing, macro definition and expansion, and other applications generally classified as systems programming. It is derived, primarily, from GAP and GPM. Initially, TTM was planned as the macro processing portion of an assembler for the IBM System/360 and, as such, was designed to overcome the restrictions and inconsistencies which existed in the standard assemblers for that system.",
    Paradigm: "general-purpose macro processor",
    "Designed by": "Steven M. Caine and E. Kent Gordon",
    "First appeared": "1968",
    "Stable release": "1.0",
    License: "MIT",
    id: "1Y_z",
  },
  {
    name: "Visual Objects",
    description:
      "Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application. Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters. Transact-SQL provides the following statements to declare and set local variables: DECLARE, SET and SELECT. Keywords for flow control in Transact-SQL include BEGIN and END, BREAK, CONTINUE, GOTO, IF and ELSE, RETURN, WAITFOR, and WHILE.",
    id: "W2zu",
  },
  {
    name: "LiveCode",
    description:
      'The environment was introduced in 2001. The "Revolution" development system was based on the MetaCard engine technology which Runtime Revolution later acquired from MetaCard Corporation in 2003. The platform won the Macworld Annual Editor\'s Choice Award for "Best Development Software" in 2004. "Revolution" was renamed "LiveCode" in the fall of 2010. "LiveCode" is developed and sold by Runtime Revolution Ltd., based in Edinburgh, Scotland. In March, 2015, the company was renamed "LiveCode Ltd.", to unify the company name with the product. In April 2013 a free/open source version \'LiveCode Community Edition 6.0\' was published after a successful crowdfunding campaign at Kickstarter. The code base was re-licensed and made available as free and open source software with a version in April 2013. LiveCode runs on iOS, Android, OS X, Windows 95 through Windows 10, Raspberry Pi and several variations of Unix, including Linux, Solaris, and BSD. It can be used for mobile, desktop and server/CGI applications. The iOS (iPhone and iPad) version was released in December 2010. The first version to deploy to the Web was released in 2009. It is the most widely used HyperCard/HyperTalk clone,[citation needed] and the only one that runs on all major operating systems. A developer release of v.8 was announced in New York on March 12, 2015. This major enhancement to the product includes a new, separate development language, known as "LiveCode Builder", which is capable of creating new object classes called "widgets". In earlier versions, the set of object classes was fixed, and could be enhanced only via the use of ordinary procedural languages such as C. The new language, which runs in its own IDE, is a departure from the transitional x-talk paradigm in that it permits typing of variables. But the two environments are fully integrated, and apart from the ability to create new objects, development in LiveCode proceeds in the normal way, within the established IDE. A second crowdfunding campaign to Bring HTML5 to LiveCode reached funding goals of nearly US$400,000 on July 31, 2014. LiveCode developer release 8.0 DP4 (August 31, 2015) was the first to include a standalone deployment option to HTML5.',
    "Developer(s)": "LiveCode Ltd.",
    "Initial release": "July 11, 2001; 20 years ago",
    "Stable release": "9.6.4 / August 31, 2021; 4 months ago",
    "Preview release": "9.6.5RC2 / October 25, 2021; 2 months ago",
    Repository: "github.com/livecode/livecode ",
    "Operating system": "macOS, Windows, Linux, Unix, Android, iOS, HTML5",
    Type: "Programming",
    License: "Proprietary, GPL",
    Website: "livecode.com ",
    Paradigm: "Object-oriented",
    Family: "scripting language",
    Developer: "LiveCode, Ltd",
    "First appeared": "1993",
    Platform: "i386, AMD64, ARM",
    OS: "Windows, macOS, Linux, Unix, Raspberry Pi",
    id: "-2md",
  },
  {
    name: "WebAssembly",
    description:
      "All versions of TTCN need dedicated compilers or interpreters for execution. TTCN is widely used, for example; ETSI, ITU for the testing of telecommunication protocols. Conformance test cases of ETSI standards like ISDN, DECT, GSM, EDGE, 3G, DSRC have also been written in TTCN. Recently it has also been used for testing various protocol standards e.g. Bluetooth, IP. Execution of those test cases against products (e.g. phones, mobile phones, service enablers or network elements) is used to verify that the protocol implementation in those products meet the requirements defined by telecommunication standards. TTCN is often combined with ASN.1.",
    other_details: {
      type: "programming",
      color: "#04133b",
      extensions: [".wast", ".wat"],
      aliases: ["wast", "wasm"],
      tm_scope: "source.webassembly",
      ace_mode: "lisp",
      codemirror_mode: "commonlisp",
      codemirror_mime_type: "text/x-common-lisp",
      language_id: 956556503,
    },
    id: "fXpj",
  },
  {
    name: "Turing",
    image: "https://upload.wikimedia.org/wikipedia/en/1/10/Turing_logo.gif",
    description:
      'Turing 4.1.0 is the latest stable version of Turing. Turing 4.1.1 and Turing 4.1.2 do not allow for stand alone .EXE files to be created and versions before Turing 4.1.0 have outdated syntax and outdated functions. Named after British computer scientist Alan Turing, Turing is used primarily as a teaching language at the high school and university level.[citation needed] Two other versions exist, Object-Oriented Turing and Turing Plus, a systems programming variant. In September 2001, "Object Oriented Turing" was renamed "Turing" and the original Turing was renamed "Classic Turing". Turing is no longer supported by Holt Software Associates in Toronto, Ontario. Currently, Microsoft Windows is the only supported platform. Turing is widely used in high schools in Ontario as an introduction to programming. On November 28, 2007, Turing, which was previously a commercial programming language, became freeware, available to download from the developer\'s website free of charge for personal, commercial, and educational use. The makers of Turing, Holt Software Associates, have since ceased operations, and Turing has seen no further development since November 25, 2007.',
    Paradigm: "multi-paradigm: object-oriented, procedural, concurrent",
    "Designed by": "Ric Holt",
    Developer: "Ric Holt",
    "First appeared": "1991",
    "Typing discipline": "static, manifest",
    OS: "Cross-platform: Sun-4, MIPS, RS-6000",
    other_details: {
      type: "programming",
      color: "#cf142b",
      extensions: [".t", ".tu"],
      tm_scope: "source.turing",
      ace_mode: "text",
      language_id: 375,
    },
    id: "R3bD",
  },
  {
    name: "TUTOR",
    description:
      'TUTOR was originally developed as a special purpose authoring language for designing instructional lessons, and its evolution into a general purpose programming language was unplanned. The name TUTOR was first applied to the authoring language of the PLATO system in the later days of Plato III. The first documentation of the language, under this name, appears to have been The TUTOR Manual, CERL Report X-4, by R. A. Avner and P. Tenczar, Jan. 1969. The article Teaching the Translation of Russian by Computer gives a snapshot of TUTOR from shortly before PLATO IV was operational. Core elements of the language were present, but commands were given in upper case, and instead of using a general mechanism, support for alternative character sets was through special command names such as WRUSS for "write using the Russian character set." Through the 1970s, the developers of TUTOR took advantage of the fact that the entire corpus of TUTOR programs were stored on-line on the same computer system. Whenever they felt a need to change the language, they ran conversion software over the corpus of TUTOR code to revise all existing code so that it conformed with the changes they had made. As a result, once new versions of TUTOR were developed, maintaining compatibility with the PLATO version could be very difficult. Control Data Corporation (CDC), by 1981, had largely expunged the name TUTOR from their PLATO documentation. They referred to the language itself as the PLATO Author Language. The phrase TUTOR file or even TUTOR lesson file survived, however, as the name of the type of file used to store text written in the PLATO Author Language.',
    Paradigm: "imperative (procedural)",
    "Designed by": "Paul Tenczar & Richard Blomme",
    Developer: "Paul Tenczar & University of Illinois at Urbana-Champaign",
    "First appeared": "1969",
    "Typing discipline": "none",
    id: "hraL",
  },
  {
    name: "TXL",
    description:
      "Modern TXL is specifically designed for creating, manipulating and rapidly prototyping language-based descriptions, tools and applications using source transformation. It is a hybrid functional / rule-based language using first order functional programming at the higher level and term rewriting at the lower level. The formal semantics and implementation of TXL are based on formal term rewriting, but the term structures are largely hidden from the user due to the example-like style of pattern specification. Each TXL program has two components: a description of the source structures to be transformed, specified as a (possibly ambiguous) context-free grammar using an extended Backus–Naur Form; and a set of tree transformation rules, specified using pattern / replacement pairs combined using first order functional programming. TXL is designed to allow explicit programmer control over the interpretation, application, order and backtracking of both parsing and rewriting rules, allowing for expression of a wide range of grammar-based techniques such as agile parsing. The first component parses the input expression into a tree using pattern-matching. The second component uses Term-rewriting in a manner similar to Yacc to produce the transformed output. TXL is most commonly used in software analysis and reengineering tasks such as design recovery, and in rapid prototyping of new programming languages and dialects.",
    Paradigm: "Pattern-matching and Term-rewriting",
    "Designed by": "Charles Halpern-Hamu James Cordy",
    Developer: "James Cordy Charles Halpern-Hamu Ian Carmichael Eric Promislow",
    Website: "www.txl.ca",
    other_details: {
      type: "programming",
      extensions: [".txl"],
      tm_scope: "source.txl",
      ace_mode: "text",
      language_id: 366,
    },
    id: "nuhQ",
  },
  {
    name: "TypeScript",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/64px-Typescript_logo_2020.svg.png",
    description:
      "TypeScript is a programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript and adds optional static typing to the language. TypeScript is designed for the development of large applications and transcompiles to JavaScript. As TypeScript is a superset of JavaScript, existing JavaScript programs are also valid TypeScript programs. TypeScript may be used to develop JavaScript applications for both client-side and server-side execution (as with Node.js or Deno). There are multiple options available for transcompilation. Either the default TypeScript Checker can be used, or the Babel compiler can be invoked to convert TypeScript to JavaScript. TypeScript supports definition files that can contain type information of existing JavaScript libraries, much like C++ header files can describe the structure of existing object files. This enables other programs to use the values defined in the files as if they were statically typed TypeScript entities. There are third-party header files for popular libraries such as jQuery, MongoDB, and D3.js. TypeScript headers for the Node.js basic modules are also available, allowing development of Node.js programs within TypeScript. The TypeScript compiler is itself written in TypeScript and compiled to JavaScript. It is licensed under the Apache License 2.0. TypeScript is included as a first-class programming language in Microsoft Visual Studio 2013 Update 2 and later, alongside C# and other Microsoft languages. An official extension allows Visual Studio 2012 to support TypeScript as well. Anders Hejlsberg, lead architect of C# and creator of Delphi and Turbo Pascal, has worked on the development of TypeScript.",
    Paradigm:
      "Multi-paradigm: functional, generic, imperative, object-oriented",
    "Designed by": "Microsoft",
    Developer: "Microsoft",
    "First appeared": "1 October 2012; 9 years ago",
    "Stable release": "4.5.4  / 13 December 2021; 33 days ago",
    "Preview release": "4.5  / 1 October 2021; 3 months ago",
    "Typing discipline": "Duck, gradual, structural",
    License: "Apache License 2.0",
    "Filename extensions": ".ts, .tsx",
    Website: "www.typescriptlang.org",
    other_details: {
      type: "programming",
      color: "#2b7489",
      aliases: ["ts"],
      interpreters: ["node"],
      extensions: [".ts", ".tsx"],
      tm_scope: "source.ts",
      ace_mode: "typescript",
      codemirror_mode: "javascript",
      codemirror_mime_type: "application/typescript",
      language_id: 378,
    },
    id: "Pih5",
  },
  {
    name: "Tynker IDE",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/5/54/Tynker_logo.png/220px-Tynker_logo.png",
    description:
      "Tynker is based on HTML5 and JavaScript, and can be used in browsers, or on tablet computers or smartphones. The Tynker company was founded by Krishna Vedati, Srinivas Mandyam and Kelvin Chong in 2012 in Mountain View, California, United States with funds raised from angel and institutional investors.[citation needed] Tynker for Schools was launched in April 2013, with Tynker for Home the year after. 60 million students, in 90,000 schools, have used Tynker. In 2018, Tynker partnered with Mattel to produce branded coding experiences with Hot Wheels and Monster High. It also has partnerships with Apple, Google, Sylvan Learning, BBC Learning, Infosys Foundation USA, Microsoft, PBS and Lego. In September 2021, Tynker was acquired by Byju's, an Indian multinational educational technology in order to expand in foreign market.",
    "Developer(s)": "Tynker",
    Type: "Educational Programming Language",
    Website: "tynker.com",
    id: "y_0n",
  },
  {
    name: "X10",
    description:
      'Here is the basic "Hello, World!" program: Here is an example using pre- and postconditions. In the example, the IntToStr function validates its input as a string before converting it to an integer:   This programming-language-related article is a stub. You can help Wikipedia by expanding it.',
    other_details: {
      type: "programming",
      aliases: ["xten"],
      ace_mode: "text",
      extensions: [".x10"],
      color: "#4B6BEF",
      tm_scope: "source.x10",
      language_id: 397,
    },
    id: "qhzK",
  },
  {
    name: "UCSD Pascal/p-System",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/UCSD_p-System.svg/150px-UCSD_p-System.svg.png",
    description:
      "In 1977, the University of California, San Diego (UCSD) Institute for Information Systems developed UCSD Pascal to provide students with a common environment that could run on any of the then available microcomputers as well as campus DEC PDP-11 minicomputers. The operating system became known as UCSD p-System. There were three operating systems that IBM offered for its original IBM PC. The first was UCSD p-System, with PC DOS and CP/M-86 as the other two. Vendor SofTech Microsystems emphasized p-System's application portability, with virtual machines for 20 CPUs as of the IBM PC's release. It predicted that users would be able to use applications they purchased on future computers running p-System; advertisements called it \"the Universal Operating System\". PC Magazine denounced UCSD p-System on the IBM PC, stating in a review of Context MBA, written in the language, that it \"simply does not produce good code\". The p-System did not sell very well for the IBM PC, because of a lack of applications and because it was more expensive than the other choices. Previously, IBM had offered the UCSD p-System as an option for Displaywriter, an 8086-based dedicated word processing machine (not to be confused with IBM's DisplayWrite word processing software). (The Displaywriter's native operating system had been developed completely internally and was not opened for end-user programming.) Notable extensions to standard Pascal include separately compilable Units and a String type. Some intrinsics were provided to accelerate string processing (e.g. scanning in an array for a particular search pattern); other language extensions were provided to allow the UCSD p-System to be self-compiling and self-hosted.",
    Developer: "University of California, San Diego, SofTech, Pecan",
    "OS family": "p-code operating systems",
    "Working state": "Historic",
    "Initial release": "August 1977; 44 years ago",
    "Latest release": "IV.2.1 R3.3 / November 1984; 37 years ago",
    "Available in": "English",
    Platforms:
      "Apple II, DEC PDP-11, Zilog Z80, MOS 6502, Motorola 68000, x86, Osborne Executive, Pascal MicroEngine, TI 99/4A",
    "Kernel type": "p-code virtual machine",
    id: "wF3v",
  },
  {
    name: "Umple",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Umple_Logo.png/200px-Umple_Logo.png",
    description:
      "The design of Umple started in 2008 at the University of Ottawa. Umple was open-sourced and its development was moved to Google Code in early 2011 and to GitHub in 2015. Umple was developed, in part, to address certain problems observed in the modelling community.  Most specifically, it was designed to bring modelling and programming into alignment, It was intended to help overcome inhibitions against modelling common in the programmer community. It was also intended to reduce some of the difficulties of model-driven development that arise from the need to use large, expensive or incomplete tools. One design objective is to enable programmers to model in a way they see as natural, by adding modelling constructs to programming languages. Umple can be used to represent in a textual manner many UML modelling entities found in class diagrams and state diagrams. Umple can generate code for these in various programming languages. Currently Umple fully supports Java, C++ and PHP as target programming languages and has functional, but somewhat incomplete support for Ruby. Umple also incorporates various features not related to UML, such as the Singleton pattern, keys, immutability, mixins and aspect-oriented code injection.",
    Paradigm: "object-oriented",
    "Designed by": "University of Ottawa",
    Developer:
      "Cruise Group in the Department of Electrical Engineering and Computer Science, Led by Timothy Lethbridge at University of Ottawa",
    "First appeared": "2008",
    "Stable release": "1.31.1 / August 18, 2021",
    "Typing discipline": "static",
    Platform: "JVM",
    License: "MIT License",
    "Filename extensions": ".ump",
    Website: "www.umple.org",
    id: "FyQ0",
  },
  {
    name: "Unicon",
    description:
      "Compared with Icon, many of the new features of Unicon are extensions to the I/O and system interface, to complement Icon's core control and data structures. Rather than providing lower-level APIs as-is from C, Unicon implements higher level and easier to use facilities, enabling rapid development of graphic- and network-intensive applications in addition to Icon's core strengths in text and file processing. When run as a graphical IDE, the Unicon program ui.exe continues to offer links to Icon help. The official Unicon programming book in PDF format is a popular way to learn Unicon. The book includes an introduction to object-oriented development as well as UML. It includes useful chapters on topics such as the use of Unicon for CGI. Recent additions to Unicon include true concurrency. Unicon is not yet Unicode-compliant. There are opportunities posted at a help-wanted page.",
    Paradigm: "object-oriented, procedural",
    "Designed by": "Clint Jeffery",
    OS: "Cross-platform: Windows, Unix",
    License: "GNU General Public License",
    Website: "unicon.sourceforge.net",
    id: "96rp",
  },
  {
    name: "Uniface",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Logo_Payoff_RGB.svg/220px-Logo_Payoff_RGB.svg.png",
    description:
      "Uniface applications are database- and platform-independent. Uniface provides an integration framework that enables Uniface applications to integrate with all major DBMS products such as Oracle, Microsoft SQL Server, MySQL and IBM DB2. In addition, Uniface also supports file systems such as RMS (HP OpenVMS), Sequential files, operating system text files and a wide range of other technologies, such as IBM mainframe-based products (CICS, IMS), web services, SMTP and POP email, LDAP directories, .NET, ActiveX, Component Object Model (COM), C(++) programs, and Java. Uniface operates under Microsoft Windows, various flavors of Unix, Linux, CentOS and IBM i. Uniface can be used in complex systems that maintain critical enterprise data supporting mission-critical business processes such as point-of sale and web-based online shopping, financial transactions, salary administration, and inventory control. It is currently used by thousands of companies in more than 30 countries, with an effective installed base of millions of end-users. Uniface applications range from client/server to web, and from data entry to workflow, as well as portals that are accessed locally, via intranets and the internet. Originally developed in the Netherlands by Inside Automation, later Uniface B.V., the product and company were acquired by Detroit-based Compuware Corp in 1994, and in 2014 was acquired by Marlin Equity Partners and continued as Uniface B.V. global headquartered in Amsterdam. In February 2021 Uniface was acquired by Rocket Software headquartered in Waltham, Massachusetts, USA. Uniface Development Environment—an integrated collection of tools for modelling, implementing, compiling, debugging, and distributing applications.",
    "Original author(s)": "Inside Automation (1984-1986)",
    "Developer(s)": "Uniface (1986–present)",
    "Stable release": "Uniface 10.3.02 / February 8, 2019; 2 years ago",
    "Operating system": "Windows, Unix-like, Linux, IBM i, CentOS",
    "Available in": "English",
    Type: "Integrated Development Environment",
    License: "Commercial",
    Website: "uniface.com",
    id: "ssOS",
  },
  {
    name: "XL",
    description:
      "All statements are assignments, and are separated by #. A statement can consist of multiple assignments, of the form a,b,c := x,y,z, or a := x || b := y || c := z. You can also have a quantified statement list, <# x,y : expression :: statement>, where x and y are chosen randomly among the values that satisfy expression. A quantified assignment is similar. In <|| x,y : expression :: statement >, statement is executed simultaneously for all pairs of x and y that satisfy expression. Bubble sort the array by comparing adjacent numbers, and swapping them if they are in the wrong order. Using  {\\displaystyle \\Theta (n)}  expected time,  {\\displaystyle \\Theta (n)}  processors and  {\\displaystyle \\Theta (n^{2})}  expected work. The reason you only have  {\\displaystyle \\Theta (n)}  expected time, is that k is always chosen randomly from  {\\displaystyle \\{0,1\\}} . This can be fixed by flipping k manually. You can sort in  {\\displaystyle \\Theta (\\log n)}  time with rank-sort. You need  {\\displaystyle \\Theta (n^{2})}  processors, and do  {\\displaystyle \\Theta (n^{2})}  work. Using the Floyd–Warshall algorithm all pairs shortest path algorithm, we include intermediate nodes iteratively, and get  {\\displaystyle \\Theta (n)}  time, using  {\\displaystyle \\Theta (n^{2})}  processors and  {\\displaystyle \\Theta (n^{3})}  work.",
    id: "FLkv",
  },
  {
    name: "Unreal Engine",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/UE_Logo_Black_Centered.svg/100px-UE_Logo_Black_Centered.svg.png",
    description:
      "Unreal Engine (UE in short) is a game engine developed by Epic Games, first showcased in the 1998 first-person shooter game Unreal. Initially developed for PC first-person shooters, it has since been used in a variety of genres of three-dimensional (3D) games and has seen adoption by other industries, most notably the film and television industry. Written in C++, the Unreal Engine features a high degree of portability, supporting a wide range of desktop, mobile, console and virtual reality platforms. The latest generation is Unreal Engine 4, which was launched in 2014 under a subscription model. Since 2015, it can be downloaded for free, with its source code available on a GitHub private repository. Epic allows its use in commercial products based on a royalty model, typically asking developers for 5% of revenues from sales, though Epic waives this fee for developers that publish their games through the Epic Games Store. On May 13, 2020, Epic announced that their portion of royalties for games developed in Unreal Engine are waived until developers have earned their first US$1 million in revenue, retroactively applying to January 1, 2020. Unreal Engine 5 is scheduled for full release in early 2022. It is popular among PC and console games with high graphics capabilities and is used for numerous games, as well as finding further use in filmmaking and other business applications. The first-generation Unreal Engine was developed by Tim Sweeney, the founder of Epic Games. Having created editing tools for his shareware games ZZT (1991) and Jill of the Jungle (1992), Sweeney began writing the engine in 1995 for the production of a game that would later become a first-person shooter known as Unreal. After years in development, it debuted with the game's release in 1998, although MicroProse and Legend Entertainment had access to the technology much earlier, licensing it in 1996. According to an interview, Sweeney wrote 90 percent of the code in the engine, including the graphics, tools, and networking.",
    "Original author(s)": "Tim Sweeney",
    "Developer(s)": "Epic Games",
    "Stable release": "4.27  (19 August 2021; 4 months ago) [±]",
    "Written in": "C++",
    Size: "40.9 GB (4.27)",
    License:
      "Source-available commercial software with royalty model for commercial use",
    Website: "docs.unrealengine.com",
    Paradigm: "Object-oriented, generic",
    Developer: "Tim Sweeney",
    "First appeared": "May 1998; 23 years ago",
    "Typing discipline": "Static, strong, safe",
    OS: "Cross-platform (multi-platform)",
    "Filename extensions": ".uc .uci .upkg",
    id: "LVa4",
  },
  {
    name: "Vala",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Vala_Logo.svg/120px-Vala_Logo.svg.png",
    description:
      "Vala is an object-oriented programming language with a self-hosting compiler that generates C code and uses the GObject system. Vala is syntactically similar to C# and includes notable features such as anonymous functions, signals, properties, generics, assisted memory management, exception handling, type inference, and foreach statements. Its developers, Jürg Billeter and Raffaele Sandrini, wanted to bring these features to the plain C runtime with little overhead and no special runtime support by targeting the GObject object system. Rather than compiling directly to machine code or assembly language, it compiles to a lower-level intermediate language. It source-to-source compiles to C, which is then compiled with a C compiler for a given platform, such as GCC or Clang. Using functionality from native code libraries requires writing vapi files, defining the library interfaces. Writing these interface definitions is well-documented for C libraries, especially when based on GObject. Bindings are already available for a large number of libraries, including for C libraries that are not based on GObject, such as the multimedia library SDL, OpenGL, etc. Vala is a programming language that combines the high-level build-time performance of scripting languages with the run-time performance of low-level programming languages. It aims to bring modern programming language features to GNOME developers without imposing any additional runtime requirements and without using a different ABI, compared to applications and libraries written in C. The syntax of Vala is similar to C#, modified to better fit the GObject type system.",
    Paradigm: "Multi-paradigm: imperative, structured, object-oriented",
    Developer: "Jürg Billeter, Raffaele Sandrini",
    "First appeared": "2006; 16 years ago",
    "Stable release":
      "0.54.3 / 30 October 2021; 2 months ago 0.52.7 / 30 October 2021; 2 months ago",
    "Typing discipline": "Static, strong, inferred, structural",
    OS: "Cross-platform all supported by GLib, but distributed as source code only.",
    License: "LGPLv2.1+",
    "Filename extensions": ".vala, .vapi",
    Website: "wiki.gnome.org/Projects/Vala",
    other_details: {
      type: "programming",
      color: "#fbe5cd",
      extensions: [".vala", ".vapi"],
      ace_mode: "vala",
      language_id: 386,
    },
    id: "p9vK",
  },
  {
    name: "Verilog",
    description:
      "Verilog, standardized as IEEE 1364, is a hardware description language (HDL) used to model electronic systems. It is most commonly used in the design and verification of digital circuits at the register-transfer level of abstraction. It is also used in the verification of analog circuits and mixed-signal circuits, as well as in the design of genetic circuits. In 2009, the Verilog standard (IEEE 1364-2005) was merged into the SystemVerilog standard, creating IEEE Standard 1800-2009. Since then, Verilog is officially part of the SystemVerilog language. The current version is IEEE standard 1800-2017. Hardware description languages such as Verilog are similar to software programming languages because they include ways of describing the propagation time and signal strengths (sensitivity). There are two types of assignment operators; a blocking assignment (=), and a non-blocking (<=) assignment. The non-blocking assignment allows designers to describe a state-machine update without needing to declare and use temporary storage variables. Since these concepts are part of Verilog's language semantics, designers could quickly write descriptions of large circuits in a relatively compact and concise form. At the time of Verilog's introduction (1984), Verilog represented a tremendous productivity improvement for circuit designers who were already using graphical schematic capture software and specially written software programs to document and simulate electronic circuits. The designers of Verilog wanted a language with syntax similar to the C programming language, which was already widely used in engineering software development. Like C, Verilog is case-sensitive and has a basic preprocessor (though less sophisticated than that of ANSI C/C++). Its control flow keywords (if/else, for, while, case, etc.) are equivalent, and its operator precedence is compatible with C. Syntactic differences include: required bit-widths for variable declarations, demarcation of procedural blocks (Verilog uses begin/end instead of curly braces {}), and many other minor differences. Verilog requires that variables be given a definite size. In C these sizes are inferred from the 'type' of the variable (for instance an integer type may be 8 bits). A Verilog design consists of a hierarchy of modules. Modules encapsulate design hierarchy, and communicate with other modules through a set of declared input, output, and bidirectional ports. Internally, a module can contain any combination of the following: net/variable declarations (wire, reg, integer, etc.), concurrent and sequential statement blocks, and instances of other modules (sub-hierarchies). Sequential statements are placed inside a begin/end block and executed in sequential order within the block. However, the blocks themselves are executed concurrently, making Verilog a dataflow language.",
    Paradigm: "Structured",
    "First appeared": "1984",
    "Stable release": "IEEE 1364-2005 / 9 November 2005; 16 years ago",
    "Typing discipline": "Static, weak",
    "Filename extensions": ".v, .vh",
    other_details: {
      type: "programming",
      color: "#b2b7f8",
      extensions: [".v", ".veo"],
      ace_mode: "verilog",
      codemirror_mode: "verilog",
      codemirror_mime_type: "text/x-verilog",
      language_id: 387,
    },
    id: "tkES",
  },
  {
    name: "VHDL",
    description:
      'VHDL is named after the United States Department of Defense program that created it, the Very High-Speed Integrated Circuits Program (VHSIC). In the early 1980s, the VHSIC Program sought a new HDL for use in the design of the integrated circuits it aimed to develop. The product of this effort was VHDL Version 7.2, released in 1985. The effort to standardize it as an IEEE standard began in the following year. In 1983, VHDL was originally developed at the behest of the U.S. Department of Defense in order to document the behavior of the ASICs that supplier companies were including in equipment. The standard MIL-STD-454N in Requirement 64 in section 4.5.1 "ASIC documentation in VHDL" explicitly requires documentation of "Microelectronic Devices" in VHDL. The idea of being able to simulate the ASICs from the information in this documentation was so obviously attractive that logic simulators were developed that could read the VHDL files. The next step was the development of logic synthesis tools that read the VHDL and output a definition of the physical implementation of the circuit. Due to the Department of Defense requiring as much of the syntax as possible to be based on Ada, in order to avoid re-inventing concepts that had already been thoroughly tested in the development of Ada,[citation needed] VHDL borrows heavily from the Ada programming language in both concept and syntax.',
    Paradigm: "concurrent, reactive, dataflow",
    "First appeared": "1980s",
    "Stable release": "IEEE 1076-2019 / 23 December 2019; 2 years ago",
    "Typing discipline": "strong",
    "Filename extensions": ".vhd",
    Website: "IEEE VASG",
    other_details: {
      type: "programming",
      color: "#adb2cb",
      extensions: [
        ".vhdl",
        ".vhd",
        ".vhf",
        ".vhi",
        ".vho",
        ".vhs",
        ".vht",
        ".vhw",
      ],
      ace_mode: "vhdl",
      codemirror_mode: "vhdl",
      codemirror_mime_type: "text/x-vhdl",
      language_id: 385,
    },
    id: "X_2u",
  },
  {
    name: "Vim",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Vimlogo.svg/64px-Vimlogo.svg.png",
    description:
      "Vim (/vɪm/; a contraction of Vi IMproved) is a free and open-source, screen-based text editor program for Unix. It is an improved clone of Bill Joy's vi. Vim's author, Bram Moolenaar, derived Vim from a port of the Stevie editor for Amiga and released a version to the public in 1991. Vim is designed for use both from a command-line interface and as a standalone application in a graphical user interface. Vim is released under the Vim license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The Vim license is compatible with the GNU General Public License through a special clause allowing distribution of modified copies under the GNU GPL version 2.0 or later. Since its release for the Amiga, cross-platform development has made it available on many other systems. In 2006, it was voted the most popular editor amongst Linux Journal readers; in 2015 the Stack Overflow developer survey found it to be the third most popular text editor, and in 2019 the fifth most popular development environment. Vim's forerunner, Stevie (ST Editor for VI Enthusiasts), was created by Tim Thompson for the Atari ST in 1987 and further developed by Tony Andrews and G.R. (Fred) Walter. Basing his work on Stevie, Bram Moolenaar began working on Vim for the Amiga computer in 1988, with the first public release (Vim v1.14) in 1991.[better source needed]",
    "Original author(s)": "Bram Moolenaar",
    "Initial release": "November 1, 2015; 6 years ago",
    "Stable release": "0.6.1  / 31 December 2021; 15 days ago",
    Repository: "https://github.com/neovim/neovim",
    "Written in": "C, Vim script, Lua",
    "Operating system": "Microsoft Windows and Unix-like",
    Type: "Text editor",
    License: "Apache-2.0",
    Website: "neovim.io",
    "Other names": "NVim",
    id: "dOny",
  },
  {
    name: "Ethereum",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Ethereum-icon-purple.svg/220px-Ethereum-icon-purple.svg.png",
    description:
      "Ethereum is a decentralized, open-source blockchain with smart contract functionality. Ether (ETH or Ξ) is the native cryptocurrency of the platform. Amongst cryptocurrencies, Ether is second only to Bitcoin in market capitalization. Ethereum was conceived in 2013 by programmer Vitalik Buterin. Additional founders of Ethereum included Gavin Wood, Charles Hoskinson, Anthony Di Iorio and Joseph Lubin. In 2014, development work commenced and was crowdfunded, and the network went live on 30 July 2015. The platform allows anyone to deploy permanent and immutable decentralized applications onto it, with which users can interact. Decentralized finance (DeFi) applications provide a broad array of financial services without the need for typical financial intermediaries like brokerages, exchanges, or banks, such as allowing cryptocurrency users to borrow against their holdings or lend them out for interest. Ethereum also allows for the creation and exchange of NFTs, which are non-interchangeable tokens connected to digital works of art or other real-world items and sold as unique digital property. Additionally, many other cryptocurrencies operate as ERC-20 tokens on top of the Ethereum blockchain and have utilized the platform for initial coin offerings. Ethereum has started implementing a series of upgrades called Ethereum 2.0, which includes a transition to proof of stake and aims to increase transaction throughput using sharding. Ethereum was initially described in a white paper by Vitalik Buterin, a programmer and co-founder of Bitcoin Magazine, in late 2013 with a goal of building decentralized applications. Buterin argued to the bitcoin core developers that Bitcoin and blockchain technology could benefit from other applications besides money and needed a more robust language for application development that could lead to attaching real-world assets, such as stocks and property, to the blockchain. In 2013, Buterin briefly worked with eToro CEO Yoni Assia on the Colored Coins project and drafted its white paper outlining additional use cases for blockchain technology. However, after failing to gain agreement on how the project should proceed, he proposed the development of a new platform with a more robust scripting language—a Turing-complete programming language—that would eventually become Ethereum.",
    "Original author(s)": "Vitalik Buterin Gavin Wood",
    "Developer(s)":
      "Ethereum Foundation, Hyperledger, Nethermind, OpenEthereum, EthereumJS",
    "Initial release": "30 July 2015; 6 years ago",
    "Stable release": "London / 5 August 2021; 5 months ago",
    "Development status": "Active",
    "Software used": "EVM 1 Bytecode",
    "Written in": "Go, Rust, C#, C++, Java, Python",
    "Operating system": "Cross-platform",
    Platform: "x86-64, ARM",
    Size: "991.56 GB (2021-09-30)",
    "Available in": "Multilingual, but primarily English",
    Type: "Distributed computing",
    License: "Open-source licenses",
    "Active hosts": "3,481 nodes (2021-09-30)",
    Website: "ethereum.org",
    id: "sr-S",
  },
  {
    name: "DataFlex",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/3/36/DF_Logo_Compact_RGB.png",
    description:
      "DataFlex can be traced back to 1982 when the company called Data Access Corporation (founded in 1976) created and developed a language allowing application code to run on almost any system architecture, regardless of hardware. It started as a relatively early example of a fully fledged and commercially used fourth-generation programming language (4GL). In its early forms, DataFlex was available for CP/M, MS-DOS, TurboDOS, Novell NetWare, OS/2, Unix, VMS and IBM AIX operating systems. By 1985, DataFlex was applied in a variety of high-tech industries including automated inventory control systems and insurance fraud detection systems. DataFlex has lasted many years as a niche application development environment. The DataFlex product supports many relational database environments: Oracle database, Microsoft SQL Server, IBM DB2, MySQL, PostgreSQL and any ODBC database. DataFlex applications are used by around 3 million users. In 1991, the 3.0 version with a modernized interface was released. In 2014, Data Access released 2014/18.0 version. DataFlex is developed and provided by Data Access Worldwide, a software company with main offices in Miami, Florida, Hengelo, Netherlands, and São Paulo, Brazil. The DataFlex language supports:",
    "Developer(s)": "Data Access Worldwide",
    "Stable release": "20.0. / April 21, 2021; 8 months ago",
    "Operating system": "Microsoft Windows",
    Type: "Object-oriented, Integrated development environment, programming language, application framework, structured, imperative",
    License: "Commercial proprietary software",
    Website: "www.dataaccess.com/DataFlex",
    id: "cffU",
  },
  {
    name: "XSharp (X#)",
    description:
      "Unlike other programming languages, the syntax of VDS is very simple. Each command occupies one line, and has a plain English name that clearly describes its purpose. Variables are typeless, and can hold many kinds of information, for example, numbers or text. Functions are clearly distinguishable with names that start with '@', just like a spreadsheet. The DialogScript language has a simple syntax not unlike MS-DOS batch language. It is designed for ease of use and efficiency when being interpreted by the run-time engine. There are 10 system variables, %0 to %9, which initially have the script file name in %0 and command line parameters in %1 through %9, just as in a batch file. There are also a further 26 user variables, %A to %Z. The contents of all variables (including system ones) can be changed once the script is running. There are now also 4032 global variables. These variables begin with %%, a letter, then alphanumerics plus underscores (e.g. %%my_variable_1.) There is no limit on the length of these user-defined variable names. Comments: Simple Information Message Box:",
    id: "v9I2",
  },
  {
    name: "Visual FoxPro",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/7/7e/VisualFoxProScreenshot.png/300px-VisualFoxProScreenshot.png",
    description:
      'It was derived from FoxPro (originally known as FoxBASE) which was developed by Fox Software beginning in 1984. Fox Technologies merged with Microsoft in 1992, after which the software acquired further features and the prefix "Visual". FoxPro 2.6 worked on Mac OS, DOS, Windows, and Unix. Visual FoxPro 3.0, the first "Visual" version, reduced platform support to only Mac and Windows, and later versions 5, 6, 7, 8 and 9 were Windows-only. The current version of Visual FoxPro is COM-based and Microsoft has stated that they do not intend to create a Microsoft .NET version. Version 9.0, released in December 2004 and updated in October 2007 with the SP2 patch, was the final version of the product. Visual FoxPro originated as a member of the class of languages commonly referred to as "xBase" languages, which have syntax based on the dBase programming language. Other members of the xBase language family include Clipper and Recital (database).',
    "Developer(s)": "Microsoft",
    "Final release": "v9.0 SP2 / October 16, 2007; 14 years ago",
    "Operating system": "Windows 2000, Windows XP, and Windows Server 2003",
    Platform: "IA-32",
    "Available in":
      "IDE: English, German, Spanish Runtime: Above plus French, Chinese, Russian, Czech, Korean",
    Type: "Integrated development environment, programming language",
    License: "Commercial proprietary software",
    Website: "msdn.microsoft.com/vfoxpro",
    id: "szpV",
  },
  {
    name: "XtendYorick",
    description:
      "The implementation, MSJVM, did not pass Sun's compliance tests leading to a lawsuit from Sun, Java's creator. Microsoft ceased such support for the MSJVM on December 31, 2007 (later Oracle bought Sun, and with it Java and its trademarks). Microsoft however, officially started distributing Java again in 2021 (though not bundled with Windows or its web browsers as before), i.e. their build of Oracle's OpenJDK, which Microsoft plans to support for at least 6 years, for LTS versions, i.e. to September 2027 for Java 17. While J++ conformed to the Java language specification, Microsoft did not implement certain features of the official Sun Java implementation in its Visual J++ product line. Remote Method Invocation (Java RMI) and Java Native Interface (JNI) are such examples. In addition, J++ implemented other extensions that were not part of Sun's Java implementation. The inclusion of callbacks and delegates for event handling further contributed to defining J++ as a completely different language merely based on an already existing design concept. Furthermore, J++ applications did not conform to the same standardized method of accessing the underlying operating system functions as any other Java application under Sun's Java SDK. In Microsoft's implementation, an underlying framework called J/Direct provided a base mechanism that allowed J++ applications to completely circumvent Java's class libraries and API in accessing the underlying operating system. Due to this short-cut around the original Java framework, J++ applications were more efficient in taking advantage of Win32 API functions than Java applications.",
    id: "KQ6Z",
  },
  {
    name: "AutoLISP",
    description:
      "AutoLISP is a small, dynamically scoped, dynamically typed Lisp language dialect with garbage collection, immutable list structure, and settable symbols, lacking in such regular Lisp features as macro system, records definition facilities, arrays, functions with variable number of arguments or let bindings. Aside from the core language, most of the primitive functions are for geometry, accessing AutoCAD's internal DWG database, or manipulation of graphical entities in AutoCAD. The properties of these graphical entities are revealed to AutoLISP as association lists in which values are paired with AutoCAD group codes that indicate properties such as definitional points, radii, colors, layers, linetypes, etc. AutoCAD loads AutoLISP code from .LSP files. AutoLISP code can interact with the user through AutoCAD's graphical editor by use of primitive functions that allow the user to pick points, choose objects on screen, and input numbers and other data. AutoLisp also has a built-in graphical user interface (GUI) mini- or domain-specific language (DSL), the Dialog Control Language, for creating modal dialog boxes with automated layout, within AutoCAD. AutoLISP was derived from an early version of XLISP, which was created by David Betz. The language was introduced in AutoCAD Version 2.18 in January 1986, and continued to be enhanced in successive releases up to release 13 in February 1995. After that, its development was neglected by Autodesk in favor of more fashionable development environments like Visual Basic for Applications (VBA), .NET Framework, and ObjectARX. However, it has remained AutoCAD's main user customizing language. Vital-LISP, a considerably enhanced version of AutoLISP including an integrated development environment (IDE), debugger, compiler, and ActiveX support, was developed and sold by third party developer Basis Software. Vital LISP was a superset of the existing AutoLISP language that added VBA-like access to the AutoCAD object model, reactors (event handling for AutoCAD objects), general ActiveX support, and some other general Lisp functions. Autodesk purchased this, renamed it Visual LISP, and briefly sold it as an add-on to AutoCAD release 14 released in May 1997. It was incorporated into AutoCAD 2000 released in March 1999, as a replacement for AutoLISP. Since then, Autodesk has ceased major enhancements to Visual LISP and focused more effort on VBA and .NET, and C++. As of January 31, 2014, Autodesk no longer supports VBA versions older than 7.1. This is part of a long-term process of changing from VBA to .NET for user customizing.",
    Family: "Lisp",
    "Designed by": "David Betz",
    Developers: "Autodesk, Basis Software",
    "First appeared": "January 1986; 36 years ago",
    "Stable release": "13 / February 1995; 26 years ago",
    "Typing discipline": "dynamic",
    Scope: "dynamic",
    Platform: "IA-32",
    OS: "Linux",
    id: "R6vX",
  },
  {
    name: "Visual Prolog",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/8/84/Visual_Prolog_IDE_Screenshot.png/300px-Visual_Prolog_IDE_Screenshot.png",
    description:
      "Visual Prolog contains a compiler which generates x86 machine code. Unlike standard Prolog, programs written in Visual Prolog are statically typed. This allows some errors to be caught at compile-time instead of run-time time. Version 10 introduces object expressions, support for master/slave processes, Microsoft Edge webView2 control and some support for Direct2D+DirectWrite+Windows Imaging Component (see also Visual Prolog 10 New Features). Version 9 introduces bounded polymorphism, extension predicates, threadsafe lock free fact databases, named parameters (see also Visual Prolog 9 New Features). Version 8 introduces presenters, for more user friendly data presentation in debugger and running program (see also Visual Prolog 8 New Features).",
    Paradigm:
      "multi-paradigm: logical, functional, object-oriented, imperative",
    Developer: "PDC A/S",
    "Stable release": "10 build 1002 / July 19, 2021; 5 months ago",
    "Typing discipline": "static, strong, inferred",
    OS: "Windows",
    License: "Proprietary",
    Website: "www.visual-prolog.com",
    id: "uZKn",
  },
  {
    name: "Zebra, ZPL, ZPL2",
    description:
      'WATFIV was used from the late 1960s into the mid-1980s. WATFIV was in turn succeeded by later versions of WATFOR. Because it could complete the three usual steps ("compile-link-go") in just one pass, the system became popular for teaching students computer programming. In the early 1960s, newly formed computer science departments started university programs to teach computer programming languages. The Fortran language had been developed at IBM, but suffered from slow and error-prone three-stage batch processing workflow. In the first stage, the compiler started with source code and produced object code. In the second stage, a linker constructed a complete program using growing libraries of common functions. Finally, the program was repeatedly executed with data for the typical scientific and business problems of customers. Each step often included a new set of punched cards or tape. Students, on the other hand, had very different requirements. Their programs were generally short, but usually contained logic and syntax errors, resulting in time-consuming repetition of the steps and confusing "core dumps" (It often took a full day to submit and receive the successful or failed output from the computer operator). Once their programs worked correctly, they were turned in and not run again. In 1961, the University of Wisconsin developed a technology called FORGO for the IBM 1620 which combined some of the steps. Similar experiments were carried out at Purdue University on the IBM 7090 in a system called PUFFT. In summer 1965, four undergraduate students of the University of Waterloo, Gus German, James G. Mitchell Richard Shirley and Robert Zarnke, led by Peter Shantz, developed a Fortran compiler for the IBM 7040 computer called WATFOR. Its objectives were fast compilation speed and effective error diagnostics at both compile and execution time. It eliminates the need for a separate linking step and, as a result, FORTRAN programs which contain no syntax errors are placed into immediate execution. Professor J. Wesley Graham provided leadership throughout the project.',
    id: "2uYo",
  },
  {
    name: "WebAssembly",
    image:
      "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/WebAssembly_Logo.svg/220px-WebAssembly_Logo.svg.png",
    description:
      "WebAssembly (sometimes abbreviated Wasm) defines a portable binary-code format and a corresponding text format for executable programs as well as software interfaces for facilitating interactions between such programs and their host environment. The main goal of WebAssembly is to enable high-performance applications on web pages. It is an open standard  and aims to support any language on any operating system, and in practice all of the most popular languages already have at least some level of support. Announced in 2015 and first released in March 2017, WebAssembly became a World Wide Web Consortium recommendation on 5 December 2019 and it received the Programming Languages Software Award from ACM SIGPLAN in 2021. The World Wide Web Consortium (W3C) maintains the standard with contributions from Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat. WebAssembly was first announced in 2015, and the first demonstration was executing Unity's Angry Bots in Firefox, Google Chrome, and Microsoft Edge. The precursor technologies were asm.js from Mozilla and Google Native Client, and the initial implementation was based on the feature set of asm.js. The asm.js technology already provides near-native code execution speeds and can be considered a viable alternative for browsers that don't support WebAssembly or have it disabled for security reasons.",
    Paradigm: "structured stack machine",
    "Designed by": "W3C",
    Developer: "W3C Mozilla Microsoft Google Apple",
    "First appeared": "March 2017; 4 years ago",
    OS: "Platform independent",
    License: "Apache License 2.0",
    "Filename extensions": ".wat (text format) .wasm (binary format)",
    Website: "webassembly.org",
    other_details: {
      type: "programming",
      color: "#04133b",
      extensions: [".wast", ".wat"],
      aliases: ["wast", "wasm"],
      tm_scope: "source.webassembly",
      ace_mode: "lisp",
      codemirror_mode: "commonlisp",
      codemirror_mime_type: "text/x-common-lisp",
      language_id: 956556503,
    },
    id: "hD6B",
  },
  {
    name: "ZetaLisp",
    description:
      'WebDNA contains a RAM-resident database system (Hybrid In-memory database) that has searching and editing capabilities. A resilient and persistent backup of the RAM databases is maintained to disk. WebDNA code can interweave with css, html/html5 and js/ajax, allowing to mix layout with programming and server-side with client-side scripting. Some instructions allow to interact with remote servers. It is usually considered as an easy-to-learn scripting language and has been designed for webmasters, webdesigners and programmers looking for quick results. WebDNA is made up of a syntax that uses square brackets ("[" "]") and the English language. For example, to display today\'s date on a web page, simply insert "[date]" within the HTML or CSS code where you want the live date to appear; likewise with "[time]". To show some text only to a specific client IP address request, the \'showif\' context can be used: [showif [ipaddress]=xxx.xxx.xxx.xxx]Some Text[/showif]. Most WebDNA tags, contexts and commands follow similar conventions. The WebDNA syntax is based on a simple format: WebDNA instructions are based on two types:',
    id: "g7DM",
  },
  {
    name: "Whiley",
    description:
      "The Whiley project began in 2009 in response to the \"Verifying Compiler Grand Challenge\" put forward by Tony Hoare in 2003. The first public release of Whiley was in June, 2010. Primarily developed by David Pearce, Whiley is an open source project with contributions from a small community. The system has been used for student research projects and in teaching undergraduate classes. It was supported between 2012 and 2014 by the Royal Society of New Zealand's Marsden Fund. The Whiley compiler generates code for the Java virtual machine and can inter-operate with Java and other JVM based languages. The goal of Whiley is to provide a realistic programming language where verification is used routinely and without thought. The idea of such a tool has a long history, but was strongly promoted in the early 2000s through Hoare's Verifying Compiler Grand Challenge. The purpose of this challenge was to spur new efforts to develop a verifying compiler, roughly described as follows:",
    Paradigm: "Imperative, Functional",
    "Designed by": "David J. Pearce",
    "First appeared": "June 2010",
    "Stable release": "0.5.0 / June 7, 2020; 18 months ago",
    "Typing discipline": "Strong, safe, structural, flow-sensitive",
    License: "BSD",
    Website: "whiley.org",
    id: "d7ee",
  },
  {
    name: "ZOPL",
    description:
      'There is no overarching classification scheme for programming languages. Thus, in many cases, a language is listed under multiple headings (in this regard, see "Multiparadigm languages" below). Array programming (also termed vector or multidimensional) languages generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays. Assembly languages directly correspond to a machine language (see below), although there may not be a 1-1 mapping between an individual statement and an individual instruction, so machine code instructions appear in a form understandable by humans. Assembly languages let programmers use symbolic addresses, which the assembler converts to absolute or relocatable addresses. Most assemblers also support macros and symbolic constants. An authoring language is a programming language desined for use by a non-computer expert to easily create tutorials, websites, and other interactive computer programs.',
    id: "WHKz",
  },
  {
    name: "Wolfram Language",
    image:
      "https://upload.wikimedia.org/wikipedia/en/thumb/1/17/Wolfram_Language_Logo_2016.svg/120px-Wolfram_Language_Logo_2016.svg.png",
    description:
      "The Wolfram Language was a part of the initial version of Mathematica in 1988. Symbolic aspects of the engine make it a computer algebra system. The language can perform integration, differentiation, matrix manipulations, and solve differential equations using a set of rules. Also in 1988 was the notebook model and the ability to embed sound and images, according to Theodore Gray's patent. An online frontend for the language, WolframAlpha, was released in 2009. Wolfram implemented this website by translating natural language statements into Wolfram-language queries that link to its database. The work leading to Wolfram Alpha also means that Wolfram's implementation of the language now has built-in access to a knowledge-base as well as natural language processing functions. Wolfram also added features for more complex tasks, such as 3D modeling.",
    Paradigm: "Multi-paradigm: term-rewriting, functional, procedural, array",
    "Designed by": "Stephen Wolfram",
    Developer: "Wolfram Research",
    "First appeared": "1988; 34 years ago",
    "Stable release": "13 / December 13, 2021; 32 days ago",
    "Typing discipline": "Dynamic, strong",
    OS: "Cross-platform",
    License: "Proprietary",
    "Filename extensions": ".nb, .m, .wl",
    Website: "www.wolfram.com/language/",
    id: "sCln",
  },
  {
    name: "Z++",
    description:
      "It is currently in a prototype stage and distributed under a GPLv2 license. A 'Hello World' program in Wyvern looks as follows:   This software-engineering-related article is a stub. You can help Wikipedia by expanding it.",
    id: "PpS6",
  },
];

const app = express();

app.get("/api/v1/search/:searchTerm", (req, res) => {
  const id = req.params.searchTerm.toLowerCase();
  const result = allLanguages.filter((lang) =>
    lang.name.toLowerCase().includes(id)
  );
  res.json(result);
});
app.get("/api/v2/search/:searchTerm", (req, res) => {
  const id = req.params.searchTerm.toLowerCase();
  const result = allLanguages
    .filter((lang) => lang.name.toLowerCase().includes(id))
    .map((lang) => {
      return { id: lang.id, name: lang.name, img: lang.image };
    });
  res.json({ result });
});
app.get("/api/v1/:languageID", (req, res) => {
  const queryLanguage = req.params.languageID;
  const lanuage = allLanguages.findIndex((lang) => lang.id == queryLanguage);
  res.json(allLanguages[lanuage]);
});

app.get("/", (req, res) => {
  res.json(
    "Welcome to Languages DB . please use /api/v1/:languageID  or /api/v2/search/:searchTerm "
  );
});
app.listen(process.env.PORT || 3000, () => {
  console.log("SERVER STARTED ");
});
